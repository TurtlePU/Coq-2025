<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="common/css/sf.css" rel="stylesheet" type="text/css" />
<title>Lecture4</title>
<link href="common/jquery-ui/jquery-ui.css" rel="stylesheet">
<script src="common/jquery-ui/external/jquery/jquery.js"></script>
<script src="common/jquery-ui/jquery-ui.js"></script>
<script src="common/toggleproofs.js"></script>
<link href="common/css/lf.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="common/slides.js"></script>
<link href="common/css/slides.css" rel="stylesheet" type="text/css"/>
</head>

<body>

<div id="page">

<div id="header">
<div id='logoinheader'><a href='https://softwarefoundations.cis.upenn.edu'>
<img src='common/media/image/sf_logo_sm.png' alt='Software Foundations Logo'></a></div>
<div class='booktitleinheader'><a href='index.html'>Volume 1: Logical Foundations</a></div>
<ul id='menu'>
   <li class='section_name'><a href='toc.html'>Table of Contents</a></li>
   <li class='section_name'><a href='coqindex.html'>Index</a></li>
   <li class='section_name'><a href='deps.html'>Roadmap</a></li>
</ul>
</div>

<div id="main">

<h1 class="libtitle">Lecture4</h1>


<div class="doc">
<a id="lab202"></a><h1 class="section">Programming with Propositions</h1>

</div>

<div class="doc">
What does it mean to say that "an element <span class="inlinecode"><span class="id" title="var">x</span></span> occurs in a
    list <span class="inlinecode"><span class="id" title="var">l</span></span>"? <ul class="doclist">
<li> If <span class="inlinecode"><span class="id" title="var">l</span></span> is the empty list, then <span class="inlinecode"><span class="id" title="var">x</span></span> cannot occur in it, so the
         property "<span class="inlinecode"><span class="id" title="var">x</span></span> appears in <span class="inlinecode"><span class="id" title="var">l</span></span>" is simply false. 
</li>
</ul>
<ul class="doclist">
<li> Otherwise, <span class="inlinecode"><span class="id" title="var">l</span></span> has the form <span class="inlinecode"><span class="id" title="var">x'</span></span> <span class="inlinecode">::</span> <span class="inlinecode"><span class="id" title="var">l'</span></span>.  In this case, <span class="inlinecode"><span class="id" title="var">x</span></span>
         occurs in <span class="inlinecode"><span class="id" title="var">l</span></span> if it is equal to <span class="inlinecode"><span class="id" title="var">x'</span></span> or if it occurs in
         <span class="inlinecode"><span class="id" title="var">l'</span></span>. 
</li>
</ul>

<div class="paragraph"> </div>

 We can translate this directly into a straightforward recursive
    function taking an element and a list and returning a proposition (!): 
</div>
<div class="code">

<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">In</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">x</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">l</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| [] ⇒ <span class="id" title="var">False</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">x'</span> :: <span class="id" title="var">l'</span> ⇒ <span class="id" title="var">x'</span> = <span class="id" title="var">x</span> ∨ <span class="id" title="var">In</span> <span class="id" title="var">x</span> <span class="id" title="var">l'</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
</div>

<div class="doc">
<a id="lab203"></a><h3 class="section"> </h3>
 When <span class="inlinecode"><span class="id" title="var">In</span></span> is applied to a concrete list, it expands into a
    concrete sequence of nested disjunctions. 
</div>
<div class="code">

<span class="id" title="keyword">Example</span> <span class="id" title="var">In_example_1</span> : <span class="id" title="var">In</span> 4 [1; 2; 3; 4; 5].<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;WORK&nbsp;IN&nbsp;CLASS&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">In_example_2</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>, <span class="id" title="var">In</span> <span class="id" title="var">n</span> [2; 4] →<br/>
&nbsp;&nbsp;<span class="id" title="tactic">∃</span> <span class="id" title="var">n'</span>, <span class="id" title="var">n</span> = 2 × <span class="id" title="var">n'</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;WORK&nbsp;IN&nbsp;CLASS&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<a id="lab204"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 We can also reason about more generic statements involving <span class="inlinecode"><span class="id" title="var">In</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Theorem</span> <span class="id" title="var">In_map</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> (<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">f</span> : <span class="id" title="var">A</span> → <span class="id" title="var">B</span>) (<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>) (<span class="id" title="var">x</span> : <span class="id" title="var">A</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">In</span> <span class="id" title="var">x</span> <span class="id" title="var">l</span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">In</span> (<span class="id" title="var">f</span> <span class="id" title="var">x</span>) (<span class="id" title="var">map</span> <span class="id" title="var">f</span> <span class="id" title="var">l</span>).<br/>
<div class="togglescript" id="proofcontrol1" onclick="toggleDisplay('proof1');toggleDisplay('proofcontrol1')"><span class="show"></span></div>
<div class="proofscript" id="proof1" onclick="toggleDisplay('proof1');toggleDisplay('proofcontrol1')">
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">f</span> <span class="id" title="var">l</span> <span class="id" title="var">x</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">l</span> <span class="id" title="keyword">as</span> [|<span class="id" title="var">x'</span> <span class="id" title="var">l'</span> <span class="id" title="var">IHl'</span>].<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;l&nbsp;=&nbsp;nil,&nbsp;contradiction&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">intros</span> [].<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;l&nbsp;=&nbsp;x'&nbsp;::&nbsp;l'&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">intros</span> [<span class="id" title="var">H</span> | <span class="id" title="var">H</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">rewrite</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">left</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">right</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">IHl'</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>
</div>

<div class="doc">
<a id="lab205"></a><h1 class="section">Applying Theorems to Arguments</h1>

<div class="paragraph"> </div>

 Coq also treats <i>proofs</i> as first-class objects! 
<div class="paragraph"> </div>

 We have seen that we can use <span class="inlinecode"><span class="id" title="keyword">Check</span></span> to ask Coq to check whether
    an expression has a given type: 
</div>
<div class="code">

<span class="id" title="keyword">Check</span> <span class="id" title="var">plus</span> : <span class="id" title="var">nat</span> → <span class="id" title="var">nat</span> → <span class="id" title="var">nat</span>.<br/>
<span class="id" title="keyword">Check</span> @<span class="id" title="var">rev</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">X</span>, <span class="id" title="var">list</span> <span class="id" title="var">X</span> → <span class="id" title="var">list</span> <span class="id" title="var">X</span>.<br/>
</div>

<div class="doc">
We can also use it to check the theorem a particular identifier
    refers to: 
</div>
<div class="code">

<span class="id" title="keyword">Check</span> <span class="id" title="var">add_comm</span>        : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">n</span> + <span class="id" title="var">m</span> = <span class="id" title="var">m</span> + <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">plus_id_example</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">n</span> = <span class="id" title="var">m</span> → <span class="id" title="var">n</span> + <span class="id" title="var">n</span> = <span class="id" title="var">m</span> + <span class="id" title="var">m</span>.<br/>
</div>

<div class="doc">
Coq checks the <i>statements</i> of the <span class="inlinecode"><span class="id" title="var">add_comm</span></span> and
    <span class="inlinecode"><span class="id" title="var">plus_id_example</span></span> theorems in the same way that it checks the
    <i>type</i> of any term (e.g., plus). If we leave off the colon and
    type, Coq will print these types for us.

<div class="paragraph"> </div>

    Why? 
<div class="paragraph"> </div>

<a id="lab206"></a><h3 class="section"> </h3>
 The reason is that the identifier <span class="inlinecode"><span class="id" title="var">add_comm</span></span> actually refers to a
    <i>proof object</i> -- a logical derivation establishing the truth of the
    statement <span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span>,</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">n</span></span>.  The type of this object
    is the proposition that it is a proof of. <a id="lab207"></a><h3 class="section"> </h3>
 The type of an ordinary function tells us what we can do with it.
<ul class="doclist">
<li> If we have a term of type <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>, we can give it two
         <span class="inlinecode"><span class="id" title="var">nat</span></span>s as arguments and get a <span class="inlinecode"><span class="id" title="var">nat</span></span> back.

</li>
</ul>

<div class="paragraph"> </div>

    Similarly, the statement of a theorem tells us what we can use that
    theorem for.
<ul class="doclist">
<li> If we have a term of type <span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span>,</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">m</span></span> and we
         provide it two numbers <span class="inlinecode"><span class="id" title="var">n</span></span> and <span class="inlinecode"><span class="id" title="var">m</span></span> and a third "argument" of type
         <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">m</span></span>, we can derive <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">m</span></span>. 
</li>
</ul>

<div class="paragraph"> </div>

<a id="lab208"></a><h3 class="section"> </h3>
 Coq actually allows us to <i>apply</i> a theorem as if it were a
    function.

<div class="paragraph"> </div>

    This is often handy in proof scripts -- e.g., suppose we want too
    prove the following: 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <span class="id" title="var">add_comm3</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span>, <span class="id" title="var">x</span> + (<span class="id" title="var">y</span> + <span class="id" title="var">z</span>) = (<span class="id" title="var">z</span> + <span class="id" title="var">y</span>) + <span class="id" title="var">x</span>.<br/>
</div>

<div class="doc">
It appears at first sight that we ought to be able to prove this by
    rewriting with <span class="inlinecode"><span class="id" title="var">add_comm</span></span> twice to make the two sides match.  The
    problem is that the second <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> will undo the effect of the
    first. 
</div>
<div class="code">

<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">add_comm</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">add_comm</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;We&nbsp;are&nbsp;back&nbsp;where&nbsp;we&nbsp;started...&nbsp;*)</span><br/>
<span class="id" title="keyword">Abort</span>.<br/>
</div>

<div class="doc">
<a id="lab209"></a><h3 class="section"> </h3>
 We can fix this by applying <span class="inlinecode"><span class="id" title="var">add_comm</span></span> to the arguments we want
    it be to instantiated with.  Then the <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> is forced to happen
    where we want it. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <span class="id" title="var">add_comm3_take3</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span>, <span class="id" title="var">x</span> + (<span class="id" title="var">y</span> + <span class="id" title="var">z</span>) = (<span class="id" title="var">z</span> + <span class="id" title="var">y</span>) + <span class="id" title="var">x</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">add_comm</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<span class="id" title="var">add_comm</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab210"></a><h3 class="section"> </h3>
 If we really wanted, we could in fact do it for both rewrites. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <span class="id" title="var">add_comm3_take4</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span>, <span class="id" title="var">x</span> + (<span class="id" title="var">y</span> + <span class="id" title="var">z</span>) = (<span class="id" title="var">z</span> + <span class="id" title="var">y</span>) + <span class="id" title="var">x</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<span class="id" title="var">add_comm</span> <span class="id" title="var">x</span> (<span class="id" title="var">y</span> + <span class="id" title="var">z</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<span class="id" title="var">add_comm</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab211"></a><h3 class="section"> </h3>
 Here's another example of using a trivial theorem about lists like
    a function. 
</div>
<div class="code">

<span class="id" title="keyword">Theorem</span> <span class="id" title="var">in_not_nil</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">A</span> (<span class="id" title="var">x</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>), <span class="id" title="var">In</span> <span class="id" title="var">x</span> <span class="id" title="var">l</span> → <span class="id" title="var">l</span> ≠ [].<br/>
<div class="togglescript" id="proofcontrol2" onclick="toggleDisplay('proof2');toggleDisplay('proofcontrol2')"><span class="show"></span></div>
<div class="proofscript" id="proof2" onclick="toggleDisplay('proof2');toggleDisplay('proofcontrol2')">
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">x</span> <span class="id" title="var">l</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">unfold</span> <span class="id" title="var">not</span>. <span class="id" title="tactic">intro</span> <span class="id" title="var">Hl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">Hl</span> <span class="id" title="keyword">in</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>
</div>

<div class="doc">
Intuitively, we should be able to use this theorem to prove the special
    case where <span class="inlinecode"><span class="id" title="var">x</span></span> is <span class="inlinecode">42</span>. However, simply invoking the tactic <span class="inlinecode"><span class="id" title="tactic">apply</span></span>
    <span class="inlinecode"><span class="id" title="var">in_not_nil</span></span> will fail because it cannot infer the value of <span class="inlinecode"><span class="id" title="var">x</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <span class="id" title="var">in_not_nil_42</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">nat</span>, <span class="id" title="var">In</span> 42 <span class="id" title="var">l</span> → <span class="id" title="var">l</span> ≠ [].<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">l</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">Fail</span> <span class="id" title="tactic">apply</span> <span class="id" title="var">in_not_nil</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>
</div>

<div class="doc">
<a id="lab212"></a><h3 class="section"> </h3>
 There are several ways to work around this: 
<div class="paragraph"> </div>

 Use <span class="inlinecode"><span class="id" title="tactic">apply</span></span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" title="keyword">with</span></span> <span class="inlinecode">...</span> 
</div>
<div class="code">
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">in_not_nil_42_take2</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">nat</span>, <span class="id" title="var">In</span> 42 <span class="id" title="var">l</span> → <span class="id" title="var">l</span> ≠ [].<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">l</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">in_not_nil</span> <span class="id" title="keyword">with</span> (<span class="id" title="var">x</span> := 42).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab213"></a><h3 class="section"> </h3>
 Use <span class="inlinecode"><span class="id" title="tactic">apply</span></span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" title="keyword">in</span></span> <span class="inlinecode">...</span> 
</div>
<div class="code">
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">in_not_nil_42_take3</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">nat</span>, <span class="id" title="var">In</span> 42 <span class="id" title="var">l</span> → <span class="id" title="var">l</span> ≠ [].<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">l</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">in_not_nil</span> <span class="id" title="keyword">in</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab214"></a><h3 class="section"> </h3>
 Explicitly apply the lemma to the value for <span class="inlinecode"><span class="id" title="var">x</span></span>. 
</div>
<div class="code">
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">in_not_nil_42_take4</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">nat</span>, <span class="id" title="var">In</span> 42 <span class="id" title="var">l</span> → <span class="id" title="var">l</span> ≠ [].<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">l</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">in_not_nil</span> <span class="id" title="var">nat</span> 42).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab215"></a><h3 class="section"> </h3>
 Explicitly apply the lemma to a hypothesis (causing the values of the
    other parameters to be inferred). 
</div>
<div class="code">
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">in_not_nil_42_take5</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">nat</span>, <span class="id" title="var">In</span> 42 <span class="id" title="var">l</span> → <span class="id" title="var">l</span> ≠ [].<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">l</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">in_not_nil</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">H</span>).<br/>
<span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
 <!-- /quiz -->
</div><div class="quiz">


<div class="doc">
Suppose we have
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">a</span>, <span class="id" title="var">b</span> : <span class="id" title="var">nat</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">H<sub>1</sub></span> : <span class="id" title="var">a</span> = <span class="id" title="var">b</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">H<sub>2</sub></span> : <span class="id" title="var">b</span> = 42<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">trans_eq</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">X</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">o</span> : <span class="id" title="var">X</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">n</span> = <span class="id" title="var">m</span> → <span class="id" title="var">m</span> = <span class="id" title="var">o</span> → <span class="id" title="var">n</span> = <span class="id" title="var">o</span>
</span>    What is the type of this proof object?
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">trans_eq</span> <span class="id" title="var">nat</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> 42 <span class="id" title="var">H<sub>1</sub></span> <span class="id" title="var">H<sub>2</sub></span>
</span>
<div class="paragraph"> </div>

    (1) <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">b</span></span>

<div class="paragraph"> </div>

    (2) <span class="inlinecode">42</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">a</span></span>

<div class="paragraph"> </div>

    (3) <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode">42</span>

<div class="paragraph"> </div>

    (4) Does not typecheck

<div class="paragraph"> </div>

 
</div>
<div class="code">
<div class="togglescript" id="proofcontrol3" onclick="toggleDisplay('proof3');toggleDisplay('proofcontrol3')"><span class="show"></span></div>
<div class="proofscript" id="proof3" onclick="toggleDisplay('proof3');toggleDisplay('proofcontrol3')">
<span class="id" title="keyword">Check</span> <span class="id" title="var">trans_eq</span> <span class="id" title="var">nat</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> 42 <span class="id" title="var">H<sub>1</sub></span> <span class="id" title="var">H<sub>2</sub></span><br/>
&nbsp;&nbsp;: <span class="id" title="var">a</span> = 42.<br/>
</div>
</div></div> <!-- /quiz -->
<div class="quiz">


<div class="doc">
Suppose, again, that we have
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">a</span>, <span class="id" title="var">b</span> : <span class="id" title="var">nat</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">H<sub>1</sub></span> : <span class="id" title="var">a</span> = <span class="id" title="var">b</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">H<sub>2</sub></span> : <span class="id" title="var">b</span> = 42<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">trans_eq</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">X</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">o</span> : <span class="id" title="var">X</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">n</span> = <span class="id" title="var">m</span> → <span class="id" title="var">m</span> = <span class="id" title="var">o</span> → <span class="id" title="var">n</span> = <span class="id" title="var">o</span>
</span>    What is the type of this proof object?
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">trans_eq</span> <span class="id" title="var">nat</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">H<sub>1</sub></span> <span class="id" title="var">H<sub>2</sub></span>
</span>
<div class="paragraph"> </div>

    (1) <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">b</span></span>

<div class="paragraph"> </div>

    (2) <span class="inlinecode">42</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">a</span></span>

<div class="paragraph"> </div>

    (3) <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode">42</span>

<div class="paragraph"> </div>

    (4) Does not typecheck

<div class="paragraph"> </div>

 
</div>
<div class="code">
<div class="togglescript" id="proofcontrol4" onclick="toggleDisplay('proof4');toggleDisplay('proofcontrol4')"><span class="show"></span></div>
<div class="proofscript" id="proof4" onclick="toggleDisplay('proof4');toggleDisplay('proofcontrol4')">
<span class="id" title="keyword">Check</span> <span class="id" title="var">trans_eq</span> <span class="id" title="var">nat</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">H<sub>1</sub></span> <span class="id" title="var">H<sub>2</sub></span><br/>
&nbsp;&nbsp;: <span class="id" title="var">a</span> = 42.<br/>
</div>
</div></div> <!-- /quiz -->
<div class="quiz">


<div class="doc">
Suppose, again, that we have
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">a</span>, <span class="id" title="var">b</span> : <span class="id" title="var">nat</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">H<sub>1</sub></span> : <span class="id" title="var">a</span> = <span class="id" title="var">b</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">H<sub>2</sub></span> : <span class="id" title="var">b</span> = 42<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">trans_eq</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">X</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">o</span> : <span class="id" title="var">X</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">n</span> = <span class="id" title="var">m</span> → <span class="id" title="var">m</span> = <span class="id" title="var">o</span> → <span class="id" title="var">n</span> = <span class="id" title="var">o</span>
</span>    What is the type of this proof object?
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">trans_eq</span> <span class="id" title="var">nat</span> <span class="id" title="var">b</span> 42 <span class="id" title="var">a</span> <span class="id" title="var">H<sub>2</sub></span>
</span>
<div class="paragraph"> </div>

    (1) <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">a</span></span>

<div class="paragraph"> </div>

    (2) <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">→</span> <span class="inlinecode">42</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">a</span></span>

<div class="paragraph"> </div>

    (3) <span class="inlinecode">42</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">a</span></span>

<div class="paragraph"> </div>

    (4) Does not typecheck

<div class="paragraph"> </div>

 
</div>
<div class="code">
<div class="togglescript" id="proofcontrol5" onclick="toggleDisplay('proof5');toggleDisplay('proofcontrol5')"><span class="show"></span></div>
<div class="proofscript" id="proof5" onclick="toggleDisplay('proof5');toggleDisplay('proofcontrol5')">
<span class="id" title="keyword">Check</span> <span class="id" title="var">trans_eq</span> <span class="id" title="var">nat</span> <span class="id" title="var">b</span> 42 <span class="id" title="var">a</span> <span class="id" title="var">H<sub>2</sub></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;: 42 = <span class="id" title="var">a</span> → <span class="id" title="var">b</span> = <span class="id" title="var">a</span>.<br/>
</div>
</div></div> <!-- /quiz -->
<div class="quiz">


<div class="doc">
Suppose, again, that we have
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">a</span>, <span class="id" title="var">b</span> : <span class="id" title="var">nat</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">H<sub>1</sub></span> : <span class="id" title="var">a</span> = <span class="id" title="var">b</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">H<sub>2</sub></span> : <span class="id" title="var">b</span> = 42<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">trans_eq</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">X</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">o</span> : <span class="id" title="var">X</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">n</span> = <span class="id" title="var">m</span> → <span class="id" title="var">m</span> = <span class="id" title="var">o</span> → <span class="id" title="var">n</span> = <span class="id" title="var">o</span>
</span>    What is the type of this proof object?
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">trans_eq</span> <span class="id" title="var">_</span> 42 <span class="id" title="var">a</span> <span class="id" title="var">b</span>
</span>
<div class="paragraph"> </div>

    (1) <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">=</span> <span class="inlinecode">42</span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode">42</span>

<div class="paragraph"> </div>

    (2) <span class="inlinecode">42</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">→</span> <span class="inlinecode">42</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">b</span></span>

<div class="paragraph"> </div>

    (3) <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode">42</span> <span class="inlinecode">→</span> <span class="inlinecode">42</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">b</span></span>

<div class="paragraph"> </div>

    (4) Does not typecheck

<div class="paragraph"> </div>

 
</div>
<div class="code">
<div class="togglescript" id="proofcontrol6" onclick="toggleDisplay('proof6');toggleDisplay('proofcontrol6')"><span class="show"></span></div>
<div class="proofscript" id="proof6" onclick="toggleDisplay('proof6');toggleDisplay('proofcontrol6')">
<span class="id" title="keyword">Check</span> <span class="id" title="var">trans_eq</span> <span class="id" title="var">_</span> 42 <span class="id" title="var">a</span> <span class="id" title="var">b</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;: 42 = <span class="id" title="var">a</span> → <span class="id" title="var">a</span> = <span class="id" title="var">b</span> → 42 = <span class="id" title="var">b</span>.<br/>
</div>
</div></div> <!-- /quiz -->
<div class="quiz">


<div class="doc">
Suppose, again, that we have
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">a</span>, <span class="id" title="var">b</span> : <span class="id" title="var">nat</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">H<sub>1</sub></span> : <span class="id" title="var">a</span> = <span class="id" title="var">b</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">H<sub>2</sub></span> : <span class="id" title="var">b</span> = 42<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">trans_eq</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">X</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">o</span> : <span class="id" title="var">X</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">n</span> = <span class="id" title="var">m</span> → <span class="id" title="var">m</span> = <span class="id" title="var">o</span> → <span class="id" title="var">n</span> = <span class="id" title="var">o</span>
</span>    What is the type of this proof object?
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">trans_eq</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">H<sub>2</sub></span> <span class="id" title="var">H<sub>1</sub></span>
</span>
<div class="paragraph"> </div>

    (1) <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">a</span></span>

<div class="paragraph"> </div>

    (2) <span class="inlinecode">42</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">a</span></span>

<div class="paragraph"> </div>

    (3) <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode">42</span>

<div class="paragraph"> </div>

    (4) Does not typecheck

<div class="paragraph"> </div>

 
</div>
<div class="code">
<div class="togglescript" id="proofcontrol7" onclick="toggleDisplay('proof7');toggleDisplay('proofcontrol7')"><span class="show"></span></div>
<div class="proofscript" id="proof7" onclick="toggleDisplay('proof7');toggleDisplay('proofcontrol7')">
<span class="id" title="var">Fail</span> <span class="id" title="keyword">Check</span> <span class="id" title="var">trans_eq</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">H<sub>2</sub></span> <span class="id" title="var">H<sub>1</sub></span>.<br/>
</div>
</div></div> <!-- /quiz -->

<div class="doc">
<a id="lab216"></a><h1 class="section">Working with Decidable Properties</h1>

<div class="paragraph"> </div>

 We've seen two different ways of expressing logical claims in Coq:
    with <i>booleans</i> (of type <span class="inlinecode"><span class="id" title="var">bool</span></span>), and with <i>propositions</i> (of type
    <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>).

<div class="paragraph"> </div>

    Here are the key differences between <span class="inlinecode"><span class="id" title="var">bool</span></span> and <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>:
<pre>
                                           bool     Prop
                                           ====     ====
           decidable?                      yes       no
           useable with match?             yes       no
           works with rewrite tactic?      no        yes
</pre>

<div class="paragraph"> </div>

 Since every function terminates on all inputs in Coq, a function
    of type <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> is a <i>decision procedure</i> -- i.e., it yields
    <span class="inlinecode"><span class="id" title="var">true</span></span> or <span class="inlinecode"><span class="id" title="var">false</span></span> on all inputs.

<div class="paragraph"> </div>

<ul class="doclist">
<li> For example, <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> is a decision procedure for the
        property "is even". 
</li>
</ul>

<div class="paragraph"> </div>

<a id="lab217"></a><h3 class="section"> </h3>
 It follows that there are some properties of numbers that we <i>cannot</i>
    express as functions of type <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>.

<div class="paragraph"> </div>

<ul class="doclist">
<li> For example, the property "is the code of a halting Turing machine"
        is undecidable, so there is no way to write it as a function of
        type <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>.

</li>
</ul>

<div class="paragraph"> </div>

    On the other hand, <span class="inlinecode"><span class="id" title="var">nat</span>→<span class="id" title="keyword">Prop</span></span> is the type of <i>all</i> properties of
    numbers that can be expressed in Coq's logic, including both decidable
    and undecidable ones.

<div class="paragraph"> </div>

<ul class="doclist">
<li> For example, "is the code of a halting Turing machine" is a
        perfectly legitimate mathematical property, and we can absolutely
        represent it as a Coq expression of type <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>.

</li>
</ul>

<div class="paragraph"> </div>

<a id="lab218"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 Since <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> includes <i>both</i> decidable and undecidable properties, we
    have two options when we want to formalize a property that happens to
    be decidable: we can express it either as a boolean computation or as a
    function into <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>. 
<div class="paragraph"> </div>

 For instance, to claim that a number <span class="inlinecode"><span class="id" title="var">n</span></span> is even, we can say
    either that <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> evaluates to <span class="inlinecode"><span class="id" title="var">true</span></span>... 
</div>
<div class="code">
<span class="id" title="keyword">Example</span> <span class="id" title="var">even_42_bool</span> : <span class="id" title="var">even</span> 42 = <span class="id" title="var">true</span>.<br/>
<div class="togglescript" id="proofcontrol8" onclick="toggleDisplay('proof8');toggleDisplay('proofcontrol8')"><span class="show"></span></div>
<div class="proofscript" id="proof8" onclick="toggleDisplay('proof8');toggleDisplay('proofcontrol8')">
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
</div>
</div>

<div class="doc">
... or that there exists some <span class="inlinecode"><span class="id" title="var">k</span></span> such that <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">double</span></span> <span class="inlinecode"><span class="id" title="var">k</span></span>. 
</div>
<div class="code">
<span class="id" title="keyword">Example</span> <span class="id" title="var">even_42_prop</span> : <span class="id" title="var">Even</span> 42.<br/>
<div class="togglescript" id="proofcontrol9" onclick="toggleDisplay('proof9');toggleDisplay('proofcontrol9')"><span class="show"></span></div>
<div class="proofscript" id="proof9" onclick="toggleDisplay('proof9');toggleDisplay('proofcontrol9')">
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">unfold</span> <span class="id" title="var">Even</span>. <span class="id" title="tactic">∃</span> 21. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
</div>
</div>

<div class="doc">
Of course, it would be pretty strange if these two
    characterizations of evenness did not describe the same set of
    natural numbers!  Fortunately, we can prove that they do... 
</div>

<div class="doc">
<a id="lab219"></a><h3 class="section"> </h3>

</div>
<div class="code">
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">even_bool_prop</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">even</span> <span class="id" title="var">n</span> = <span class="id" title="var">true</span> ↔ <span class="id" title="var">Even</span> <span class="id" title="var">n</span>.<br/>
<div class="togglescript" id="proofcontrol12" onclick="toggleDisplay('proof12');toggleDisplay('proofcontrol12')"><span class="show"></span></div>
<div class="proofscript" id="proof12" onclick="toggleDisplay('proof12');toggleDisplay('proofcontrol12')">
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span>. <span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">destruct</span> (<span class="id" title="var">even_double_conv</span> <span class="id" title="var">n</span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">k</span> <span class="id" title="var">Hk</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">Hk</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">∃</span> <span class="id" title="var">k</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> [<span class="id" title="var">k</span> <span class="id" title="var">Hk</span>]. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">Hk</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">even_double</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>
</div>

<div class="doc">
In view of this theorem, we can say that the boolean computation
    <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> is <i>reflected</i> in the truth of the proposition
    <span class="inlinecode"><span class="id" title="tactic">∃</span></span> <span class="inlinecode"><span class="id" title="var">k</span>,</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">double</span></span> <span class="inlinecode"><span class="id" title="var">k</span></span>. 
<div class="paragraph"> </div>

<a id="lab220"></a><h3 class="section"> </h3>
 Similarly, to state that two numbers <span class="inlinecode"><span class="id" title="var">n</span></span> and <span class="inlinecode"><span class="id" title="var">m</span></span> are equal, we can
    say either
<ul class="doclist">
<li> (1) that <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=?</span> <span class="inlinecode"><span class="id" title="var">m</span></span> returns <span class="inlinecode"><span class="id" title="var">true</span></span>, or

</li>
<li> (2) that <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">m</span></span>.

</li>
</ul>
    Again, these two notions are equivalent: 
</div>
<div class="code">

<span class="id" title="keyword">Theorem</span> <span class="id" title="var">eqb_eq</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n<sub>1</sub></span> <span class="id" title="var">n<sub>2</sub></span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">n<sub>1</sub></span> =? <span class="id" title="var">n<sub>2</sub></span> = <span class="id" title="var">true</span> ↔ <span class="id" title="var">n<sub>1</sub></span> = <span class="id" title="var">n<sub>2</sub></span>.<br/>
<div class="togglescript" id="proofcontrol13" onclick="toggleDisplay('proof13');toggleDisplay('proofcontrol13')"><span class="show"></span></div>
<div class="proofscript" id="proof13" onclick="toggleDisplay('proof13');toggleDisplay('proofcontrol13')">
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n<sub>1</sub></span> <span class="id" title="var">n<sub>2</sub></span>. <span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">apply</span> <span class="id" title="var">eqb_true</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">eqb_refl</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>
</div>

<div class="doc">
<a id="lab221"></a><h3 class="section"> </h3>
 Even when the boolean and propositional formulations of a claim are
    interchangeable from a purely logical perspective, it can be more
    convenient to use one over the other. 
<div class="paragraph"> </div>

 For example, there is no effective way to <i>test</i> whether or not a
    <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> is true in a function definition; thus the
    following definition is rejected: 
</div>
<div class="code">

<span class="id" title="var">Fail</span><br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">is_even_prime</span> <span class="id" title="var">n</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">if</span> <span class="id" title="var">n</span> = 2 <span class="id" title="keyword">then</span> <span class="id" title="var">true</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">else</span> <span class="id" title="var">false</span>.<br/>
</div>

<div class="doc">
Rather, we have to state this definition using a boolean equality
    test. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <span class="id" title="var">is_even_prime</span> <span class="id" title="var">n</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">if</span> <span class="id" title="var">n</span> =? 2 <span class="id" title="keyword">then</span> <span class="id" title="var">true</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">else</span> <span class="id" title="var">false</span>.<br/>
</div>

<div class="doc">
<a id="lab222"></a><h3 class="section"> </h3>
 More generally, stating facts using booleans can often enable
    effective proof automation through computation with Coq terms, a
    technique known as <i>proof by reflection</i>.

<div class="paragraph"> </div>

    Consider the following statement: 
</div>
<div class="code">

<span class="id" title="keyword">Example</span> <span class="id" title="var">even_1000</span> : <span class="id" title="var">Even</span> 1000.<br/>
</div>

<div class="doc">
The most direct way to prove this is to give the value of <span class="inlinecode"><span class="id" title="var">k</span></span>
    explicitly. 
</div>
<div class="code">

<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">unfold</span> <span class="id" title="var">Even</span>. <span class="id" title="tactic">∃</span> 500. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
The proof of the corresponding boolean statement is simpler, because we
    don't have to invent the witness <span class="inlinecode">500</span>: Coq's computation mechanism
    does it for us! 
</div>
<div class="code">

<span class="id" title="keyword">Example</span> <span class="id" title="var">even_1000'</span> : <span class="id" title="var">even</span> 1000 = <span class="id" title="var">true</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab223"></a><h3 class="section"> </h3>
 Now, the useful observation is that, since the two notions are
    equivalent, we can use the boolean formulation to prove the other one
    without mentioning the value 500 explicitly: 
</div>
<div class="code">

<span class="id" title="keyword">Example</span> <span class="id" title="var">even_1000''</span> : <span class="id" title="var">Even</span> 1000.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">even_bool_prop</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
Although we haven't gained much in terms of proof-script
    line count in this case, larger proofs can often be made considerably
    simpler by the use of reflection.  As an extreme example, a famous
    Coq proof of the even more famous <i>4-color theorem</i> uses
    reflection to reduce the analysis of hundreds of different cases
    to a boolean computation. 
<div class="paragraph"> </div>

<a id="lab224"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 Another advantage of booleans is that the negation of a "boolean fact"
    is straightforward to state and prove: simply flip the expected boolean
    result. 
</div>
<div class="code">

<span class="id" title="keyword">Example</span> <span class="id" title="var">not_even_1001</span> : <span class="id" title="var">even</span> 1001 = <span class="id" title="var">false</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab225"></a><h3 class="section"> </h3>
 In contrast, propositional negation can be difficult to work with
    directly.

<div class="paragraph"> </div>

    For example, suppose we state the non-evenness of <span class="inlinecode">1001</span>
    propositionally: 
</div>
<div class="code">

<span class="id" title="keyword">Example</span> <span class="id" title="var">not_even_1001'</span> : ~(<span class="id" title="var">Even</span> 1001).<br/>
</div>

<div class="doc">
Proving this directly -- by assuming that there is some <span class="inlinecode"><span class="id" title="var">n</span></span> such that
    <span class="inlinecode">1001</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">double</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> and then somehow reasoning to a contradiction --
    would be rather complicated.

<div class="paragraph"> </div>

    But if we convert it to a claim about the boolean <span class="inlinecode"><span class="id" title="var">even</span></span> function, we
    can let Coq do the work for us. 
</div>
<div class="code">

<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;WORK&nbsp;IN&nbsp;CLASS&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<a id="lab226"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 Conversely, there are complementary situations where it can be easier
    to work with propositions rather than booleans.

<div class="paragraph"> </div>

    In particular, knowing that <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">=?</span> <span class="inlinecode"><span class="id" title="var">m</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">true</span></span> is generally of little
    direct help in the middle of a proof involving <span class="inlinecode"><span class="id" title="var">n</span></span> and <span class="inlinecode"><span class="id" title="var">m</span></span>, but if we
    convert the statement to the equivalent form <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">m</span></span>, we can rewrite
    with it. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <span class="id" title="var">plus_eqb_example</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">n</span> =? <span class="id" title="var">m</span> = <span class="id" title="var">true</span> → <span class="id" title="var">n</span> + <span class="id" title="var">p</span> =? <span class="id" title="var">m</span> + <span class="id" title="var">p</span> = <span class="id" title="var">true</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;WORK&nbsp;IN&nbsp;CLASS&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
Being able to cross back and forth between the boolean and
    propositional worlds will often be convenient in later chapters. 
</div>

<div class="doc">
<a id="lab227"></a><h1 class="section">The Logic of Coq</h1>

<div class="paragraph"> </div>

 Coq's logical core, the <i>Calculus of Inductive Constructions</i>,
    is a "metalanguage for mathematics" in the same sense as familiar
    foundations for paper-and-pencil math, like Zermelo-Fraenkel Set
    Theory (ZFC).

<div class="paragraph"> </div>

    Mostly, the differences are not too important, but a few points are
    useful to understand. 
<div class="paragraph"> </div>

<a id="lab228"></a><h2 class="section">Functional Extensionality</h2>

<div class="paragraph"> </div>

 Coq's logic is quite minimalistic.  This means that one occasionally
    encounters cases where translating standard mathematical reasoning into
    Coq is cumbersome -- or even impossible -- unless we enrich its core
    logic with additional axioms. 
<div class="paragraph"> </div>

 A first instance has to do with equality of functions.  In certain cases Coq can successfully prove equality propositions stating
    that two <i>functions</i> are equal to each other: 
</div>
<div class="code">

<span class="id" title="keyword">Example</span> <span class="id" title="var">function_equality_ex<sub>1</sub></span> :<br/>
&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ 3 + <span class="id" title="var">x</span>) = (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ (<span class="id" title="var">pred</span> 4) + <span class="id" title="var">x</span>).<br/>
<div class="togglescript" id="proofcontrol14" onclick="toggleDisplay('proof14');toggleDisplay('proofcontrol14')"><span class="show"></span></div>
<div class="proofscript" id="proof14" onclick="toggleDisplay('proof14');toggleDisplay('proofcontrol14')">
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
</div>
</div>

<div class="doc">
This works when Coq can simplify the functions to the same expression,
    but this doesn't always happen. 
<div class="paragraph"> </div>

<a id="lab229"></a><h3 class="section"> </h3>
 These two functions are equal just by simplification, but in general
    functions can be equal for more interesting reasons.

<div class="paragraph"> </div>

    In common mathematical practice, two functions <span class="inlinecode"><span class="id" title="var">f</span></span> and <span class="inlinecode"><span class="id" title="var">g</span></span> are
    considered equal if they produce the same output on every input:
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <span class="id" title="var">f</span> <span class="id" title="var">x</span> = <span class="id" title="var">g</span> <span class="id" title="var">x</span>) → <span class="id" title="var">f</span> = <span class="id" title="var">g</span>
</span>    This is known as the principle of <i>functional extensionality</i>. 
<div class="paragraph"> </div>

 However, functional extensionality is not part of Coq's built-in logic.
    This means that some intuitively obvious propositions are not
    provable. 
</div>
<div class="code">

<span class="id" title="keyword">Example</span> <span class="id" title="var">function_equality_ex<sub>2</sub></span> :<br/>
&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="var">plus</span> <span class="id" title="var">x</span> 1) = (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="var">plus</span> 1 <span class="id" title="var">x</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">Fail</span> <span class="id" title="tactic">reflexivity</span>. <span class="id" title="var">Fail</span> <span class="id" title="tactic">rewrite</span> <span class="id" title="var">add_comm</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;Stuck&nbsp;*)</span><br/>
<span class="id" title="keyword">Abort</span>.<br/>
</div>

<div class="doc">
<a id="lab230"></a><h3 class="section"> </h3>
 However, if we like, we can add functional extensionality to Coq
    using the <span class="inlinecode"><span class="id" title="keyword">Axiom</span></span> command. 
</div>
<div class="code">

<span class="id" title="keyword">Axiom</span> <span class="id" title="var">functional_extensionality</span> : <span class="id" title="keyword">∀</span> {<span class="id" title="var">X</span> <span class="id" title="var">Y</span>: <span class="id" title="keyword">Type</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">f</span> <span class="id" title="var">g</span> : <span class="id" title="var">X</span> → <span class="id" title="var">Y</span>},<br/>
&nbsp;&nbsp;(<span class="id" title="keyword">∀</span> (<span class="id" title="var">x</span>:<span class="id" title="var">X</span>), <span class="id" title="var">f</span> <span class="id" title="var">x</span> = <span class="id" title="var">g</span> <span class="id" title="var">x</span>) → <span class="id" title="var">f</span> = <span class="id" title="var">g</span>.<br/>
</div>

<div class="doc">
Defining something as an <span class="inlinecode"><span class="id" title="keyword">Axiom</span></span> has the same effect as stating a
    theorem and skipping its proof using <span class="inlinecode"><span class="id" title="var">Admitted</span></span>, but it alerts the
    reader that this isn't just something we're going to come back and
    fill in later! 
<div class="paragraph"> </div>

<a id="lab231"></a><h3 class="section"> </h3>
 We can now invoke functional extensionality in proofs: 
</div>
<div class="code">

<span class="id" title="keyword">Example</span> <span class="id" title="var">function_equality_ex<sub>2</sub></span> :<br/>
&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="var">plus</span> <span class="id" title="var">x</span> 1) = (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="var">plus</span> 1 <span class="id" title="var">x</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">functional_extensionality</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">add_comm</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab232"></a><h3 class="section"> </h3>
 Naturally, we need to be quite careful when adding new axioms into
    Coq's logic, as this can render it <i>inconsistent</i> -- that is, it may
    become possible to prove every proposition, including <span class="inlinecode"><span class="id" title="var">False</span></span>, <span class="inlinecode">2+2=5</span>,
    etc.!

<div class="paragraph"> </div>

    In general, there is no simple way of telling whether an axiom is safe
    to add: hard work by highly trained mathematicians is often required to
    establish the consistency of any particular combination of axioms.

<div class="paragraph"> </div>

    Fortunately, it is known that adding functional extensionality, in
    particular, <i>is</i> consistent. 
<div class="paragraph"> </div>

<a id="lab233"></a><h3 class="section"> </h3>
 To check whether a particular proof relies on any additional
    axioms, use the <span class="inlinecode"><span class="id" title="keyword">Print</span></span> <span class="inlinecode"><span class="id" title="keyword">Assumptions</span></span> command:
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Print</span> <span class="id" title="keyword">Assumptions</span> <span class="id" title="var">function_equality_ex<sub>2</sub></span>
</span>
</div>
<div class="code">
<span class="comment">(*&nbsp;===&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Axioms:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;functional_extensionality&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;(X&nbsp;Y&nbsp;:&nbsp;Type)&nbsp;(f&nbsp;g&nbsp;:&nbsp;X&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span>&nbsp;Y),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;x&nbsp;:&nbsp;X,&nbsp;f&nbsp;x&nbsp;=&nbsp;g&nbsp;x)&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span>&nbsp;f&nbsp;=&nbsp;g&nbsp;*)</span><br/><hr class='doublespaceincode'/>
 <!-- /quiz -->
</div><div class="quiz">


<div class="doc">
Is the following statement provable by just <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span>, without
    <span class="inlinecode"><span class="id" title="var">functional_extensionality</span></span>?

<div class="paragraph"> </div>

      <span class="inlinecode">(<span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">xs</span></span> <span class="inlinecode">⇒</span> <span class="inlinecode">1</span> <span class="inlinecode">::</span> <span class="inlinecode"><span class="id" title="var">xs</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode">(<span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">xs</span></span> <span class="inlinecode">⇒</span> <span class="inlinecode">[1]</span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" title="var">xs</span>)</span>

<div class="paragraph"> </div>

    (1) Yes

<div class="paragraph"> </div>

    (2) No

<div class="paragraph"> </div>

 
</div>
<div class="code">
<div class="togglescript" id="proofcontrol15" onclick="toggleDisplay('proof15');toggleDisplay('proofcontrol15')"><span class="show"></span></div>
<div class="proofscript" id="proof15" onclick="toggleDisplay('proof15');toggleDisplay('proofcontrol15')">
<span class="id" title="keyword">Example</span> <span class="id" title="var">cons_1_eq_ex</span> : (<span class="id" title="keyword">fun</span> <span class="id" title="var">xs</span> ⇒ 1 :: <span class="id" title="var">xs</span>) = (<span class="id" title="keyword">fun</span> <span class="id" title="var">xs</span> ⇒ [1] ++ <span class="id" title="var">xs</span>).<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
</div>
</div></div> <!-- /quiz -->

<div class="doc">
<a id="lab234"></a><h2 class="section">Classical vs. Constructive Logic</h2>

<div class="paragraph"> </div>

 The following reasoning principle is <i>not</i> derivable in
    Coq (though, again, it can consistently be added as an axiom): 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <span class="id" title="var">excluded_middle</span> := <span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> : <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">P</span> ∨ ¬<span class="id" title="var">P</span>.<br/>
</div>

<div class="doc">
Logics like Coq's, which do not assume the excluded middle, are
    referred to as <i>constructive logics</i>.

<div class="paragraph"> </div>

    More conventional logical systems such as ZFC, in which the
    excluded middle does hold for arbitrary propositions, are referred
    to as <i>classical</i>. 
<div class="paragraph"> </div>

<a id="lab235"></a><h1 class="section">IndProp: Inductively Defined Propositions</h1>

</div>

<div class="doc">
<a id="lab236"></a><h1 class="section">Inductively Defined Propositions</h1>

<div class="paragraph"> </div>

 In the <a href="Logic.html"><span class="inlineref">Logic</span></a> chapter, we looked at several ways of writing
    propositions, including conjunction, disjunction, and existential
    quantification.

<div class="paragraph"> </div>

    In this chapter, we bring yet another new tool into the mix:
    <i>inductively defined propositions</i>.

<div class="paragraph"> </div>

    To begin, some examples... 
</div>

<div class="doc">
<a id="lab237"></a><h2 class="section">Example: The Collatz Conjecture</h2>

<div class="paragraph"> </div>

 The <i>Collatz Conjecture</i> is a famous open problem in number
    theory.

<div class="paragraph"> </div>

    Its statement is quite simple.  First, we define a function <span class="inlinecode"><span class="id" title="var">csf</span></span>
    on numbers, as follows (where <span class="inlinecode"><span class="id" title="var">csf</span></span> stands for "Collatz step function"): 
</div>
<div class="code">

<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">div2</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;0 ⇒ 0<br/>
&nbsp;&nbsp;| 1 ⇒ 0<br/>
&nbsp;&nbsp;| <span class="id" title="var">S</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>) ⇒ <span class="id" title="var">S</span> (<span class="id" title="var">div2</span> <span class="id" title="var">n</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">csf</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">if</span> <span class="id" title="var">even</span> <span class="id" title="var">n</span> <span class="id" title="keyword">then</span> <span class="id" title="var">div2</span> <span class="id" title="var">n</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">else</span> (3 × <span class="id" title="var">n</span>) + 1.<br/>
</div>

<div class="doc">
<a id="lab238"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 Next, we look at what happens when we repeatedly apply <span class="inlinecode"><span class="id" title="var">csf</span></span> to
    some given starting number.  For example, <span class="inlinecode"><span class="id" title="var">csf</span></span> <span class="inlinecode">12</span> is <span class="inlinecode">6</span>, and
    <span class="inlinecode"><span class="id" title="var">csf</span></span> <span class="inlinecode">6</span> is <span class="inlinecode">3</span>, so by repeatedly applying <span class="inlinecode"><span class="id" title="var">csf</span></span> we get the
    sequence <span class="inlinecode">12,</span> <span class="inlinecode">6,</span> <span class="inlinecode">3,</span> <span class="inlinecode">10,</span> <span class="inlinecode">5,</span> <span class="inlinecode">16,</span> <span class="inlinecode">8,</span> <span class="inlinecode">4,</span> <span class="inlinecode">2,</span> <span class="inlinecode">1</span>.

<div class="paragraph"> </div>

    Similarly, if we start with <span class="inlinecode">19</span>, we get the longer sequence <span class="inlinecode">19,</span>
    <span class="inlinecode">58,</span> <span class="inlinecode">29,</span> <span class="inlinecode">88,</span> <span class="inlinecode">44,</span> <span class="inlinecode">22,</span> <span class="inlinecode">11,</span> <span class="inlinecode">34,</span> <span class="inlinecode">17,</span> <span class="inlinecode">52,</span> <span class="inlinecode">26,</span> <span class="inlinecode">13,</span> <span class="inlinecode">40,</span> <span class="inlinecode">20,</span> <span class="inlinecode">10,</span> <span class="inlinecode">5,</span> <span class="inlinecode">16,</span> <span class="inlinecode">8,</span>
    <span class="inlinecode">4,</span> <span class="inlinecode">2,</span> <span class="inlinecode">1</span>.

<div class="paragraph"> </div>

    Both of these sequences eventually reach <span class="inlinecode">1</span>.  The question posed
    by Collatz was: Is the sequence starting from <i>any</i> positive
    natural number guaranteed to reach <span class="inlinecode">1</span> eventually? 
<div class="paragraph"> </div>

<a id="lab239"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 To formalize this question in Coq, we might try to define a
    recursive <i>function</i> that calculates the total number of steps
    that it takes for such a sequence to reach <span class="inlinecode">1</span>. 
</div>
<div class="code">

<span class="id" title="var">Fail</span> <span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">reaches1_in</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">if</span> <span class="id" title="var">n</span> =? 1 <span class="id" title="keyword">then</span> 0<br/>
&nbsp;&nbsp;<span class="id" title="keyword">else</span> 1 + <span class="id" title="var">reaches1_in</span> (<span class="id" title="var">csf</span> <span class="id" title="var">n</span>).<br/>
</div>

<div class="doc">
You can write this definition in a standard programming language.
    This definition is, however, rejected by Coq's termination
    checker, since the argument to the recursive call, <span class="inlinecode"><span class="id" title="var">csf</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>, is not
    "obviously smaller" than <span class="inlinecode"><span class="id" title="var">n</span></span>.

<div class="paragraph"> </div>

    Indeed, this isn't just a pointless limitation: functions in Coq
    are required to be total, to ensure logical consistency.

<div class="paragraph"> </div>

    Moreover, we can't fix it by devising a more clever termination
    checker: deciding whether this particular function is total
    would be equivalent to settling the Collatz conjecture! 
<div class="paragraph"> </div>

<a id="lab240"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 Another idea could be to express the concept of "eventually
    reaches <span class="inlinecode">1</span> in the Collatz sequence" as an <i>recursively defined
    property</i> of numbers <span class="inlinecode"><span class="id" title="var">Collatz_holds_for</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>. 
</div>
<div class="code">

<span class="id" title="var">Fail</span> <span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">Collatz_holds_for</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| 0 ⇒ <span class="id" title="var">False</span><br/>
&nbsp;&nbsp;| 1 ⇒ <span class="id" title="var">True</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">_</span> ⇒ <span class="id" title="keyword">if</span> <span class="id" title="var">even</span> <span class="id" title="var">n</span> <span class="id" title="keyword">then</span> <span class="id" title="var">Collatz_holds_for</span> (<span class="id" title="var">div2</span> <span class="id" title="var">n</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">else</span> <span class="id" title="var">Collatz_holds_for</span> ((3 × <span class="id" title="var">n</span>) + 1)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
</div>

<div class="doc">
This recursive function is also rejected by the termination
    checker, since while we can in principle convince Coq that
    <span class="inlinecode"><span class="id" title="var">div2</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> is smaller than <span class="inlinecode"><span class="id" title="var">n</span></span>, we can't convince it that
    <span class="inlinecode">(3</span> <span class="inlinecode">×</span> <span class="inlinecode"><span class="id" title="var">n</span>)</span> <span class="inlinecode">+</span> <span class="inlinecode">1</span> is smaller than <span class="inlinecode"><span class="id" title="var">n</span></span>. Since it's definitely not! 
<div class="paragraph"> </div>

<a id="lab241"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 Fortunately, there is another way to do it: We can express the
    concept "reaches <span class="inlinecode">1</span> eventually in the Collatz sequence" as an
    <i>inductively defined property</i> of numbers. Intuitively, this
    property is defined by a set of rules:

<div class="paragraph"> </div>

<center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">&nbsp;&nbsp;</td>
  <td class="infrulenamecol" rowspan="3">
    (Chf_one) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">Collatz_holds_for 1</td>
  <td></td>
</tr>
</table></center><center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">even n = true&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Collatz_holds_for (div2 n)</td>
  <td class="infrulenamecol" rowspan="3">
    (Chf_even) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">Collatz_holds_for n</td>
  <td></td>
</tr>
</table></center><center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">even n = false&nbsp;&nbsp;&nbsp;&nbsp;Collatz_holds_for ((3 * n) + 1)</td>
  <td class="infrulenamecol" rowspan="3">
    (Chf_odd) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">Collatz_holds_for n</td>
  <td></td>
</tr>
</table></center>
<div class="paragraph"> </div>

    So there are three ways to prove that a number <span class="inlinecode"><span class="id" title="var">n</span></span> eventually
    reaches 1 in the Collatz sequence:
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">n</span></span> is 1;

</li>
<li> <span class="inlinecode"><span class="id" title="var">n</span></span> is even and <span class="inlinecode"><span class="id" title="var">div2</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> reaches 1;

</li>
<li> <span class="inlinecode"><span class="id" title="var">n</span></span> is odd and <span class="inlinecode">(3</span> <span class="inlinecode">×</span> <span class="inlinecode"><span class="id" title="var">n</span>)</span> <span class="inlinecode">+</span> <span class="inlinecode">1</span> reaches 1.

</li>
</ul>
<a id="lab242"></a><h3 class="section"> </h3>
 We can prove that a number reaches 1 by constructing a (finite)
    derivation using these rules. For instance, here is the derivation
    proving that 12 reaches 1 (where we left out the evenness/oddness
    premises):
<br/>
<span class="inlinecode"><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;———————————————————— (<span class="id" title="var">Chf_one</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Collatz_holds_for</span> 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;———————————————————— (<span class="id" title="var">Chf_even</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Collatz_holds_for</span> 2<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;———————————————————— (<span class="id" title="var">Chf_even</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Collatz_holds_for</span> 4<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;———————————————————— (<span class="id" title="var">Chf_even</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Collatz_holds_for</span> 8<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;———————————————————— (<span class="id" title="var">Chf_even</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Collatz_holds_for</span> 16<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;———————————————————— (<span class="id" title="var">Chf_odd</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Collatz_holds_for</span> 5<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;———————————————————— (<span class="id" title="var">Chf_even</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Collatz_holds_for</span> 10<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;———————————————————— (<span class="id" title="var">Chf_odd</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Collatz_holds_for</span> 3<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;———————————————————— (<span class="id" title="var">Chf_even</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Collatz_holds_for</span> 6<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;———————————————————— (<span class="id" title="var">Chf_even</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Collatz_holds_for</span> 12
</span><a id="lab243"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 Formally in Coq, the <span class="inlinecode"><span class="id" title="var">Collatz_holds_for</span></span> property is
    <i>inductively defined</i>: 
</div>
<div class="code">

<span class="id" title="keyword">Inductive</span> <span class="id" title="var">Collatz_holds_for</span> : <span class="id" title="var">nat</span> → <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">Chf_one</span> : <span class="id" title="var">Collatz_holds_for</span> 1<br/>
&nbsp;&nbsp;| <span class="id" title="var">Chf_even</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">even</span> <span class="id" title="var">n</span> = <span class="id" title="var">true</span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Collatz_holds_for</span> (<span class="id" title="var">div2</span> <span class="id" title="var">n</span>) →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Collatz_holds_for</span> <span class="id" title="var">n</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">Chf_odd</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) :  <span class="id" title="var">even</span> <span class="id" title="var">n</span> = <span class="id" title="var">false</span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Collatz_holds_for</span> ((3 × <span class="id" title="var">n</span>) + 1) →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Collatz_holds_for</span> <span class="id" title="var">n</span>.<br/>
</div>

<div class="doc">
<a id="lab244"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 For particular numbers, we can now prove that the Collatz sequence
    reaches <span class="inlinecode">1</span> (we'll go through the details of how it works a bit
    later in the chapter): 
</div>
<div class="code">

<span class="id" title="keyword">Example</span> <span class="id" title="var">Collatz_holds_for_12</span> : <span class="id" title="var">Collatz_holds_for</span> 12.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">Chf_even</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">Chf_even</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">Chf_odd</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">Chf_even</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">Chf_odd</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">Chf_even</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">Chf_even</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">Chf_even</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">Chf_even</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">Chf_one</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab245"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 The Collatz conjecture then states that the sequence beginning
    from <i>any</i> positive number reaches <span class="inlinecode">1</span>: 
</div>
<div class="code">

<span class="id" title="keyword">Conjecture</span> <span class="id" title="var">collatz</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>, <span class="id" title="var">n</span> ≠ 0 → <span class="id" title="var">Collatz_holds_for</span> <span class="id" title="var">n</span>.<br/>
</div>

<div class="doc">
If you succeed in proving this conjecture, you've got a bright
    future as a number theorist!  But don't spend too long on it --
    it's been open since 1937. 
</div>

<div class="doc">
<a id="lab246"></a><h2 class="section">Example: Binary relation for comparing numbers</h2>

<div class="paragraph"> </div>

 A binary <i>relation</i> on a set <span class="inlinecode"><span class="id" title="var">X</span></span> has Coq type <span class="inlinecode"><span class="id" title="var">X</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">X</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>.
    This is a family of propositions parameterized by two elements of
    <span class="inlinecode"><span class="id" title="var">X</span></span> -- i.e., a proposition about pairs of elements of <span class="inlinecode"><span class="id" title="var">X</span></span>. 
<div class="paragraph"> </div>

 For example, one familiar binary relation on <span class="inlinecode"><span class="id" title="var">nat</span></span> is <span class="inlinecode"><span class="id" title="var">le</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">→</span>
    <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, the less-than-or-equal-to relation, which can be
    inductively defined by the following two rules: 
<div class="paragraph"> </div>


<div class="paragraph"> </div>

<center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">&nbsp;&nbsp;</td>
  <td class="infrulenamecol" rowspan="3">
    (le_n) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">le n n</td>
  <td></td>
</tr>
</table></center><center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">le n m</td>
  <td class="infrulenamecol" rowspan="3">
    (le_S) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">le n (S m)</td>
  <td></td>
</tr>
</table></center>
<div class="paragraph"> </div>

 This corresponds to the following inductive definition in Coq: 
</div>
<div class="code">
<hr class='doublespaceincode'/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">le</span> : <span class="id" title="var">nat</span> → <span class="id" title="var">nat</span> → <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">le_n</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>)   : <span class="id" title="var">le</span> <span class="id" title="var">n</span> <span class="id" title="var">n</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">le_S</span> (<span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">le</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> → <span class="id" title="var">le</span> <span class="id" title="var">n</span> (<span class="id" title="var">S</span> <span class="id" title="var">m</span>).<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Notation</span> &quot;n &lt;= m" := (<span class="id" title="var">le</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>) (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 70).<br/><hr class='doublespaceincode'/>
</div>

<div class="doc">
<a id="lab247"></a><h2 class="section">Example: Transitive Closure</h2>

<div class="paragraph"> </div>

 As another example, the <i>transitive closure</i> of a relation <span class="inlinecode"><span class="id" title="var">R</span></span>
    is the smallest relation that contains <span class="inlinecode"><span class="id" title="var">R</span></span> and that is transitive.
    This can be defined by the following two rules:
<center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">R x y</td>
  <td class="infrulenamecol" rowspan="3">
    (t_step) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">clos_trans R x y</td>
  <td></td>
</tr>
</table></center><center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">clos_trans R x y&nbsp;&nbsp;&nbsp;&nbsp;clos_trans R y z</td>
  <td class="infrulenamecol" rowspan="3">
    (t_trans) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">clos_trans R x z</td>
  <td></td>
</tr>
</table></center>
<div class="paragraph"> </div>

    In Coq this looks as follows:

</div>
<div class="code">

<span class="id" title="keyword">Inductive</span> <span class="id" title="var">clos_trans</span> {<span class="id" title="var">X</span>: <span class="id" title="keyword">Type</span>} (<span class="id" title="var">R</span>: <span class="id" title="var">X</span>→<span class="id" title="var">X</span>→<span class="id" title="keyword">Prop</span>) : <span class="id" title="var">X</span>→<span class="id" title="var">X</span>→<span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">t_step</span> (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">X</span>) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">R</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">clos_trans</span> <span class="id" title="var">R</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">t_trans</span> (<span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span> : <span class="id" title="var">X</span>) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">clos_trans</span> <span class="id" title="var">R</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">clos_trans</span> <span class="id" title="var">R</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">clos_trans</span> <span class="id" title="var">R</span> <span class="id" title="var">x</span> <span class="id" title="var">z</span>.<br/>
</div>

<div class="doc">
<a id="lab248"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 For example, suppose we define a "parent of" relation on a group
    of people... 
</div>
<div class="code">

<span class="id" title="keyword">Inductive</span> <span class="id" title="var">Person</span> : <span class="id" title="keyword">Type</span> := <span class="id" title="var">Sage</span> | <span class="id" title="var">Cleo</span> | <span class="id" title="var">Ridley</span> | <span class="id" title="var">Moss</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">parent_of</span> : <span class="id" title="var">Person</span> → <span class="id" title="var">Person</span> → <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">po_SC</span> : <span class="id" title="var">parent_of</span> <span class="id" title="var">Sage</span> <span class="id" title="var">Cleo</span><br/>
| <span class="id" title="var">po_SR</span> : <span class="id" title="var">parent_of</span> <span class="id" title="var">Sage</span> <span class="id" title="var">Ridley</span><br/>
| <span class="id" title="var">po_CM</span> : <span class="id" title="var">parent_of</span> <span class="id" title="var">Cleo</span> <span class="id" title="var">Moss</span>.<br/>
</div>

<div class="doc">
The <span class="inlinecode"><span class="id" title="var">parent_of</span></span> relation is not transitive, but we can define
   an "ancestor of" relation as its transitive closure: 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <span class="id" title="var">ancestor_of</span> : <span class="id" title="var">Person</span> → <span class="id" title="var">Person</span> → <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">clos_trans</span> <span class="id" title="var">parent_of</span>.<br/>
</div>

<div class="doc">
Here is a derivation showing that Sage is an ancestor of Moss:
<br/>
<span class="inlinecode"><br/>
&nbsp;———————————————————(<span class="id" title="var">po_SC</span>)     ———————————————————(<span class="id" title="var">po_CM</span>)<br/>
&nbsp;<span class="id" title="var">parent_of</span> <span class="id" title="var">Sage</span> <span class="id" title="var">Cleo</span>            <span class="id" title="var">parent_of</span> <span class="id" title="var">Cleo</span> <span class="id" title="var">Moss</span><br/>
—————————————————————(<span class="id" title="var">t_step</span>)  —————————————————————(<span class="id" title="var">t_step</span>)<br/>
<span class="id" title="var">ancestor_of</span> <span class="id" title="var">Sage</span> <span class="id" title="var">Cleo</span>          <span class="id" title="var">ancestor_of</span> <span class="id" title="var">Cleo</span> <span class="id" title="var">Moss</span><br/>
————————————————————————————————————————————————————(<span class="id" title="var">t_trans</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">ancestor_of</span> <span class="id" title="var">Sage</span> <span class="id" title="var">Moss</span>
</span>
</div>

<div class="doc">
<a id="lab249"></a><h2 class="section">Example: Reflexive and Transitive Closure</h2>

<div class="paragraph"> </div>

 As another example, the <i>reflexive and transitive closure</i>
    of a relation <span class="inlinecode"><span class="id" title="var">R</span></span> is the
    smallest relation that contains <span class="inlinecode"><span class="id" title="var">R</span></span> and that is reflexive and
    transitive. This can be defined by the following three rules
    (where we added a reflexivity rule to <span class="inlinecode"><span class="id" title="var">clos_trans</span></span>):
<center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">R x y</td>
  <td class="infrulenamecol" rowspan="3">
    (rt_step) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">clos_refl_trans R x y</td>
  <td></td>
</tr>
</table></center><center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">&nbsp;&nbsp;</td>
  <td class="infrulenamecol" rowspan="3">
    (rt_refl) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">clos_refl_trans R x x</td>
  <td></td>
</tr>
</table></center><center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">clos_refl_trans R x y&nbsp;&nbsp;&nbsp;&nbsp;clos_refl_trans R y z</td>
  <td class="infrulenamecol" rowspan="3">
    (rt_trans) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">clos_refl_trans R x z</td>
  <td></td>
</tr>
</table></center>
</div>

<div class="doc">
<a id="lab250"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 For instance, this enables an equivalent definition of the Collatz
    conjecture.  First we define the binary relation corresponding to
    the Collatz step function <span class="inlinecode"><span class="id" title="var">csf</span></span>: 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <span class="id" title="var">cs</span> (<span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>) : <span class="id" title="keyword">Prop</span> := <span class="id" title="var">csf</span> <span class="id" title="var">n</span> = <span class="id" title="var">m</span>.<br/>
</div>

<div class="doc">
This Collatz step relation can be used in conjunction with the
    reflexive and transitive closure operation to define a Collatz
    multi-step (<span class="inlinecode"><span class="id" title="var">cms</span></span>) relation, expressing that a number <span class="inlinecode"><span class="id" title="var">n</span></span>
    reaches another number <span class="inlinecode"><span class="id" title="var">m</span></span> in zero or more Collatz steps: 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <span class="id" title="var">cms</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> := <span class="id" title="var">clos_refl_trans</span> <span class="id" title="var">cs</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>.<br/>
<span class="id" title="keyword">Conjecture</span> <span class="id" title="var">collatz'</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>, <span class="id" title="var">n</span> ≠ 0 → <span class="id" title="var">cms</span> <span class="id" title="var">n</span> 1.<br/>
</div>

<div class="doc">
<a id="lab251"></a><h2 class="section">Example: Permutations</h2>

<div class="paragraph"> </div>

 The familiar mathematical concept of <i>permutation</i> also has an
    elegant formulation as an inductive relation.  For simplicity,
    let's focus on permutations of lists with exactly three
    elements. We can define them by the following rules:
<center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">&nbsp;&nbsp;</td>
  <td class="infrulenamecol" rowspan="3">
    (perm3_swap12) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">Perm3 [a;b;c] [b;a;c]</td>
  <td></td>
</tr>
</table></center><center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">&nbsp;&nbsp;</td>
  <td class="infrulenamecol" rowspan="3">
    (perm3_swap23) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">Perm3 [a;b;c] [a;c;b]</td>
  <td></td>
</tr>
</table></center><center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">Perm3 l<sub>1</sub> l<sub>2</sub>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Perm3 l<sub>2</sub> l<sub>3</sub></td>
  <td class="infrulenamecol" rowspan="3">
    (perm3_trans) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">Perm3 l<sub>1</sub> l<sub>3</sub></td>
  <td></td>
</tr>
</table></center>    For instance we can derive <span class="inlinecode"><span class="id" title="var">Perm3</span></span> <span class="inlinecode">[1;2;3]</span> <span class="inlinecode">[3;2;1]</span> as follows:
<br/>
<span class="inlinecode"><br/>
————————(<span class="id" title="var">perm_swap12</span>)  —————————————————————(<span class="id" title="var">perm_swap23</span>)<br/>
<span class="id" title="var">Perm3</span> [1;2;3] [2;1;3]  <span class="id" title="var">Perm3</span> [2;1;3] [2;3;1]<br/>
——————————————————————————————(<span class="id" title="var">perm_trans</span>)  ————————————(<span class="id" title="var">perm_swap12</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Perm3</span> [1;2;3] [2;3;1]                   <span class="id" title="var">Perm</span> [2;3;1] [3;2;1]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;—————————————————————————————————————————————————————(<span class="id" title="var">perm_trans</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Perm3</span> [1;2;3] [3;2;1]
</span>
<div class="paragraph"> </div>

<a id="lab252"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 In Coq <span class="inlinecode"><span class="id" title="var">Perm3</span></span> is given the following inductive definition: 
</div>
<div class="code">

<span class="id" title="keyword">Inductive</span> <span class="id" title="var">Perm3</span> {<span class="id" title="var">X</span> : <span class="id" title="keyword">Type</span>} : <span class="id" title="var">list</span> <span class="id" title="var">X</span> → <span class="id" title="var">list</span> <span class="id" title="var">X</span> → <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">perm3_swap12</span> (<span class="id" title="var">a</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span> : <span class="id" title="var">X</span>) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Perm3</span> [<span class="id" title="var">a</span>;<span class="id" title="var">b</span>;<span class="id" title="var">c</span>] [<span class="id" title="var">b</span>;<span class="id" title="var">a</span>;<span class="id" title="var">c</span>]<br/>
&nbsp;&nbsp;| <span class="id" title="var">perm3_swap23</span> (<span class="id" title="var">a</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span> : <span class="id" title="var">X</span>) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Perm3</span> [<span class="id" title="var">a</span>;<span class="id" title="var">b</span>;<span class="id" title="var">c</span>] [<span class="id" title="var">a</span>;<span class="id" title="var">c</span>;<span class="id" title="var">b</span>]<br/>
&nbsp;&nbsp;| <span class="id" title="var">perm3_trans</span> (<span class="id" title="var">l<sub>1</sub></span> <span class="id" title="var">l<sub>2</sub></span> <span class="id" title="var">l<sub>3</sub></span> : <span class="id" title="var">list</span> <span class="id" title="var">X</span>) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Perm3</span> <span class="id" title="var">l<sub>1</sub></span> <span class="id" title="var">l<sub>2</sub></span> → <span class="id" title="var">Perm3</span> <span class="id" title="var">l<sub>2</sub></span> <span class="id" title="var">l<sub>3</sub></span> → <span class="id" title="var">Perm3</span> <span class="id" title="var">l<sub>1</sub></span> <span class="id" title="var">l<sub>3</sub></span>.<br/>
</div>

<div class="doc">
<a id="lab253"></a><h2 class="section">Example: Evenness (yet again)</h2>

<div class="paragraph"> </div>

 We've already seen two ways of stating a proposition that a number
    <span class="inlinecode"><span class="id" title="var">n</span></span> is even: We can say

<div class="paragraph"> </div>

      (1) <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">true</span></span> (using the recursive boolean function <span class="inlinecode"><span class="id" title="var">even</span></span>), or

<div class="paragraph"> </div>

      (2) <span class="inlinecode"><span class="id" title="tactic">∃</span></span> <span class="inlinecode"><span class="id" title="var">k</span>,</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">double</span></span> <span class="inlinecode"><span class="id" title="var">k</span></span> (using an existential quantifier). 
<div class="paragraph"> </div>

<a id="lab254"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 A third possibility, which we'll use as a simple running example
    here, is to say that a number is even if we can
    <i>establish</i> its evenness from the following two rules:
<center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">&nbsp;&nbsp;</td>
  <td class="infrulenamecol" rowspan="3">
    (ev_0) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">ev 0</td>
  <td></td>
</tr>
</table></center><center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">ev n</td>
  <td class="infrulenamecol" rowspan="3">
    (ev_SS) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">ev (S (S n))</td>
  <td></td>
</tr>
</table></center>
<div class="paragraph"> </div>

 To illustrate how this new definition of evenness works, let's
    imagine using it to show that <span class="inlinecode">4</span> is even:
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;———— (<span class="id" title="var">ev_0</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">ev</span> 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;———————————— (<span class="id" title="var">ev_SS</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">ev</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> 0))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;———————————————————— (<span class="id" title="var">ev_SS</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">ev</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> 0))))
</span>
<div class="paragraph"> </div>

<a id="lab255"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 We can translate the informal definition of evenness from above
    into a formal <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> declaration, where each "way that a
    number can be even" corresponds to a separate constructor: 
</div>
<div class="code">

<span class="id" title="keyword">Inductive</span> <span class="id" title="var">ev</span> : <span class="id" title="var">nat</span> → <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">ev_0</span>                       : <span class="id" title="var">ev</span> 0<br/>
&nbsp;&nbsp;| <span class="id" title="var">ev_SS</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">H</span> : <span class="id" title="var">ev</span> <span class="id" title="var">n</span>) : <span class="id" title="var">ev</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>)).<br/>
</div>

<div class="doc">
We put off discussing syntax so far, but there are both
    similarities and a few differences between inductive properties
    like <span class="inlinecode"><span class="id" title="var">ev</span></span> and inductive types like <span class="inlinecode"><span class="id" title="var">nat</span></span> or <span class="inlinecode"><span class="id" title="var">list</span></span>:
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Inductive</span> <span class="id" title="var">list</span> (<span class="id" title="var">X</span>:<span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">nil</span>                       : <span class="id" title="var">list</span> <span class="id" title="var">X</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">cons</span> (<span class="id" title="var">x</span> : <span class="id" title="var">X</span>) (<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">X</span>) : <span class="id" title="var">list</span> <span class="id" title="var">X</span>.
</span> 
<div class="paragraph"> </div>

<a id="lab256"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 Beyond this syntactic distinction, we can think of the inductive
    definition of <span class="inlinecode"><span class="id" title="var">ev</span></span> as defining a Coq property <span class="inlinecode"><span class="id" title="var">ev</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>,
    together with two "evidence constructors": 
</div>
<div class="code">

<span class="id" title="keyword">Check</span> <span class="id" title="var">ev_0</span> : <span class="id" title="var">ev</span> 0.<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">ev_SS</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>), <span class="id" title="var">ev</span> <span class="id" title="var">n</span> → <span class="id" title="var">ev</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>)).<br/>
</div>

<div class="doc">
In fact, Coq also accepts the following equivalent definition of <span class="inlinecode"><span class="id" title="var">ev</span></span>: 
</div>
<div class="code">

<span class="id" title="keyword">Module</span> <span class="id" title="var">EvPlayground</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">ev</span> : <span class="id" title="var">nat</span> → <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">ev_0</span>  : <span class="id" title="var">ev</span> 0<br/>
&nbsp;&nbsp;| <span class="id" title="var">ev_SS</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>), <span class="id" title="var">ev</span> <span class="id" title="var">n</span> → <span class="id" title="var">ev</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>)).<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">End</span> <span class="id" title="var">EvPlayground</span>.<br/>
</div>

<div class="doc">
<a id="lab257"></a><h3 class="section"> </h3>
 These evidence constructors can be thought of as "primitive
    evidence of evenness", and they can be used just like proven
    theorems.  In particular, we can use Coq's <span class="inlinecode"><span class="id" title="tactic">apply</span></span> tactic with the
    constructor names to obtain evidence for <span class="inlinecode"><span class="id" title="var">ev</span></span> of particular
    numbers... 
</div>
<div class="code">

<span class="id" title="keyword">Theorem</span> <span class="id" title="var">ev_4</span> : <span class="id" title="var">ev</span> 4.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">ev_SS</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">ev_SS</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">ev_0</span>. <span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
... or we can use function application syntax to combine several
    constructors: 
</div>
<div class="code">

<span class="id" title="keyword">Theorem</span> <span class="id" title="var">ev_4'</span> : <span class="id" title="var">ev</span> 4.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">apply</span> (<span class="id" title="var">ev_SS</span> 2 (<span class="id" title="var">ev_SS</span> 0 <span class="id" title="var">ev_0</span>)). <span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
In this way, we can also prove theorems that have hypotheses
    involving <span class="inlinecode"><span class="id" title="var">ev</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Theorem</span> <span class="id" title="var">ev_plus4</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>, <span class="id" title="var">ev</span> <span class="id" title="var">n</span> → <span class="id" title="var">ev</span> (4 + <span class="id" title="var">n</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span>. <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">Hn</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">ev_SS</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">ev_SS</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">Hn</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab258"></a><h2 class="section">Constructing Evidence for Permutations</h2>

<div class="paragraph"> </div>

 Similarly we can apply the evidence constructors to obtain
    evidence of <span class="inlinecode"><span class="id" title="var">Perm3</span></span> <span class="inlinecode">[1;2;3]</span> <span class="inlinecode">[3;2;1]</span>: 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <span class="id" title="var">Perm3_rev</span> : <span class="id" title="var">Perm3</span> [1;2;3] [3;2;1].<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">perm3_trans</span> <span class="id" title="keyword">with</span> (<span class="id" title="var">l<sub>2</sub></span>:=[2;3;1]).<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">apply</span> <span class="id" title="var">perm3_trans</span> <span class="id" title="keyword">with</span> (<span class="id" title="var">l<sub>2</sub></span>:=[2;1;3]).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">apply</span> <span class="id" title="var">perm3_swap12</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">apply</span> <span class="id" title="var">perm3_swap23</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">apply</span> <span class="id" title="var">perm3_swap12</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab259"></a><h3 class="section"> </h3>
 And again we can equivalently use function application syntax to
    combine several constructors. Note that the Coq type checker can
    infer not only types, but also nats and lists. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <span class="id" title="var">Perm3_rev'</span> : <span class="id" title="var">Perm3</span> [1;2;3] [3;2;1].<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">perm3_trans</span> <span class="id" title="var">_</span> [2;3;1] <span class="id" title="var">_</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">perm3_trans</span> <span class="id" title="var">_</span> [2;1;3] <span class="id" title="var">_</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">perm3_swap12</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">perm3_swap23</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">perm3_swap12</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>)).<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
So the informal derivation trees we drew above are not too far
    from what's happening formally.  Formally we're using the evidence
    constructors to build <i>evidence trees</i>, similar to the finite trees we
    built using the constructors of data types such as nat, list,
    binary trees, etc. 
</div>

<div class="doc">
<a id="lab260"></a><h1 class="section">Using Evidence in Proofs</h1>

<div class="paragraph"> </div>

 Besides <i>constructing</i> evidence that numbers are even, we can also
    <i>destruct</i> such evidence, reasoning about how it could have been
    built.

<div class="paragraph"> </div>

    Defining <span class="inlinecode"><span class="id" title="var">ev</span></span> with an <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> declaration tells Coq not
    only that the constructors <span class="inlinecode"><span class="id" title="var">ev_0</span></span> and <span class="inlinecode"><span class="id" title="var">ev_SS</span></span> are valid ways to
    build evidence that some number is <span class="inlinecode"><span class="id" title="var">ev</span></span>, but also that these two
    constructors are the <i>only</i> ways to build evidence that numbers
    are <span class="inlinecode"><span class="id" title="var">ev</span></span>. 
<div class="paragraph"> </div>

<a id="lab261"></a><h3 class="section"> </h3>
 In other words, if someone gives us evidence <span class="inlinecode"><span class="id" title="var">E</span></span> for the proposition
    <span class="inlinecode"><span class="id" title="var">ev</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>, then we know that <span class="inlinecode"><span class="id" title="var">E</span></span> must be one of two things:

<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">E</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">ev_0</span></span> and <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">O</span></span>, or

</li>
<li> <span class="inlinecode"><span class="id" title="var">E</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">ev_SS</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span> <span class="inlinecode"><span class="id" title="var">E'</span></span>, where <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span>)</span> and <span class="inlinecode"><span class="id" title="var">E'</span></span> is
        evidence for <span class="inlinecode"><span class="id" title="var">ev</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span>. 
</li>
</ul>

<div class="paragraph"> </div>

 This suggests that it should be possible to do <i>case
    analysis</i> and even <i>induction</i> on evidence of evenness... 
<div class="paragraph"> </div>

<a id="lab262"></a><h2 class="section">Destructing and Inverting Evidence</h2>

<div class="paragraph"> </div>

 We can prove our characterization of evidence for <span class="inlinecode"><span class="id" title="var">ev</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>,
    using <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Theorem</span> <span class="id" title="var">ev_inversion</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">ev</span> <span class="id" title="var">n</span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">n</span> = 0) ∨ (<span class="id" title="tactic">∃</span> <span class="id" title="var">n'</span>, <span class="id" title="var">n</span> = <span class="id" title="var">S</span> (<span class="id" title="var">S</span> <span class="id" title="var">n'</span>) ∧ <span class="id" title="var">ev</span> <span class="id" title="var">n'</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">E</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">E</span> <span class="id" title="keyword">as</span> [ | <span class="id" title="var">n'</span> <span class="id" title="var">E'</span>] <span class="id" title="var">eqn</span>:<span class="id" title="var">EE</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;E&nbsp;=&nbsp;ev_0&nbsp;:&nbsp;ev&nbsp;0&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">left</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;E&nbsp;=&nbsp;ev_SS&nbsp;n'&nbsp;E'&nbsp;:&nbsp;ev&nbsp;(S&nbsp;(S&nbsp;n'))&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">right</span>. <span class="id" title="tactic">∃</span> <span class="id" title="var">n'</span>. <span class="id" title="tactic">split</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">E'</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
Facts like this are often called "inversion lemmas" because they
    allow us to "invert" some given information to reason about all
    the different ways it could have been derived. 
<div class="paragraph"> </div>

<a id="lab263"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 We can use the inversion lemma that we proved above to help
    structure proofs: 
</div>
<div class="code">

<span class="id" title="keyword">Theorem</span> <span class="id" title="var">evSS_ev</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>, <span class="id" title="var">ev</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>)) → <span class="id" title="var">ev</span> <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">E</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">ev_inversion</span> <span class="id" title="keyword">in</span> <span class="id" title="var">E</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">E</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">H<sub>0</sub></span>|<span class="id" title="var">H<sub>1</sub></span>].<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">discriminate</span> <span class="id" title="var">H<sub>0</sub></span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">destruct</span> <span class="id" title="var">H<sub>1</sub></span> <span class="id" title="keyword">as</span> [<span class="id" title="var">n'</span> [<span class="id" title="var">Hnn'</span> <span class="id" title="var">E'</span>]]. <span class="id" title="tactic">injection</span> <span class="id" title="var">Hnn'</span> <span class="id" title="keyword">as</span> <span class="id" title="var">Hnn'</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">Hnn'</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">E'</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab264"></a><h3 class="section"> </h3>
 Coq provides a handy tactic called <span class="inlinecode"><span class="id" title="tactic">inversion</span></span> that does
    the work of our inversion lemma and more besides. 
</div>
<div class="code">

<span class="id" title="keyword">Theorem</span> <span class="id" title="var">evSS_ev'</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">ev</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>)) → <span class="id" title="var">ev</span> <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">E</span>. <span class="id" title="tactic">inversion</span> <span class="id" title="var">E</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n'</span> <span class="id" title="var">E'</span> <span class="id" title="var">Hnn'</span>].<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;We&nbsp;are&nbsp;in&nbsp;the&nbsp;<span class="inlinecode"><span class="id" title="var">E</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">ev_SS</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span> <span class="inlinecode"><span class="id" title="var">E'</span></span>&nbsp;case&nbsp;now.&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">E'</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab265"></a><h3 class="section"> </h3>
 We can use <span class="inlinecode"><span class="id" title="tactic">inversion</span></span> to re-prove some theorems from
    <span class="inlinecode"><span class="id" title="var">Tactics.v</span></span>.

<div class="paragraph"> </div>

    Note that <span class="inlinecode"><span class="id" title="tactic">inversion</span></span> also works on equality propositions. 
</div>
<div class="code">

<span class="id" title="keyword">Theorem</span> <span class="id" title="var">inversion_ex<sub>1</sub></span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">o</span> : <span class="id" title="var">nat</span>),<br/>
&nbsp;&nbsp;[<span class="id" title="var">n</span>; <span class="id" title="var">m</span>] = [<span class="id" title="var">o</span>; <span class="id" title="var">o</span>] → [<span class="id" title="var">n</span>] = [<span class="id" title="var">m</span>].<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">o</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">inversion</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">inversion_ex<sub>2</sub></span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>),<br/>
&nbsp;&nbsp;<span class="id" title="var">S</span> <span class="id" title="var">n</span> = <span class="id" title="var">O</span> → 2 + 2 = 5.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">contra</span>. <span class="id" title="tactic">inversion</span> <span class="id" title="var">contra</span>. <span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab266"></a><h3 class="section"> </h3>
 The tactic <span class="inlinecode"><span class="id" title="tactic">inversion</span></span> actually works on any <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">P</span></span> where
    <span class="inlinecode"><span class="id" title="var">P</span></span> is defined <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span>ly:

<div class="paragraph"> </div>

<ul class="doclist">
<li> For each constructor of <span class="inlinecode"><span class="id" title="var">P</span></span>, make a subgoal where <span class="inlinecode"><span class="id" title="var">H</span></span> is
        constrained by the form of this constructor.

<div class="paragraph"> </div>


</li>
<li> Discard contradictory subgoals (such as <span class="inlinecode"><span class="id" title="var">ev_0</span></span> above).

<div class="paragraph"> </div>


</li>
<li> Generate auxiliary equalities (as with <span class="inlinecode"><span class="id" title="var">ev_SS</span></span> above). 
</li>
</ul>

<div class="paragraph"> </div>

<a id="lab267"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 Let's try to show that our new notion of evenness implies
    our earlier notion (the one based on <span class="inlinecode"><span class="id" title="var">double</span></span>). 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <span class="id" title="var">ev_Even_firsttry</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">ev</span> <span class="id" title="var">n</span> → <span class="id" title="var">Even</span> <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;WORK&nbsp;IN&nbsp;CLASS&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<a id="lab268"></a><h2 class="section">Induction on Evidence</h2>

<div class="paragraph"> </div>

 If this story feels familiar, it is no coincidence: We
    encountered similar problems in the <a href="Induction.html"><span class="inlineref">Induction</span></a> chapter, when
    trying to use case analysis to prove results that required
    induction.  And once again the solution is... induction! 
<div class="paragraph"> </div>

 Let's try proving that lemma again: 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <span class="id" title="var">ev_Even</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">ev</span> <span class="id" title="var">n</span> → <span class="id" title="var">Even</span> <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">Even</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">E</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">E</span> <span class="id" title="keyword">as</span> [|<span class="id" title="var">n'</span> <span class="id" title="var">E'</span> <span class="id" title="var">IH</span>].<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;E&nbsp;=&nbsp;ev_0&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">∃</span> 0. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;E&nbsp;=&nbsp;ev_SS&nbsp;n'&nbsp;E',&nbsp;&nbsp;with&nbsp;IH&nbsp;:&nbsp;Even&nbsp;n'&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">IH</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">k</span> <span class="id" title="var">Hk</span>]. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">Hk</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">∃</span> (<span class="id" title="var">S</span> <span class="id" title="var">k</span>). <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab269"></a><h1 class="section">Case Study: Improving Reflection</h1>

<div class="paragraph"> </div>

 We've seen that we often need to relate boolean
    computations to statements in <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>: 
</div>
<div class="code">

<span class="id" title="keyword">Check</span> <span class="id" title="var">eqb_eq</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n<sub>1</sub></span> <span class="id" title="var">n<sub>2</sub></span>, (<span class="id" title="var">n<sub>1</sub></span> =? <span class="id" title="var">n<sub>2</sub></span>) = <span class="id" title="var">true</span> ↔ <span class="id" title="var">n<sub>1</sub></span> = <span class="id" title="var">n<sub>2</sub></span>.<br/>
</div>

<div class="doc">
However, this can result in some tedium in proof scripts. Consider: 
</div>
<div class="code">

<span class="id" title="keyword">Theorem</span> <span class="id" title="var">filter_not_empty_In</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">l</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">filter</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="var">n</span> =? <span class="id" title="var">x</span>) <span class="id" title="var">l</span> ≠ [] → <span class="id" title="var">In</span> <span class="id" title="var">n</span> <span class="id" title="var">l</span>.<br/>
<div class="togglescript" id="proofcontrol16" onclick="toggleDisplay('proof16');toggleDisplay('proofcontrol16')"><span class="show"></span></div>
<div class="proofscript" id="proof16" onclick="toggleDisplay('proof16');toggleDisplay('proofcontrol16')">
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">l</span>. <span class="id" title="tactic">induction</span> <span class="id" title="var">l</span> <span class="id" title="keyword">as</span> [|<span class="id" title="var">m</span> <span class="id" title="var">l'</span> <span class="id" title="var">IHl'</span>].<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;l&nbsp;=&nbsp;nil&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;l&nbsp;=&nbsp;m&nbsp;::&nbsp;l'&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">destruct</span> (<span class="id" title="var">n</span> =? <span class="id" title="var">m</span>) <span class="id" title="var">eqn</span>:<span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="comment">(*&nbsp;n&nbsp;=?&nbsp;m&nbsp;=&nbsp;true&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">_</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">eqb_eq</span> <span class="id" title="keyword">in</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">left</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="comment">(*&nbsp;n&nbsp;=?&nbsp;m&nbsp;=&nbsp;false&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">H'</span>. <span class="id" title="tactic">right</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">IHl'</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">H'</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>
</div>

<div class="doc">
The first subcase (where <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=?</span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">true</span></span>) is awkward
    because we have to explicitly "switch worlds."

<div class="paragraph"> </div>

    It would be annoying to have to do this kind of thing all the
    time. 
<div class="paragraph"> </div>

<a id="lab270"></a><h3 class="section"> </h3>
 We can streamline this sort of reasoning by defining an inductive
    proposition that yields a better case-analysis principle for <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=?</span>
    <span class="inlinecode"><span class="id" title="var">m</span></span>.  Instead of generating the assumption <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">=?</span> <span class="inlinecode"><span class="id" title="var">m</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">true</span></span>, which
    usually requires some massaging before we can use it, this
    principle gives us right away the assumption we really need: <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span>
    <span class="inlinecode"><span class="id" title="var">m</span></span>.

<div class="paragraph"> </div>

    Following the terminology introduced in <a href="Logic.html"><span class="inlineref">Logic</span></a>, we call this
    the "reflection principle for equality on numbers," and we say
    that the boolean <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=?</span> <span class="inlinecode"><span class="id" title="var">m</span></span> is <i>reflected in</i> the proposition <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span>
    <span class="inlinecode"><span class="id" title="var">m</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Inductive</span> <span class="id" title="var">reflect</span> (<span class="id" title="var">P</span> : <span class="id" title="keyword">Prop</span>) : <span class="id" title="var">bool</span> → <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">ReflectT</span> (<span class="id" title="var">H</span> :   <span class="id" title="var">P</span>) : <span class="id" title="var">reflect</span> <span class="id" title="var">P</span> <span class="id" title="var">true</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">ReflectF</span> (<span class="id" title="var">H</span> : ¬<span class="id" title="var">P</span>) : <span class="id" title="var">reflect</span> <span class="id" title="var">P</span> <span class="id" title="var">false</span>.<br/>
</div>

<div class="doc">
Notice that the only way to produce evidence for <span class="inlinecode"><span class="id" title="var">reflect</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span>
    <span class="inlinecode"><span class="id" title="var">true</span></span> is by showing <span class="inlinecode"><span class="id" title="var">P</span></span> and then using the <span class="inlinecode"><span class="id" title="var">ReflectT</span></span> constructor.

<div class="paragraph"> </div>

    If we play this reasoning backwards, it says we can extract
    <i>evidence</i> for <span class="inlinecode"><span class="id" title="var">P</span></span> from evidence for <span class="inlinecode"><span class="id" title="var">reflect</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">true</span></span>. 
<div class="paragraph"> </div>

 To put this observation to work, we first prove that the
    statements <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">↔</span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">true</span></span> and <span class="inlinecode"><span class="id" title="var">reflect</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> are indeed
    equivalent.  First, the left-to-right implication: 
</div>
<div class="code">

<span class="id" title="keyword">Theorem</span> <span class="id" title="var">iff_reflect</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> <span class="id" title="var">b</span>, (<span class="id" title="var">P</span> ↔ <span class="id" title="var">b</span> = <span class="id" title="var">true</span>) → <span class="id" title="var">reflect</span> <span class="id" title="var">P</span> <span class="id" title="var">b</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;WORK&nbsp;IN&nbsp;CLASS&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
(The right-to-left implication is left as an exercise.) 
<div class="paragraph"> </div>

<a id="lab271"></a><h3 class="section"> </h3>
 We can think of <span class="inlinecode"><span class="id" title="var">reflect</span></span> as a variant of the usual "if and only
    if" connective; the advantage of <span class="inlinecode"><span class="id" title="var">reflect</span></span> is that, by destructing
    a hypothesis or lemma of the form <span class="inlinecode"><span class="id" title="var">reflect</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span>, we can perform
    case analysis on <span class="inlinecode"><span class="id" title="var">b</span></span> while <i>at the same time</i> generating
    appropriate hypothesis in the two branches (<span class="inlinecode"><span class="id" title="var">P</span></span> in the first
    subgoal and <span class="inlinecode">¬</span> <span class="inlinecode"><span class="id" title="var">P</span></span> in the second). 
<div class="paragraph"> </div>

<a id="lab272"></a><h3 class="section"> </h3>
 Let's use <span class="inlinecode"><span class="id" title="var">reflect</span></span> to produce a smoother proof of
    <span class="inlinecode"><span class="id" title="var">filter_not_empty_In</span></span>.

<div class="paragraph"> </div>

    We begin by recasting the <span class="inlinecode"><span class="id" title="var">eqb_eq</span></span> lemma in terms of <span class="inlinecode"><span class="id" title="var">reflect</span></span>: 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <span class="id" title="var">eqbP</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>, <span class="id" title="var">reflect</span> (<span class="id" title="var">n</span> = <span class="id" title="var">m</span>) (<span class="id" title="var">n</span> =? <span class="id" title="var">m</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">iff_reflect</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">eqb_eq</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab273"></a><h3 class="section"> </h3>
 The proof of <span class="inlinecode"><span class="id" title="var">filter_not_empty_In</span></span> now goes as follows.  Notice
    how the calls to <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> and <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> in the earlier proof of
    this theorem are combined here into a single call to
    <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Theorem</span> <span class="id" title="var">filter_not_empty_In'</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">l</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">filter</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="var">n</span> =? <span class="id" title="var">x</span>) <span class="id" title="var">l</span> ≠ [] →<br/>
&nbsp;&nbsp;<span class="id" title="var">In</span> <span class="id" title="var">n</span> <span class="id" title="var">l</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">l</span>. <span class="id" title="tactic">induction</span> <span class="id" title="var">l</span> <span class="id" title="keyword">as</span> [|<span class="id" title="var">m</span> <span class="id" title="var">l'</span> <span class="id" title="var">IHl'</span>].<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;l&nbsp;=&nbsp;<span class="inlinecode"></span>&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;l&nbsp;=&nbsp;m&nbsp;::&nbsp;l'&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">destruct</span> (<span class="id" title="var">eqbP</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">EQnm</span> | <span class="id" title="var">NEQnm</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="comment">(*&nbsp;n&nbsp;=&nbsp;m&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">_</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">EQnm</span>. <span class="id" title="tactic">left</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="comment">(*&nbsp;n&nbsp;&lt;&gt;&nbsp;m&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">H'</span>. <span class="id" title="tactic">right</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">IHl'</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">H'</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab274"></a><h3 class="section"> </h3>
 This small example shows reflection giving us a small gain in
    convenience; in larger developments, using <span class="inlinecode"><span class="id" title="var">reflect</span></span> consistently
    can often lead to noticeably shorter and clearer proof scripts.
    We'll see many more examples in later chapters.

<div class="paragraph"> </div>

    This way of using <span class="inlinecode"><span class="id" title="var">reflect</span></span> was popularized by <i>SSReflect</i>, a Coq
    library that has been used to formalize important results in
    mathematics, including the 4-color theorem and the Feit-Thompson
    theorem.  The name SSReflect stands for <i>small-scale reflection</i>,
    i.e., the pervasive use of reflection to streamline small proof
    steps by turning them into boolean computations. 
<div class="paragraph"> </div>

 When we write a proof using tactics, what we are doing is
    instructing Coq to build a proof object under the hood.  We can
    see this using <span class="inlinecode"><span class="id" title="keyword">Show</span></span> <span class="inlinecode"><span class="id" title="keyword">Proof</span></span>: 
</div>
<div class="code">

<span class="id" title="keyword">Theorem</span> <span class="id" title="var">ev_4''</span> : <span class="id" title="var">ev</span> 4.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Show</span> <span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">ev_SS</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Show</span> <span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">ev_SS</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Show</span> <span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">ev_0</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Show</span> <span class="id" title="keyword">Proof</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab275"></a><h3 class="section"> </h3>
 Tactic proofs are convenient, but they are not essential in Coq:
    in principle, we can always just construct the required evidence
    by hand. Then we can use <span class="inlinecode"><span class="id" title="keyword">Definition</span></span> (rather than <span class="inlinecode"><span class="id" title="keyword">Theorem</span></span>) to
    introduce a global name for this evidence. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <span class="id" title="var">ev_4'''</span> : <span class="id" title="var">ev</span> 4 :=<br/>
&nbsp;&nbsp;<span class="id" title="var">ev_SS</span> 2 (<span class="id" title="var">ev_SS</span> 0 <span class="id" title="var">ev_0</span>).<br/>
</div>

<div class="doc">
<a id="lab276"></a><h1 class="section">Quantifiers, Implications, Functions</h1>

<div class="paragraph"> </div>

 In Coq's computational universe (where data structures and
    programs live), there are two sorts of values that have arrows in
    their types: <i>constructors</i> introduced by <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span>ly defined
    data types, and <i>functions</i>.

<div class="paragraph"> </div>

    Similarly, in Coq's logical universe (where we carry out proofs),
    there are two ways of giving evidence for an implication:
    constructors introduced by <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span>ly defined propositions,
    and... functions! 
<div class="paragraph"> </div>

<a id="lab277"></a><h3 class="section"> </h3>
 For example, consider this statement:
<br/>
<span class="inlinecode"><span class="id" title="keyword">Theorem</span> <span class="id" title="var">ev_plus4</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>, <span class="id" title="var">ev</span> <span class="id" title="var">n</span> → <span class="id" title="var">ev</span> (4 + <span class="id" title="var">n</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">ev_SS</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">ev_SS</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>.<br/>
<span class="id" title="keyword">Qed</span>.
</span>
<div class="paragraph"> </div>

 What is the proof object corresponding to <span class="inlinecode"><span class="id" title="var">ev_plus4</span></span>? 
<div class="paragraph"> </div>

<a id="lab278"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 We're looking for an expression whose <i>type</i> is <span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode"><span class="id" title="var">n</span>,</span> <span class="inlinecode"><span class="id" title="var">ev</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">→</span>
    <span class="inlinecode"><span class="id" title="var">ev</span></span> <span class="inlinecode">(4</span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">n</span>)</span> -- that is, a <i>function</i> that takes two arguments (one
    number and a piece of evidence) and returns a piece of evidence!

<div class="paragraph"> </div>

    Here it is: 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <span class="id" title="var">ev_plus4'</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>, <span class="id" title="var">ev</span> <span class="id" title="var">n</span> → <span class="id" title="var">ev</span> (4 + <span class="id" title="var">n</span>) :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">fun</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) ⇒ <span class="id" title="keyword">fun</span> (<span class="id" title="var">H</span> : <span class="id" title="var">ev</span> <span class="id" title="var">n</span>) ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">ev_SS</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>)) (<span class="id" title="var">ev_SS</span> <span class="id" title="var">n</span> <span class="id" title="var">H</span>).<br/>
</div>

<div class="doc">
Or equivalently: 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <span class="id" title="var">ev_plus4''</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">H</span> : <span class="id" title="var">ev</span> <span class="id" title="var">n</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="var">ev</span> (4 + <span class="id" title="var">n</span>) :=<br/>
&nbsp;&nbsp;<span class="id" title="var">ev_SS</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>)) (<span class="id" title="var">ev_SS</span> <span class="id" title="var">n</span> <span class="id" title="var">H</span>).<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">ev_plus4''</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">ev</span> <span class="id" title="var">n</span> → <span class="id" title="var">ev</span> (4 + <span class="id" title="var">n</span>).<br/>
</div>

<div class="doc">
<a id="lab279"></a><h3 class="section"> </h3>
 When we view the proposition being proved by <span class="inlinecode"><span class="id" title="var">ev_plus4</span></span> as a
    function type, one interesting point becomes apparent: The second
    argument's type, <span class="inlinecode"><span class="id" title="var">ev</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>, mentions the <i>value</i> of the first
    argument, <span class="inlinecode"><span class="id" title="var">n</span></span>.

<div class="paragraph"> </div>

    While such <i>dependent types</i> are not found in most mainstream
    programming languages, they can be quite useful in programming
    too, as the flurry of activity in the functional programming
    community over the past couple of decades demonstrates. 
<div class="paragraph"> </div>

<a id="lab280"></a><h3 class="section"> </h3>
 Notice that both implication (<span class="inlinecode">→</span>) and quantification (<span class="inlinecode"><span class="id" title="keyword">∀</span></span>)
    correspond to functions on evidence.  In fact, they are really the
    same thing: <span class="inlinecode">→</span> is just a shorthand for a degenerate use of
    <span class="inlinecode"><span class="id" title="keyword">∀</span></span> where there is no dependency, i.e., no need to give a
    name to the type on the left-hand side of the arrow:
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> (<span class="id" title="var">x</span>:<span class="id" title="var">nat</span>), <span class="id" title="var">nat</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=  <span class="id" title="keyword">∀</span> (<span class="id" title="var">_</span>:<span class="id" title="var">nat</span>), <span class="id" title="var">nat</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=  <span class="id" title="var">nat</span>          → <span class="id" title="var">nat</span>
</span>
</div>
<div class="quiz">


<div class="doc">
Recall the definition of <span class="inlinecode"><span class="id" title="var">ev</span></span>:
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Inductive</span> <span class="id" title="var">ev</span> : <span class="id" title="var">nat</span> → <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">ev_0</span> : <span class="id" title="var">ev</span> 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">ev_SS</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>, <span class="id" title="var">ev</span> <span class="id" title="var">n</span> → <span class="id" title="var">ev</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>)).
</span>    What is the type of this expression?
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> (<span class="id" title="var">H</span> : <span class="id" title="var">ev</span> <span class="id" title="var">n</span>) ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">ev_SS</span> (2 + <span class="id" title="var">n</span>) (<span class="id" title="var">ev_SS</span> <span class="id" title="var">n</span> <span class="id" title="var">H</span>)
</span>
<div class="paragraph"> </div>

  (1) <span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode"><span class="id" title="var">n</span>,</span> <span class="inlinecode"><span class="id" title="var">ev</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>

<div class="paragraph"> </div>

  (2) <span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode"><span class="id" title="var">n</span>,</span> <span class="inlinecode"><span class="id" title="var">ev</span></span> <span class="inlinecode">(2</span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">n</span>)</span>

<div class="paragraph"> </div>

  (3) <span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode"><span class="id" title="var">n</span>,</span> <span class="inlinecode"><span class="id" title="var">ev</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">ev</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>

<div class="paragraph"> </div>

  (4) <span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode"><span class="id" title="var">n</span>,</span> <span class="inlinecode"><span class="id" title="var">ev</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">ev</span></span> <span class="inlinecode">(2</span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">n</span>)</span>

<div class="paragraph"> </div>

  (5) <span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode"><span class="id" title="var">n</span>,</span> <span class="inlinecode"><span class="id" title="var">ev</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">ev</span></span> <span class="inlinecode">(4</span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">n</span>)</span>

<div class="paragraph"> </div>

  (6) Not typeable

</div>
<div class="code">
<div class="togglescript" id="proofcontrol17" onclick="toggleDisplay('proof17');toggleDisplay('proofcontrol17')"><span class="show"></span></div>
<div class="proofscript" id="proof17" onclick="toggleDisplay('proof17');toggleDisplay('proofcontrol17')">
<span class="id" title="keyword">Check</span> (<span class="id" title="keyword">fun</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> (<span class="id" title="var">H</span> : <span class="id" title="var">ev</span> <span class="id" title="var">n</span>) ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">ev_SS</span> (2 + <span class="id" title="var">n</span>) (<span class="id" title="var">ev_SS</span> <span class="id" title="var">n</span> <span class="id" title="var">H</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">ev</span> <span class="id" title="var">n</span> → <span class="id" title="var">ev</span> (4 + <span class="id" title="var">n</span>).<br/>
</div>
</div></div> <!-- /quiz -->

<div class="doc">
<a id="lab281"></a><h1 class="section">Programming with Tactics</h1>

<div class="paragraph"> </div>

 If we can build proofs by giving explicit terms rather than
    executing tactic scripts, you may be wondering whether we can
    build <i>programs</i> using tactics rather than by writing down
    explicit terms.

<div class="paragraph"> </div>

    Naturally, the answer is yes! 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <span class="id" title="var">add1</span> : <span class="id" title="var">nat</span> → <span class="id" title="var">nat</span>.<br/>
<span class="id" title="tactic">intro</span> <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Show</span> <span class="id" title="keyword">Proof</span>.<br/>
<span class="id" title="tactic">apply</span> <span class="id" title="var">S</span>.<br/>
<span class="id" title="keyword">Show</span> <span class="id" title="keyword">Proof</span>.<br/>
<span class="id" title="tactic">apply</span> <span class="id" title="var">n</span>. <span class="id" title="keyword">Defined</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">add1</span>.<br/>
<span class="comment">(*&nbsp;==&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;add1&nbsp;=&nbsp;fun&nbsp;n&nbsp;:&nbsp;nat&nbsp;=&gt;&nbsp;S&nbsp;n<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;nat&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span>&nbsp;nat<br/>
*)</span><br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Compute</span> <span class="id" title="var">add1</span> 2.<br/>
<span class="comment">(*&nbsp;==&gt;&nbsp;3&nbsp;:&nbsp;nat&nbsp;*)</span><br/>
</div>

<div class="doc">
<a id="lab282"></a><h1 class="section">Logical Connectives as Inductive Types</h1>

<div class="paragraph"> </div>

 Inductive definitions are powerful enough to express most of the
    logical connectives we have seen so far.  Indeed, only universal
    quantification (with implication as a special case) is built into
    Coq; all the others are defined inductively.

<div class="paragraph"> </div>

    Let's see how. 
</div>

<div class="doc">
<a id="lab283"></a><h2 class="section">Conjunction</h2>

<div class="paragraph"> </div>

 To prove that <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">∧</span> <span class="inlinecode"><span class="id" title="var">Q</span></span> holds, we must present evidence for both
    <span class="inlinecode"><span class="id" title="var">P</span></span> and <span class="inlinecode"><span class="id" title="var">Q</span></span>.  Thus, it makes sense to define a proof object for
    <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">∧</span> <span class="inlinecode"><span class="id" title="var">Q</span></span> to consist of a pair of two proofs: one for <span class="inlinecode"><span class="id" title="var">P</span></span> and
    another one for <span class="inlinecode"><span class="id" title="var">Q</span></span>. This leads to the following definition. 
</div>
<div class="code">

<span class="id" title="keyword">Inductive</span> <span class="id" title="var">and</span> (<span class="id" title="var">P</span> <span class="id" title="var">Q</span> : <span class="id" title="keyword">Prop</span>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">conj</span> : <span class="id" title="var">P</span> → <span class="id" title="var">Q</span> → <span class="id" title="var">and</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">conj</span> [<span class="id" title="var">P</span>] [<span class="id" title="var">Q</span>].<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Notation</span> &quot;P /\ Q" := (<span class="id" title="var">and</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span>) : <span class="id" title="var">type_scope</span>.<br/>
</div>

<div class="doc">
Notice the similarity with the definition of the <span class="inlinecode"><span class="id" title="var">prod</span></span> type,
    given in chapter <a href="Poly.html"><span class="inlineref">Poly</span></a>; the only difference is that <span class="inlinecode"><span class="id" title="var">prod</span></span> takes
    <span class="inlinecode"><span class="id" title="keyword">Type</span></span> arguments, whereas <span class="inlinecode"><span class="id" title="var">and</span></span> takes <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> arguments. 
</div>
<div class="code">

<span class="id" title="keyword">Print</span> <span class="id" title="var">prod</span>.<br/>
<span class="comment">(*&nbsp;===&gt;<br/>
&nbsp;&nbsp;&nbsp;Inductive&nbsp;prod&nbsp;(X&nbsp;Y&nbsp;:&nbsp;Type)&nbsp;:&nbsp;Type&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;|&nbsp;pair&nbsp;:&nbsp;X&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span>&nbsp;Y&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span>&nbsp;X&nbsp;*&nbsp;Y.&nbsp;*)</span><br/>
</div>

<div class="doc">
<a id="lab284"></a><h3 class="section"> </h3>
 This similarity should clarify why <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> and <span class="inlinecode"><span class="id" title="tactic">intros</span></span>
    patterns can be used on a conjunctive hypothesis.  Case analysis
    allows us to consider all possible ways in which <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">∧</span> <span class="inlinecode"><span class="id" title="var">Q</span></span> was
    proved -- here just one (the <span class="inlinecode"><span class="id" title="var">conj</span></span> constructor). 
</div>
<div class="code">

<span class="id" title="keyword">Theorem</span> <span class="id" title="var">proj1'</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">P</span> ∧ <span class="id" title="var">Q</span> → <span class="id" title="var">P</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">HPQ</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">HPQ</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">HP</span> <span class="id" title="var">HQ</span>]. <span class="id" title="tactic">apply</span> <span class="id" title="var">HP</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Show</span> <span class="id" title="keyword">Proof</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
Similarly, the <span class="inlinecode"><span class="id" title="tactic">split</span></span> tactic actually works for any inductively
    defined proposition with exactly one constructor.  In particular,
    it works for <span class="inlinecode"><span class="id" title="var">and</span></span>: 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <span class="id" title="var">and_comm</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> : <span class="id" title="keyword">Prop</span>, <span class="id" title="var">P</span> ∧ <span class="id" title="var">Q</span> ↔ <span class="id" title="var">Q</span> ∧ <span class="id" title="var">P</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span>. <span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> [<span class="id" title="var">HP</span> <span class="id" title="var">HQ</span>]. <span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">apply</span> <span class="id" title="var">HQ</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">apply</span> <span class="id" title="var">HP</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> [<span class="id" title="var">HQ</span> <span class="id" title="var">HP</span>]. <span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">apply</span> <span class="id" title="var">HP</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">apply</span> <span class="id" title="var">HQ</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
</div>

<div class="doc">
<a id="lab285"></a><h3 class="section"> </h3>
 This shows why the inductive definition of <span class="inlinecode"><span class="id" title="var">and</span></span> can be
    manipulated by tactics as we've been doing.  We can also use it to
    build proofs directly, using pattern-matching.  For instance: 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <span class="id" title="var">proj1''</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> (<span class="id" title="var">HPQ</span> : <span class="id" title="var">P</span> ∧ <span class="id" title="var">Q</span>) : <span class="id" title="var">P</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">HPQ</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">conj</span> <span class="id" title="var">HP</span> <span class="id" title="var">HQ</span> ⇒ <span class="id" title="var">HP</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">and_comm'_aux</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> (<span class="id" title="var">H</span> : <span class="id" title="var">P</span> ∧ <span class="id" title="var">Q</span>) : <span class="id" title="var">Q</span> ∧ <span class="id" title="var">P</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">H</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">conj</span> <span class="id" title="var">HP</span> <span class="id" title="var">HQ</span> ⇒ <span class="id" title="var">conj</span> <span class="id" title="var">HQ</span> <span class="id" title="var">HP</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">and_comm'</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> : <span class="id" title="var">P</span> ∧ <span class="id" title="var">Q</span> ↔ <span class="id" title="var">Q</span> ∧ <span class="id" title="var">P</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">conj</span> (<span class="id" title="var">and_comm'_aux</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span>) (<span class="id" title="var">and_comm'_aux</span> <span class="id" title="var">Q</span> <span class="id" title="var">P</span>).<br/><hr class='doublespaceincode'/>
 <!-- /quiz -->
</div><div class="quiz">


<div class="doc">
What is the type of this expression?
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">R</span> (<span class="id" title="var">H<sub>1</sub></span>: <span class="id" title="var">and</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span>) (<span class="id" title="var">H<sub>2</sub></span>: <span class="id" title="var">and</span> <span class="id" title="var">Q</span> <span class="id" title="var">R</span>) ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> (<span class="id" title="var">H<sub>1</sub></span>,<span class="id" title="var">H<sub>2</sub></span>) <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (<span class="id" title="var">conj</span> <span class="id" title="var">HP</span> <span class="id" title="var">_</span>, <span class="id" title="var">conj</span>  <span class="id" title="var">_</span> <span class="id" title="var">HR</span>) ⇒ <span class="id" title="var">conj</span> <span class="id" title="var">HP</span> <span class="id" title="var">HR</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.
</span>
<div class="paragraph"> </div>

  (1) <span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">Q</span></span> <span class="inlinecode"><span class="id" title="var">R</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">∧</span> <span class="inlinecode"><span class="id" title="var">Q</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">Q</span></span> <span class="inlinecode">∧</span> <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">∧</span> <span class="inlinecode"><span class="id" title="var">R</span></span>

<div class="paragraph"> </div>

  (2) <span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">Q</span></span> <span class="inlinecode"><span class="id" title="var">R</span>,</span> <span class="inlinecode"><span class="id" title="var">Q</span></span> <span class="inlinecode">∧</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode">∧</span> <span class="inlinecode"><span class="id" title="var">Q</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">∧</span> <span class="inlinecode"><span class="id" title="var">R</span></span>

<div class="paragraph"> </div>

  (3) <span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">Q</span></span> <span class="inlinecode"><span class="id" title="var">R</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">∧</span> <span class="inlinecode"><span class="id" title="var">R</span></span>

<div class="paragraph"> </div>

  (4) <span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">Q</span></span> <span class="inlinecode"><span class="id" title="var">R</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">∨</span> <span class="inlinecode"><span class="id" title="var">Q</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">Q</span></span> <span class="inlinecode">∨</span> <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">∨</span> <span class="inlinecode"><span class="id" title="var">R</span></span>

<div class="paragraph"> </div>

  (5) Not typeable

<div class="paragraph"> </div>


</div>
<div class="code">
<div class="togglescript" id="proofcontrol18" onclick="toggleDisplay('proof18');toggleDisplay('proofcontrol18')"><span class="show"></span></div>
<div class="proofscript" id="proof18" onclick="toggleDisplay('proof18');toggleDisplay('proofcontrol18')">
<span class="id" title="keyword">Check</span><br/>
&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">R</span> (<span class="id" title="var">H<sub>1</sub></span>: <span class="id" title="var">and</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span>) (<span class="id" title="var">H<sub>2</sub></span>: <span class="id" title="var">and</span> <span class="id" title="var">Q</span> <span class="id" title="var">R</span>) ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> (<span class="id" title="var">H<sub>1</sub></span>,<span class="id" title="var">H<sub>2</sub></span>) <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| (<span class="id" title="var">conj</span> <span class="id" title="var">HP</span> <span class="id" title="var">_</span>, <span class="id" title="var">conj</span> <span class="id" title="var">_</span> <span class="id" title="var">HR</span>) ⇒ <span class="id" title="var">conj</span> <span class="id" title="var">HP</span> <span class="id" title="var">HR</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>) : <span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">R</span>, <span class="id" title="var">P</span> ∧ <span class="id" title="var">Q</span> → <span class="id" title="var">Q</span> ∧ <span class="id" title="var">R</span> → <span class="id" title="var">P</span> ∧ <span class="id" title="var">R</span>.<br/>
</div>
</div></div> <!-- /quiz -->

<div class="doc">
<a id="lab286"></a><h2 class="section">Disjunction</h2>

<div class="paragraph"> </div>

 The inductive definition of disjunction uses two constructors, one
    for each side of the disjunct: 
</div>
<div class="code">

<span class="id" title="keyword">Inductive</span> <span class="id" title="var">or</span> (<span class="id" title="var">P</span> <span class="id" title="var">Q</span> : <span class="id" title="keyword">Prop</span>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">or_introl</span> : <span class="id" title="var">P</span> → <span class="id" title="var">or</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">or_intror</span> : <span class="id" title="var">Q</span> → <span class="id" title="var">or</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">or_introl</span> [<span class="id" title="var">P</span>] [<span class="id" title="var">Q</span>].<br/>
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">or_intror</span> [<span class="id" title="var">P</span>] [<span class="id" title="var">Q</span>].<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Notation</span> &quot;P \/ Q" := (<span class="id" title="var">or</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span>) : <span class="id" title="var">type_scope</span>.<br/>
</div>

<div class="doc">
This declaration explains the behavior of the <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> tactic on
    a disjunctive hypothesis, since the generated subgoals match the
    shape of the <span class="inlinecode"><span class="id" title="var">or_introl</span></span> and <span class="inlinecode"><span class="id" title="var">or_intror</span></span> constructors. 
<div class="paragraph"> </div>

<a id="lab287"></a><h3 class="section"> </h3>
 Once again, we can also directly write proof objects for theorems
    involving <span class="inlinecode"><span class="id" title="var">or</span></span>, without resorting to tactics. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <span class="id" title="var">inj_l</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">P</span> <span class="id" title="var">Q</span> : <span class="id" title="keyword">Prop</span>), <span class="id" title="var">P</span> → <span class="id" title="var">P</span> ∨ <span class="id" title="var">Q</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">HP</span> ⇒ <span class="id" title="var">or_introl</span> <span class="id" title="var">HP</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">inj_l'</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">P</span> <span class="id" title="var">Q</span> : <span class="id" title="keyword">Prop</span>), <span class="id" title="var">P</span> → <span class="id" title="var">P</span> ∨ <span class="id" title="var">Q</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">HP</span>. <span class="id" title="tactic">left</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">HP</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Show</span> <span class="id" title="keyword">Proof</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab288"></a><h3 class="section"> </h3>

</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">or_elim</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">R</span> : <span class="id" title="keyword">Prop</span>), (<span class="id" title="var">P</span> ∨ <span class="id" title="var">Q</span>) → (<span class="id" title="var">P</span> → <span class="id" title="var">R</span>) → (<span class="id" title="var">Q</span> → <span class="id" title="var">R</span>) → <span class="id" title="var">R</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">R</span> <span class="id" title="var">HPQ</span> <span class="id" title="var">HPR</span> <span class="id" title="var">HQR</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">HPQ</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">or_introl</span> <span class="id" title="var">HP</span> ⇒ <span class="id" title="var">HPR</span> <span class="id" title="var">HP</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">or_intror</span> <span class="id" title="var">HQ</span> ⇒ <span class="id" title="var">HQR</span> <span class="id" title="var">HQ</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">or_elim'</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">R</span> : <span class="id" title="keyword">Prop</span>), (<span class="id" title="var">P</span> ∨ <span class="id" title="var">Q</span>) → (<span class="id" title="var">P</span> → <span class="id" title="var">R</span>) → (<span class="id" title="var">Q</span> → <span class="id" title="var">R</span>) → <span class="id" title="var">R</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">R</span> <span class="id" title="var">HPQ</span> <span class="id" title="var">HPR</span> <span class="id" title="var">HQR</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">HPQ</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">HP</span> | <span class="id" title="var">HQ</span>].<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">apply</span> <span class="id" title="var">HPR</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">HP</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">apply</span> <span class="id" title="var">HQR</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">HQ</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>

<br/>
 <!-- /quiz -->
</div><div class="quiz">


<div class="doc">
What is the type of this expression?
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">H</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">H</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">or_introl</span> <span class="id" title="var">HP</span> ⇒ @<span class="id" title="var">or_intror</span> <span class="id" title="var">Q</span> <span class="id" title="var">P</span> <span class="id" title="var">HP</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">or_intror</span> <span class="id" title="var">HQ</span> ⇒ @<span class="id" title="var">or_introl</span> <span class="id" title="var">Q</span> <span class="id" title="var">P</span> <span class="id" title="var">HQ</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.
</span>
<div class="paragraph"> </div>

  (1) <span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">Q</span></span> <span class="inlinecode"><span class="id" title="var">H</span>,</span> <span class="inlinecode"><span class="id" title="var">Q</span></span> <span class="inlinecode">∨</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">∨</span> <span class="inlinecode"><span class="id" title="var">H</span></span>

<div class="paragraph"> </div>

  (2) <span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">Q</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">∨</span> <span class="inlinecode"><span class="id" title="var">Q</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">∨</span> <span class="inlinecode"><span class="id" title="var">Q</span></span>

<div class="paragraph"> </div>

  (3) <span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">Q</span></span> <span class="inlinecode"><span class="id" title="var">H</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">∨</span> <span class="inlinecode"><span class="id" title="var">Q</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">Q</span></span> <span class="inlinecode">∨</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">H</span></span>

<div class="paragraph"> </div>

  (4) <span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">Q</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">∨</span> <span class="inlinecode"><span class="id" title="var">Q</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">Q</span></span> <span class="inlinecode">∨</span> <span class="inlinecode"><span class="id" title="var">P</span></span>

<div class="paragraph"> </div>

  (5) Not typeable

<div class="paragraph"> </div>


</div>
<div class="code">
<div class="togglescript" id="proofcontrol19" onclick="toggleDisplay('proof19');toggleDisplay('proofcontrol19')"><span class="show"></span></div>
<div class="proofscript" id="proof19" onclick="toggleDisplay('proof19');toggleDisplay('proofcontrol19')">
<span class="id" title="keyword">Check</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">H</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">H</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">or_introl</span> <span class="id" title="var">HP</span> ⇒ @<span class="id" title="var">or_intror</span> <span class="id" title="var">Q</span> <span class="id" title="var">P</span> <span class="id" title="var">HP</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">or_intror</span> <span class="id" title="var">HQ</span> ⇒ @<span class="id" title="var">or_introl</span> <span class="id" title="var">Q</span> <span class="id" title="var">P</span> <span class="id" title="var">HQ</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>) : <span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span>, <span class="id" title="var">P</span> ∨ <span class="id" title="var">Q</span> → <span class="id" title="var">Q</span> ∨ <span class="id" title="var">P</span>.<br/>
</div>
</div></div> <!-- /quiz -->

<div class="doc">
<a id="lab289"></a><h2 class="section">Existential Quantification</h2>

<div class="paragraph"> </div>

 To give evidence for an existential quantifier, we package a
    witness <span class="inlinecode"><span class="id" title="var">x</span></span> together with a proof that <span class="inlinecode"><span class="id" title="var">x</span></span> satisfies the property
    <span class="inlinecode"><span class="id" title="var">P</span></span>: 
</div>
<div class="code">
<hr class='doublespaceincode'/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">ex</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">P</span> : <span class="id" title="var">A</span> → <span class="id" title="keyword">Prop</span>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">ex_intro</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span>, <span class="id" title="var">P</span> <span class="id" title="var">x</span> → <span class="id" title="var">ex</span> <span class="id" title="var">P</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Notation</span> &quot;'exists' x , p" :=<br/>
&nbsp;&nbsp;(<span class="id" title="var">ex</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="var">p</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 200, <span class="id" title="tactic">right</span> <span class="id" title="keyword">associativity</span>) : <span class="id" title="var">type_scope</span>.<br/>
</div>

<div class="doc">
<a id="lab290"></a><h3 class="section"> </h3>
 The more familiar form <span class="inlinecode"><span class="id" title="tactic">∃</span></span> <span class="inlinecode"><span class="id" title="var">x</span>,</span> <span class="inlinecode"><span class="id" title="var">ev</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> desugars to an expression
    involving <span class="inlinecode"><span class="id" title="var">ex</span></span>: 
</div>
<div class="code">

<span class="id" title="keyword">Check</span> <span class="id" title="var">ex</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">n</span> ⇒ <span class="id" title="var">ev</span> <span class="id" title="var">n</span>) : <span class="id" title="keyword">Prop</span>.<br/>
</div>

<div class="doc">
Here's how to define an explicit proof object involving <span class="inlinecode"><span class="id" title="var">ex</span></span>: 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <span class="id" title="var">some_nat_is_even</span> : <span class="id" title="tactic">∃</span> <span class="id" title="var">n</span>, <span class="id" title="var">ev</span> <span class="id" title="var">n</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">ex_intro</span> <span class="id" title="var">ev</span> 4 (<span class="id" title="var">ev_SS</span> 2 (<span class="id" title="var">ev_SS</span> 0 <span class="id" title="var">ev_0</span>)).<br/><hr class='doublespaceincode'/>
 <!-- /quiz -->
</div><div class="quiz">


<div class="doc">
Which of the following propositions is proved by
    providing an explicit witness <span class="inlinecode"><span class="id" title="var">w</span></span> using <span class="inlinecode"><span class="id" title="var">exist</span></span> <span class="inlinecode"><span class="id" title="var">w</span></span>?

<div class="paragraph"> </div>

    (1) <span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode"><span class="id" title="var">x</span>:</span> <span class="inlinecode"><span class="id" title="var">nat</span>,</span> <span class="inlinecode">(<span class="id" title="tactic">∃</span></span> <span class="inlinecode"><span class="id" title="var">n</span>,</span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span>)</span> <span class="inlinecode">→</span> <span class="inlinecode">(<span class="id" title="var">x</span>&lt;&gt;0)</span>

<div class="paragraph"> </div>

    (2) <span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode"><span class="id" title="var">x</span>:</span> <span class="inlinecode"><span class="id" title="var">nat</span>,</span> <span class="inlinecode">(<span class="id" title="var">x</span>&lt;&gt;0)</span> <span class="inlinecode">→</span> <span class="inlinecode">(<span class="id" title="tactic">∃</span></span> <span class="inlinecode"><span class="id" title="var">n</span>,</span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span>)</span>

<div class="paragraph"> </div>

    (3) <span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode"><span class="id" title="var">x</span>:</span> <span class="inlinecode"><span class="id" title="var">nat</span>,</span> <span class="inlinecode">(<span class="id" title="var">x</span>=0)</span> <span class="inlinecode">→</span>  <span class="inlinecode">~(<span class="id" title="tactic">∃</span></span> <span class="inlinecode"><span class="id" title="var">n</span>,</span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span>)</span>

<div class="paragraph"> </div>

    (4) <span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode"><span class="id" title="var">x</span>:</span> <span class="inlinecode"><span class="id" title="var">nat</span>,</span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode">4</span> <span class="inlinecode">→</span> <span class="inlinecode">(<span class="id" title="var">x</span>&lt;&gt;0)</span>

<div class="paragraph"> </div>

    (5) none of the above

<div class="paragraph"> </div>


</div>
<div class="code">
<div class="togglescript" id="proofcontrol20" onclick="toggleDisplay('proof20');toggleDisplay('proofcontrol20')"><span class="show"></span></div>
<div class="proofscript" id="proof20" onclick="toggleDisplay('proof20');toggleDisplay('proofcontrol20')">
<span class="id" title="keyword">Goal</span> <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>: <span class="id" title="var">nat</span>, (<span class="id" title="var">x</span>&lt;&gt;0) → (<span class="id" title="tactic">∃</span> <span class="id" title="var">n</span>, <span class="id" title="var">x</span> = <span class="id" title="var">S</span> <span class="id" title="var">n</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">x</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">x'</span>].<br/>
- <span class="id" title="var">exfalso</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
- <span class="id" title="tactic">∃</span> <span class="id" title="var">x'</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>
</div></div> <!-- /quiz -->

<div class="doc">
<a id="lab291"></a><h3 class="section"> </h3>
 To destruct existentials in a proof term we simply use match: 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">dist_exists_or_term</span> (<span class="id" title="var">X</span>:<span class="id" title="keyword">Type</span>) (<span class="id" title="var">P</span> <span class="id" title="var">Q</span> : <span class="id" title="var">X</span> → <span class="id" title="keyword">Prop</span>) :<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">∃</span> <span class="id" title="var">x</span>, <span class="id" title="var">P</span> <span class="id" title="var">x</span> ∨ <span class="id" title="var">Q</span> <span class="id" title="var">x</span>) → (<span class="id" title="tactic">∃</span> <span class="id" title="var">x</span>, <span class="id" title="var">P</span> <span class="id" title="var">x</span>) ∨ (<span class="id" title="tactic">∃</span> <span class="id" title="var">x</span>, <span class="id" title="var">Q</span> <span class="id" title="var">x</span>) :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">H</span> ⇒ <span class="id" title="keyword">match</span> <span class="id" title="var">H</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">ex_intro</span> <span class="id" title="var">_</span> <span class="id" title="var">x</span> <span class="id" title="var">Hx</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">Hx</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">or_introl</span> <span class="id" title="var">HPx</span> ⇒ <span class="id" title="var">or_introl</span> (<span class="id" title="var">ex_intro</span> <span class="id" title="var">_</span> <span class="id" title="var">x</span> <span class="id" title="var">HPx</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">or_intror</span> <span class="id" title="var">HQx</span> ⇒ <span class="id" title="var">or_intror</span> (<span class="id" title="var">ex_intro</span> <span class="id" title="var">_</span> <span class="id" title="var">x</span> <span class="id" title="var">HQx</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
</div>

<div class="doc">
<a id="lab292"></a><h2 class="section"><span class="inlinecode"><span class="id" title="var">True</span></span> and <span class="inlinecode"><span class="id" title="var">False</span></span></h2>

<div class="paragraph"> </div>

 The inductive definition of the <span class="inlinecode"><span class="id" title="var">True</span></span> proposition is simple: 
</div>
<div class="code">

<span class="id" title="keyword">Inductive</span> <span class="id" title="var">True</span> : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">I</span> : <span class="id" title="var">True</span>.<br/>
</div>

<div class="doc">
It has one constructor (so every proof of <span class="inlinecode"><span class="id" title="var">True</span></span> is the same, so
    being given a proof of <span class="inlinecode"><span class="id" title="var">True</span></span> is not informative.) 
<div class="paragraph"> </div>

<a id="lab293"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" title="var">False</span></span> is equally simple -- indeed, so simple it may look
    syntactically wrong at first glance! 
</div>
<div class="code">

<span class="id" title="keyword">Inductive</span> <span class="id" title="var">False</span> : <span class="id" title="keyword">Prop</span> := .<br/>
</div>

<div class="doc">
That is, <span class="inlinecode"><span class="id" title="var">False</span></span> is an inductive type with <i>no</i> constructors --
    i.e., no way to build evidence for it. For example, there is
    no way to complete the following definition such that it
    succeeds. 
</div>
<div class="code">

<span class="id" title="var">Fail</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <span class="id" title="var">contra</span> : <span class="id" title="var">False</span> :=<br/>
&nbsp;&nbsp;42.<br/>
</div>

<div class="doc">
<a id="lab294"></a><h3 class="section"> </h3>
 But it is possible to destruct <span class="inlinecode"><span class="id" title="var">False</span></span> by pattern matching. There can
    be no patterns that match it, since it has no constructors.  So
    the pattern match also is so simple it may look syntactically
    wrong at first glance. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <span class="id" title="var">false_implies_zero_eq_one</span> : <span class="id" title="var">False</span> → 0 = 1 :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">contra</span> ⇒ <span class="id" title="keyword">match</span> <span class="id" title="var">contra</span> <span class="id" title="keyword">with</span> <span class="id" title="keyword">end</span>.<br/>
</div>

<div class="doc">
Since there are no branches to evaluate, the <span class="inlinecode"><span class="id" title="keyword">match</span></span> expression
    can be considered to have any type we want, including <span class="inlinecode">0</span> <span class="inlinecode">=</span> <span class="inlinecode">1</span>.
    Fortunately, it's impossible to ever cause the <span class="inlinecode"><span class="id" title="keyword">match</span></span> to be
    evaluated, because we can never construct a value of type <span class="inlinecode"><span class="id" title="var">False</span></span>
    to pass to the function. 
</div>

<div class="doc">
<a id="lab295"></a><h1 class="section">Equality</h1>

<div class="paragraph"> </div>

 Even Coq's equality relation is not built in.  We can define
    it ourselves: 
</div>
<div class="code">

<span class="id" title="keyword">Inductive</span> <span class="id" title="var">eq</span> {<span class="id" title="var">X</span>:<span class="id" title="keyword">Type</span>} : <span class="id" title="var">X</span> → <span class="id" title="var">X</span> → <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">eq_refl</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <span class="id" title="var">eq</span> <span class="id" title="var">x</span> <span class="id" title="var">x</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Notation</span> &quot;x == y" := (<span class="id" title="var">eq</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 70, <span class="id" title="keyword">no</span> <span class="id" title="keyword">associativity</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="var">type_scope</span>.<br/>
</div>

<div class="doc">
<a id="lab296"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 Coq terms are "the same" if they are <i>convertible</i>
    according to a simple set of computation rules: evaluation of
    function applications, inlining of definitions, and simplification
    of <span class="inlinecode"><span class="id" title="keyword">match</span></span>es. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <span class="id" title="var">four</span>: 2 + 2 == 1 + 3.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">eq_refl</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab297"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> is essentially just <span class="inlinecode"><span class="id" title="tactic">apply</span></span> <span class="inlinecode"><span class="id" title="var">eq_refl</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <span class="id" title="var">four'</span> : 2 + 2 == 1 + 3 :=<br/>
&nbsp;&nbsp;<span class="id" title="var">eq_refl</span> 4.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">singleton</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">X</span>:<span class="id" title="keyword">Type</span>) (<span class="id" title="var">x</span>:<span class="id" title="var">X</span>), []++[<span class="id" title="var">x</span>] == <span class="id" title="var">x</span>::[]  :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">fun</span> (<span class="id" title="var">X</span>:<span class="id" title="keyword">Type</span>) (<span class="id" title="var">x</span>:<span class="id" title="var">X</span>) ⇒ <span class="id" title="var">eq_refl</span> [<span class="id" title="var">x</span>].<br/>
</div>

<div class="doc">
<a id="lab298"></a><h3 class="section"> </h3>
 We can also pattern-match on an equality proof: 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">eq_add</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">n<sub>1</sub></span> <span class="id" title="var">n<sub>2</sub></span> : <span class="id" title="var">nat</span>), <span class="id" title="var">n<sub>1</sub></span> == <span class="id" title="var">n<sub>2</sub></span> → (<span class="id" title="var">S</span> <span class="id" title="var">n<sub>1</sub></span>) == (<span class="id" title="var">S</span> <span class="id" title="var">n<sub>2</sub></span>) :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">n<sub>1</sub></span> <span class="id" title="var">n<sub>2</sub></span> <span class="id" title="var">Heq</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">Heq</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">eq_refl</span> <span class="id" title="var">n</span> ⇒ <span class="id" title="var">eq_refl</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
</div>

<div class="doc">
<a id="lab299"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 A tactic-based proof runs into some difficulties if we try to use
    our usual repertoire of tactics, such as <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> and
    <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span>. Those work with *setoid* relations that Coq knows
    about, such as <span class="inlinecode">=</span>, but not our <span class="inlinecode">==</span>. We could prove to Coq that
    <span class="inlinecode">==</span> is a setoid, but a simpler way is to use <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> and
    <span class="inlinecode"><span class="id" title="tactic">apply</span></span> instead. 
</div>
<div class="code">

<span class="id" title="keyword">Theorem</span> <span class="id" title="var">eq_add'</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">n<sub>1</sub></span> <span class="id" title="var">n<sub>2</sub></span> : <span class="id" title="var">nat</span>), <span class="id" title="var">n<sub>1</sub></span> == <span class="id" title="var">n<sub>2</sub></span> → (<span class="id" title="var">S</span> <span class="id" title="var">n<sub>1</sub></span>) == (<span class="id" title="var">S</span> <span class="id" title="var">n<sub>2</sub></span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n<sub>1</sub></span> <span class="id" title="var">n<sub>2</sub></span> <span class="id" title="var">Heq</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">Fail</span> <span class="id" title="tactic">rewrite</span> <span class="id" title="var">Heq</span>. <span class="comment">(*&nbsp;doesn't&nbsp;work&nbsp;for&nbsp;_our_&nbsp;==&nbsp;relation&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">Heq</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">n</span>]. <span class="comment">(*&nbsp;n<sub>1</sub>&nbsp;and&nbsp;n<sub>2</sub>&nbsp;replaced&nbsp;by&nbsp;n&nbsp;in&nbsp;the&nbsp;goal!&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="var">Fail</span> <span class="id" title="tactic">reflexivity</span>. <span class="comment">(*&nbsp;doesn't&nbsp;work&nbsp;for&nbsp;_our_&nbsp;==&nbsp;relation&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">eq_refl</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
 <!-- /quiz -->
</div><div class="quiz">


<div class="doc">
Which of the following is a correct proof object for the proposition
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">∃</span> <span class="id" title="var">x</span>, <span class="id" title="var">x</span> + 3 == 4
</span>?

<div class="paragraph"> </div>

    (1) <span class="inlinecode"><span class="id" title="var">eq_refl</span></span> <span class="inlinecode">4</span>

<div class="paragraph"> </div>

    (2) <span class="inlinecode"><span class="id" title="var">ex_intro</span></span> <span class="inlinecode">(<span class="id" title="var">z</span></span> <span class="inlinecode">+</span> <span class="inlinecode">3</span> <span class="inlinecode">==</span> <span class="inlinecode">4)</span> <span class="inlinecode">1</span> <span class="inlinecode">(<span class="id" title="var">eq_refl</span></span> <span class="inlinecode">4)</span>

<div class="paragraph"> </div>

    (3) <span class="inlinecode"><span class="id" title="var">ex_intro</span></span> <span class="inlinecode">(<span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">z</span></span> <span class="inlinecode">⇒</span> <span class="inlinecode">(<span class="id" title="var">z</span></span> <span class="inlinecode">+</span> <span class="inlinecode">3</span> <span class="inlinecode">==</span> <span class="inlinecode">4))</span> <span class="inlinecode">1</span> <span class="inlinecode">(<span class="id" title="var">eq_refl</span></span> <span class="inlinecode">4)</span>

<div class="paragraph"> </div>

    (4) <span class="inlinecode"><span class="id" title="var">ex_intro</span></span> <span class="inlinecode">(<span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">z</span></span> <span class="inlinecode">⇒</span> <span class="inlinecode">(<span class="id" title="var">z</span></span> <span class="inlinecode">+</span> <span class="inlinecode">3</span> <span class="inlinecode">==</span> <span class="inlinecode">4))</span> <span class="inlinecode">1</span> <span class="inlinecode">(<span class="id" title="var">eq_refl</span></span> <span class="inlinecode">1)</span>

<div class="paragraph"> </div>

    (5) none of the above

</div>
<div class="code">
<div class="togglescript" id="proofcontrol21" onclick="toggleDisplay('proof21');toggleDisplay('proofcontrol21')"><span class="show"></span></div>
<div class="proofscript" id="proof21" onclick="toggleDisplay('proof21');toggleDisplay('proofcontrol21')">
<span class="id" title="var">Fail</span> <span class="id" title="keyword">Definition</span> <span class="id" title="var">quiz1</span> : <span class="id" title="tactic">∃</span> <span class="id" title="var">x</span>, <span class="id" title="var">x</span> + 3 == 4<br/>
&nbsp;&nbsp;:= <span class="id" title="var">eq_refl</span> 4.<br/>
<span class="id" title="var">Fail</span> <span class="id" title="keyword">Definition</span> <span class="id" title="var">quiz2</span> : <span class="id" title="tactic">∃</span> <span class="id" title="var">x</span>, <span class="id" title="var">x</span> + 3 == 4<br/>
&nbsp;&nbsp;:= <span class="id" title="var">ex_intro</span> (<span class="id" title="var">z</span> + 3 == 4) 1 (<span class="id" title="var">eq_refl</span> 4).<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">quiz3</span> : <span class="id" title="tactic">∃</span> <span class="id" title="var">x</span>, <span class="id" title="var">x</span> + 3 == 4<br/>
&nbsp;&nbsp;:= <span class="id" title="var">ex_intro</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">z</span> ⇒ (<span class="id" title="var">z</span> + 3 == 4)) 1 (<span class="id" title="var">eq_refl</span> 4).<br/>
<span class="id" title="var">Fail</span> <span class="id" title="keyword">Definition</span> <span class="id" title="var">quiz4</span> : <span class="id" title="tactic">∃</span> <span class="id" title="var">x</span>, <span class="id" title="var">x</span> + 3 == 4<br/>
&nbsp;&nbsp;:= <span class="id" title="var">ex_intro</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">z</span> ⇒ (<span class="id" title="var">z</span> + 3 == 4)) 1 (<span class="id" title="var">eq_refl</span> 1).<br/>
</div>
</div></div> <!-- /quiz -->

<div class="doc">
<a id="lab300"></a><h1 class="section">Coq's Trusted Computing Base</h1>

<div class="paragraph"> </div>

 The Coq typechecker is what actually checks our proofs.  We
    have to trust it, but it's relatively small and
    straightforward. 
<div class="paragraph"> </div>

 For example, it rejects this broken proof: 
</div>
<div class="code">

<span class="id" title="var">Fail</span> <span class="id" title="keyword">Definition</span> <span class="id" title="var">or_bogus</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span>, <span class="id" title="var">P</span> ∨ <span class="id" title="var">Q</span> → <span class="id" title="var">P</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">fun</span> (<span class="id" title="var">P</span> <span class="id" title="var">Q</span> : <span class="id" title="keyword">Prop</span>) (<span class="id" title="var">A</span> : <span class="id" title="var">P</span> ∨ <span class="id" title="var">Q</span>) ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">A</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">or_introl</span> <span class="id" title="var">H</span> ⇒ <span class="id" title="var">H</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
</div>

<div class="doc">
And these: 
</div>
<div class="code">

<span class="id" title="var">Fail</span> <span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">infinite_loop</span> {<span class="id" title="var">X</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) {<span class="id" title="keyword">struct</span> <span class="id" title="var">n</span>} : <span class="id" title="var">X</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">infinite_loop</span> <span class="id" title="var">n</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="var">Fail</span> <span class="id" title="keyword">Definition</span> <span class="id" title="var">falso</span> : <span class="id" title="var">False</span> := <span class="id" title="var">infinite_loop</span> 0.<br/>
</div>

<div class="doc">
Complex tactics can (in principle and occasionally in
    practice) produce invalid proof objects.  <span class="inlinecode"><span class="id" title="keyword">Qed</span></span> runs the type
    checker to detect such situations. 
</div>
</div>

<div id="footer">
<hr/><a href="coqindex.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>