(** * Предисловие *)

(* ################################################################# *)
(** * Добро пожаловать! *)

(** Это вводный материал к курсу по Coq в Центральном Университете, основанный
    на серии электронных учебников о различных аспектах _Оснований ПО_,
    математических оснований создания надёжного программного обеспечения
    ({http://softwarefoundations.cis.upenn.edu}).  В рамках данного курса мы
    затронем базовые понятия логики, доказательства теорем с помощью компьютера,
    использование средства для интерактивных доказательств Coq, функциональное
    программирование, операционную семантику и техники изучения свойств
    программ.  Знание логики и/или теории языков программирования НЕ
    предполагается, однако наличие общей математической культуры не повредит.

    Отличительная особенность нашего курса (как и исходной серии книг) состоит в
    том, что он на 100% формализован и проверяем машиной: все материалы курса
    это буквально скрипты для Coq.  Предполагается, что читатель изучает
    материал одновременно с запуском интерактивной сессии в Coq.  Все тонкости
    материала полностью формализованы в Coq и абсолютное большинство упражнений
    созданы для выполнения с помощью Coq.

    В рамках данного курса всего будет 8 файлов, по числу занятий. В каждом из
    них есть как разбираемые на занятии упражнения, так и задачи для
    самостоятельного решения, на основе которых будет выставлена оценка. *)

(* ################################################################# *)
(** * Обзор *)

(** Создавать надёжное ПО тяжело -- ОЧЕНЬ тяжело.  Масштаб и сложность
    современных систем, масса привлечённых к разработке людей и набор
    предъявляемых к ним требований делают затруднительным хотя бы более-менее
    правильную реализацию продуктов, не говоря уже о 100%-ной корректности.
    Вдобавок растущая вовлечённость обработки информации в каждый аспект
    общественной жизни многократно увеличивает цену ошибок, багов и проблем с
    безопасностью.

    По мере взросления отрасли, специалисты компьютерных наук и разработчики
    придумали множество техник для улучшения надёжности программных систем,
    начиная от методик управления командами разработчиков (эджайл, экстремальное
    программирование и т.д.) и парадигм в разработке библиотек (например,
    model-view-controller, publish-subscribe, и т.д.) и языков программирования
    (ООП, функциональное программирование, ...) до математических техник для
    формального задания (спецификации) свойств программ, а также инструментов,
    помогающих в проверке этих свойств.  В рамках данного курса мы
    сосредоточимся на последней категории.

    В первой половине курса мы затронем следующие темы:

    (1) базовые инструменты из _логики_ для формулировки и доказательства
        математически точных утверждений о программах;

    (2) использование _ассистентов в формальных доказательствх_ (_proof
        assistants_) для конструирования строгих логических аргументов;

    (3) _функциональное программирование_, и как методику программирования,
        которая упрощает рассуждения о программах, и как мост между
        программированием и логикой. *)

(* ================================================================= *)
(** ** Логика *)

(** Логика -- это область исследований, предметом которых являются
    _доказательства_ -- неопровержимые аргументы в пользу истинности конкретных
    утверждений.  О центральной роли логики в компьютерных науках написаны тонны
    книг; Манна и Уолдингер назвали это "математическим анализом компьютерных
    наук", в то время как статья Халперна и др. _Эффективность логики в
    компьютерных науках_ содержит множество способов, с помощью которых логика
    предлагает важнейшие инструменты и идеи для анализа программ и алгоритмов.
    Действительно, они отмечают, что "На самом деле логика оказалась значительно
    более эффективной в компьютерных науках, чем в математике.  Это весьма
    примечательно, особенно с учетом того, что за последние сто лет математика
    во многом придала импульс развитию логики."

    В частности, фундаментальные инструменты _индуктивных доказательств_ широко
    распространены во всех областях компьютерных наук.  Вы наверняка видели их
    раньше, возможно, в курсе дискретной математики или анализа алгоритмов, но в
    этом курсе мы рассмотрим их более подробно чем вы, вероятно, делали это до
    сих пор. *)

(* ================================================================= *)
(** ** Инструменты интерактивного доказательства теорем *)

(** Обмен идеями между логикой и информатикой не был однонаправленным: CS также
    привнесли много нового в логику. В частности, было разработано множество
    программных средств, помогающих создавать доказательства логических
    утверждений.  Эти инструменты делятся на две большие категории:

       - _Aвтоматизированные средства доказательства теорем_ обеспечивают
         "кнопочное" управление: вы даете им предложение, и они возвращают либо
         _ИСТИНА_, либо _ЛОЖЬ_ (или, иногда, _НЕ ЗНАЮ: НЕ ХВАТИЛО ВРЕМЕНИ_).
         Хотя их возможности к рассуждениям по-прежнему ограничены, за последние
         десятилетия они значительно усовершенствовались и в настоящее время
         используются во множестве ситуаций.  Примеры таких инструментов
         включают в себя SAT-решатели, SMT-солверы и средства проверки моделей.

       - _Инструменты интерактивного доказательства теорем_ (proof assistants)
         -- это гибридные инструменты, автоматизирующие более рутинные аспекты
         создания доказательств, но которые в то же время направляются человеком
         в более сложных аспектах.  Широко используемые ассистенты включают в
         себя Isabelle, Agda, Twelf, ACL2, PVS, F*, HOL4, Lean, Coq и многие
         другие.

    Этот курс основан на Coq, proof assistant-е, который разрабатывается с 1983
    года и который в последние годы привлёк большое сообщество пользователей как
    в научных кругах, так и в индустрии.  Coq предоставляет богатую среду для
    интерактивной разработки формальных рассуждений, проверяемых машиной.  Ядро
    системы Coq -- это простая программа проверки правильности доказательства,
    которая гарантирует, что все шаги в логическом рассуждении корректны.  В
    дополнение к этому ядру среда Coq предоставляет высокоуровневые средства для
    разработки доказательств, включая большую библиотеку общих определений и
    лемм, мощные _тактики_ построения сложных доказательств полуавтоматически, и
    специальный язык программирования для определения новых тактик для
    автоматизации доказательств в специфичных ситуациях.

    Coq стал ключевым стимулирующим фактором для огромного разнообразия работ по
    компьютерным наукам и математике:

    - В качестве _платформы для моделирования языков программирования_, он стал
      стандартным инструментом для исследователей, которым необходимо описывать
      объёмные определения языков и исследовать их свойства.  Например, он
      использовался для проверки безопасности платформы Java Card, для
      формальных спецификаций набора инструкций x86 и LLVM, языков
      программирования (того же C).

    - В качестве _среды для разработки формально сертифицированного программного
      и аппаратного обеспечения_, Coq использовался, например, для создания
      CompCert, полностью верифицированного оптимизирующего компилятора для C, и
      CertiKOS, полностью верифицированного гипервизора, для проверки
      корректности тонких мест в алгоритмах, использующих вычисления c плавающей
      запятой, и является основой для CertiCrypt, FCF и SS Prove, фреймворков
      для проверки безопасности криптографических алгоритмов. Он также
      используется для создания верифицированных реализаций архитектуры
      процессора RISC-V с открытым исходным кодом.

    - В качестве _реалистичной среды для функционального программирования с
      зависимыми типами_, он вдохновил многочисленные инновации.  Например,
      Хоарова теория типов позволяет рассуждать о "предварительных условиях" и
      "постусловиях" (расширение _логики Хоара_, которую мы увидим позже в этом
      курсе) в Coq.

    - В качестве _proof assistant-a для логики высшего порядка_, Coq был
      использован для проверки ряда важных результатов в математике. Например,
      его способность производить сложные вычисления по ходу доказательства
      позволила разработать первое формально верифицированное доказательство
      Теоремы о четырёх красках.  Принятие не-верифицированной версии этого
      доказательства ранее было спорным вопросом среди математиков, потому что
      она требовала компьютерного перебора большого количества вариантов. В свою
      очередь, в формализации на Coq проверяется всё, в том числе и правильность
      произведённых вычислений.  Совсем недавно были предприняты еще более
      масштабные усилия, приведшие к формализации на Coq теоремы Фейта-Томпсона,
      первого важного шага в классификации конечных простых групп.

   Кстати, если вам интересно происхождение названия, вот что написано на
   официальном веб-сайте Coq в Inria (французском национальном исследовательском
   центре, где в основном разрабатывался Coq): "У некоторых французских
   компьютерщиков есть традиция называть свои программы видами животных: Caml,
   Elan, Foc или Phox являются примерами этого негласного соглашения.
   По-французски "coq" означает "петух", а ещё это звучит как аббревиатура
   названия Исчисления Конструкций (Calculus of Constructions, CoC), на котором
   он основан."  Петух также является национальным символом Франции, а C-o-q --
   это первые три буквы фамилии Тьерри Коканда, одного из первых разработчиков
   Coq.

   Правда, после массового возмущения и мольбы англофонов, язык был переименован
   в Rocq. Но в рамках этого курса мы будем пользоваться старым названием. *)

(* ================================================================= *)
(** ** Функциональное программирование *)

(** Термин _функциональное программирование_ применяется как к набору идиом
    программирования, которые могут быть использованы практически в любом
    языке программирования, так и к семейству языков программирования,
    разработанных с учетом этих идиом, включающему Haskell, OCaml, Standard ML,
    F##, Scala, Scheme, Racket, Common Lisp, Clojure, Erlang, F* и Coq.

    Функциональное программирование разрабатывалось на протяжении многих
    десятилетий -- действительно, его корни уходят в лямбда-исчисление Черча,
    которое было изобретено в 1930-х годах, задолго до появления первых
    электронных компьютеров!  Но с начала 90-х годов он вызвал всплеск интереса
    среди промышленных инженеров и разработчиков языков программирования, сыграв
    ключевую роль в высокоприбыльных системах в таких компаниях, как Jane Street
    Capital, Microsoft, Facebook, Twitter и Ericsson.

    Самый основной принцип функционального программирования заключается в том,
    что вычисления, насколько это возможно, должны быть _чистыми_ в том смысле,
    что единственным эффектом исполнения должно быть получение результата в виде
    данных: в нём не должно быть _сайд-эффектов_, таких как ввод-вывод,
    присвоения значений изменяемым переменным, перенаправления указателей и т.д.
    Например, в то время как _императивная_ функция сортировки может взять
    список чисел и переставить его указатели, чтобы упорядочить список, чистая
    функция сортировки возьмет исходный список и вернет _новый_ список,
    содержащий те же числа в отсортированном порядке.

    Существенным преимуществом этого стиля программирования является то, что он
    облегчает понимание программы и рассуждение о её свойствах.  Если каждая
    операция со структурой данных приводит к созданию новой структуры данных,
    оставляя старую структуру неизменной, то нет необходимости беспокоиться о
    том, как эта структура используется совместно и может ли изменение в одной
    части программы нарушить инвариант, на который опирается другая часть
    программы.  Эти соображения особенно важны в конкурентных системах, где
    каждая часть изменяемого состояния, доступная из нескольких потоков,
    является потенциальным источником опасных ошибок. Действительно, большая
    часть современного интереса к применению функционального программирования в
    промышленности обусловлено его более простым поведением при наличии
    параллелизма.

    Еще одна причина нынешнего ажиотажа по поводу функционального
    программирования связана с первой: функциональные программы часто гораздо
    проще распараллеливать и физически распространять, чем их императивные
    аналоги.  Если запуск вычислений не дает никакого эффекта кроме получения
    конкретного значения, неважно, _где_ эти вычисления запускать.  Аналогично,
    если к структуре данных никогда не применяется разрушающее изменение, её
    можно свободно копировать между ядрами или по сети.  Действительно, идиома
    "Map-Reduce", которая лежит в основе обработчиков массово распределённых
    запросов вроде Hadoop и используется в Google для индексации всего
    Интернета, является классическим примером функционального программирования.

    Для целей данного курса функциональное программирование имеет еще одну
    важную черту: оно служит связующим звеном между логикой и компьютерными
    науками.  Действительно, Coq сам по себе можно рассматривать как сочетание
    небольшого, но чрезвычайно выразительного функционального языка
    программирования плюс набор инструментов для формулирования и доказательства
    логических утверждений.  Более того, при более внимательном рассмотрении мы
    обнаружим, что эти две стороны Coq на самом деле являются аспектами одного и
    того же базового механизма -- другими словами, _доказательства -- это
    программы_.  *)

(* ================================================================= *)
(** ** Дополнительная литература *)

(** Этот курс задуман как самостоятельный, но слушатели, которые хотят
    глубже разобраться в отдельных темах, найдут некоторые рекомендации для
    дальнейшего чтения в главе [Postscript]. Библиографию всех цитируемых работ
    можно найти в файле [Bib].*)

(* ################################################################# *)
(** * Практические аспекты *)

(* ================================================================= *)
(** ** Системные требования *)

(** Coq работает на Windows, Linux, и macOS.  Материалы этого курса были
    протестированы на версии Coq 8.19.2.

    Вам потребуется:

    - Свежая версия Coq, доступная на домашней странице Coq
      ({https://coq.inria.fr/download}). "Coq Platform", как правило, установить
      проще всего, особенно на Windows.

      Если Вы используете комбинацию VSCode + Docker, описанную ниже, Вам не
      потребуется устанавливать Coq отдельно.

    - IDE для взаимодействия с Coq.  Есть несколько вариантов:

        - _VsCoq_ это расширение для VS Code, предлагающее простой интерфейс в
          знакомой IDE.  Это "рекомендованный по умолчанию" вариант. Если Вы
          установили Coq с официального сайта, то Вы можете использовать только
          версию "VsCoq Legacy", которая в любом случае более стабильна. Если Вы
          используете менеджер пакетов opam, Вы также можете попробовать
          "VsCoq 2". Это расширение более экспериментальное, но и
          функциональности в нём намного больше.

          VsCoq может быть использован как обычная IDE, либо может быть совмещён
          с Docker (см. ниже) для более легковесной установки.

        - _Proof General_ это IDE, основанная на Emacs.  Обычно, её предпочитают
          пользователи, которым уже привычен Emacs. Он требует отдельной
          установки и настройки (загуглите "Proof General", но, как правило,
          всё, что Вам нужно сделать, это [M-x package-list-packages],
          затем выбрать пакет [proof-general] из списка и нажать [i] для
          установки, затем [x] для исполнения).

          Желающим поэкспериментировать с Coq внутри Emacs могут понравиться
          такие расширения как [company-coq] и [control-lock].

        - _CoqIDE_ это упрощённая самостоятельная IDE.  Она распространяется
          вместе с Coq, так что должна быть доступна сразу, как Вы установите
          Coq. Также её можно собрать из исходников, но на некоторых платформах
          это может потребовать установки дополнительных пакетов для
          GUI-фреймворков и пр.

          Пользователям, которым нравится CoqIDE, стоит попробовать запустить
          его с выключенными режимами "asynchronous" и "error resilience": [[
          coqide -async-proofs off \
          -async-proofs-command-error-resilience off Foo.v &
          ]]

        - Ваш покорный слуга предпочитает использовать _NeoVim_ с плагином
          _Coqtail_. *)

(* ----------------------------------------------------------------- *)
(** *** Coq с VSCode и Docker *)

(** VS Code может взаимодействовать с платформой виртуализации Docker для
    компиляции скриптов на Coq без необходимости какой-либо отдельной
    установки Coq.  Чтобы все настроить, выполните следующие действия:

    - Установите Docker с помощью [https://www.docker.com/get-started/] или
      убедитесь, что у Вашей текущей установки актуальная версия.

    - Убедитесь, что Docker запущен.

    - Установите VS Code из [https://code.visualstudio.com] и запустите его.

    - Установите расширение Remote Containers для VS Code из [
        https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-containers
        ]

    - Склонируйте к себе репозиторий курса (в VS Code это можно сделать, выбрав
      опцию "Clone Git Repository...").  Помимо файла [.v] для каждой главы,
      этот репозиторий будет содержать подпапку [.devcontainer] с инструкциями
      для VSCode о том, где найти соответствующий образ Docker, и файл
      [_CoqProject], наличие которого является триггером для запуска VsCoq.

    - Откройте репозиторий в VS Code. IDE должна спросить вас, хотите ли вы
      запустить проект в соответствующем контейнере Docker.  (Если вас не
      спросят, вы можете открыть командную палитру, нажав клавишу F1, и
      выполнить команду “Dev Containers: Reopen in Container”.)

    - Убедитесь, что VSCoq работает, дважды щелкнув файл [Lecture1.v] в списке
      слева (вы должны увидеть мигающий курсор в открывшемся окне; если нет, вы
      можете щелкнуть на этом окне, чтобы выбрать его), и несколько раз нажмите
      [alt+стрелка вниз] (в Mac OS -- [control+option+стрелка вниз]).  Вы должны
      увидеть, как курсор перемещается по файлу, а область над курсором
      становится подсвеченной.

    - Чтобы узнать, какие ещё сочетания клавиш доступны, нажмите клавишу F1 и
      затем введите [Coq:] или посетите веб-страницы VSCoq:
      [https://github.com/coq-community/vscoq/tree/vscoq1].  *)

(* ================================================================= *)
(** ** Упражнения *)

(** Каждая глава содержит множество упражнений.  Каждое из них отмечено
    "звездным рейтингом", который можно интерпретировать следующим образом:

       - Одна звездочка: простые упражнения, которые подчеркивают некоторые
         моменты в тексте и которые для большинства слушателей должны занять
         всего минуту или две. Возьмите за привычку выполнять их по мере чтения.

       - Две звезды: простые упражнения (пять-десять минут).

       - Три звезды: упражнения, требующие некоторого размышления (от десяти
         минут до получаса).

       - Четыре и пять звезд: более сложные упражнения (дольше получаса).

    Имейте в виду, что автогрейдер присваивает дополнительные баллы за более
    сложные упражнения:

      1 звездочка = 1 балл
      2 звездочки = 2 балла
      3 звездочки = 3 балла
      4 звездочки = 6 баллов
      5 звездочек = 10 баллов

    Некоторые упражнения помечены как "продвинутые", а некоторые - как
    "необязательные".  Выполнение только обязательных, не-продвинутых упражнений
    должно обеспечивать хорошее усвоение базового материала.  Необязательные
    упражнения дают немного дополнительной практики в работе с ключевыми
    понятиями и знакомят с второстепенными темами, которые могут представлять
    интерес для некоторых слушателей.  Продвинутые упражнения предназначены для
    слушателей, которым нужен дополнительный челлендж и более глубокое
    погружение.

    _Пожалуйста, не размещайте решения упражнений в публичном доступе_.
    Оригинальная серия книг, Software Foundations, широко используется как для
    самостоятельного изучения, так и для университетских курсов.  Наличие
    легкодоступных решений делает его гораздо менее полезным для курсов, которые
    обычно содержат домашние задания с оценкой.  Мы особенно просим слушателей
    не размещать решения к упражнениям в тех местах, где их могут найти
    поисковые системы. *)

(* ================================================================= *)
(** ** Загрузка материалов *)

(** Архив с расширением .tar, содержащий все исходники к "публичному релизу"
    оригинальной книги (в виде коллекции скриптов на Coq и файлов HTML) доступен
    по ссылке {https://softwarefoundations.cis.upenn.edu}.

    Наши слегка отредактированные и переведённые на русский язык файлы доступны
    в приватном репозитории курса. По ходу прохождения курса, в нём будут
    появляться новые материалы каждую неделю. *)

(* ################################################################# *)
(** * Ресурсы *)

(* ================================================================= *)
(** ** Лекционные видео *)

(** Лекции по двум летним интенсивам, основанным на оригинальной книге _Logical
    Foundations_ (входит в программу регулярной летней школы DeepSpec) можно
    найти по следующим ссылкам: {https://deepspec.org/event/dsss17} и
    {https://deepspec.org/event/dsss18/}.  Качество видео в лекциях за 2017
    поначалу не очень хорошее, но в дальнейшем становится гораздо лучше.

    Также во внутренней системе ЦУ, как обычно, будут доступны записи всех
    занятий. *)

(** * Основы: Функциональное программмирование на Coq *)

(* ################################################################# *)
(** * Введение *)

(** Функциональный стиль программирования основан на простой, повседневной
    математической интуиции: если процедура или метод не имеют побочных
    эффектов, то (игнорируя эффективность) все, что нам нужно знать для работы с
    ним -- это то, как он сопоставляет входные данные с выходными, то есть мы
    можем думать о нём просто как о конкретном методе вычисления математической
    функции.  Это одно из значений слова "функциональный" в словосочетании
    "функциональное программирование".  Прямая связь между программами и
    простыми математическими объектами поддерживает как формальную корректность
    доказательств, так и обоснованные неформальные рассуждения о поведении
    программы.

    Другой смысл, в котором функциональное программирование является
    "функциональным", заключается в том, что оно подчеркивает использование
    функций в качестве значений _первого класса_ -- т.е. значений, которые могут
    передаваться в качестве аргументов другим функциям, возвращаться в качестве
    результатов, включаться в структуры данных и т.д.  Понимание того, что
    функции можно рассматривать как данные, порождает множество полезных и
    мощных идиом программирования.

    Другие общие черты функциональных языков включают в себя _алгебраические
    типы данных_ и _сопоставление c образцом_, которые упрощают создание сложных
    структур данных и манипулирование ими, а также _полиморфные системы типов_,
    поддерживающие абстракцию и повторное использование кода.  В Coq доступны
    все эти функции.

    В первой четверти этого занятия представлены наиболее важные элементы
    собственного функционального языка программирования Coq, _Gallina_.  Во
    второй части представлены некоторые базовые _тактики_, которые можно
    использовать для доказательства свойств программ, написанных на Gallina. *)

(* ################################################################# *)
(** * Сдача домашних заданий *)

(** Мы используем скрипты на Coq для автопроверки Ваших домашних заданий.  Чтобы
    эти скрипты работали корректно (и чтобы вы получили полную оценку за свою
    работу!), пожалуйста, внимательно следуйте этим правилам:

      - Не меняйте названия упражнений. В противном случае скрипты для
        выставления оценок не смогут найти Ваше решение.
      - Не удаляйте упражнения.  Если вы пропустите какое-либо упражнение
        (например, поскольку оно помечено как "необязательное" или потому что вы
        не можете его решить), можно оставить частичное доказательство в вашем
        файле [.v]; в этом случае, пожалуйста, убедитесь, что оно заканчивается
        ключевым словом [Admitted] (а не, например, [Abort]).
      - В своих решениях можно использовать дополнительные определения
        (вспомогательных функций, полезных лемм и т.д.).  Вы можете поместить их
        перед теоремой, которую вас просят доказать.
      - Если вы вводите вспомогательную лемму, которую вы в конечном итоге не
        можете доказать, заканчивайте её словом [Admitted], затем не забудьте
        также закончить основную теорему, в которой вы ее используете, словом
        [Admitted], а не [Qed].  Это поможет вам получить частичный балл в том
        случае, если вы используете эту основную теорему для решения
        последующего упражнения.

    Вы также заметите, что каждый файл (например, [Lecture1.v]) сопровождается
    _тестирующим скриптом_ ([Lecture1Test.v]), который автоматически
    подсчитывает баллы за готовые домашние задания в этой главе.  Эти скрипты в
    основном предназначены для автопроверки, но вы также можете воспользоваться
    ими, чтобы еще раз проверить, правильно ли отформатирован ваш файл, прежде
    чем сдать его.  Ввполните в терминале команду "[make Lecture1Test.vo]" или
    выполните следующие действия:

       coqc -Q . Lecture1.v
       coqc -Q . Lecture1Test.v

    Более подробную информацию о том, как интерпретировать выходные данные
    тестирующих скриптов, смотрите далее.

    Сам тестирующий скрипт ([Lecture1Test.v]) сдавать не нужно!

    Для сдачи домашних заданий сделайте следующее:

      - Создайте приватную копию репозитория курса.
      - Выдайте лектору доступ к Вашей приватной копии.
      - Решайте домашнее задание прямо в файлах [Lecture1.v], [Lecture2.v],...
      - Для сдачи домашнего задания на проверку создавайте коммиты с Вашими
        изменениями и отправляйте их в Вашу приватную копию.
      - В репозитории настроен GitHub Workflow, запускающий автопроверку при
        каждом коммите в основную ветку. Это поможет и Вам, и проверяющему сразу
        увидеть результаты проверки. *)

(* ################################################################# *)
(** * Типы данных и функции *)

(* ================================================================= *)
(** ** Типы-перечисления *)

(** Одной из примечательных особенностей Coq является то, что встроенная в него
    функциональность _чрезвычайно_ ограничена.  Например, вместо предоставления
    обычного набора атомарных типов данных (логические значения, целые числа,
    строки и т.д.), Coq предлагает мощный механизм для определения новых типов
    данных с нуля, предоставляя возможность задать все эти знакомые типы на
    уровне библиотек.

    Естественно, дистрибутив Coq поставляется с обширной стандартной
    библиотекой, предоставляющей определения логических значений, чисел и многих
    распространенных структур данных, таких как списки и хэш-таблицы.  Но в этих
    библиотечных определениях нет ничего волшебного или примитивного.  Чтобы
    проиллюстрировать это, в этом курсе мы подробно рассмотрим (почти) все
    определения, которые нам нужны, вместо того чтобы брать их из стандартной
    библиотеки. *)

(* ================================================================= *)
(** ** Дни недели *)

(** Чтобы увидеть, как работает этот механизм определений, давайте начнем с
    очень простого примера.  Следующее объявление сообщает Coq-у, что мы
    определяем набор значений данных -- _тип_. *)

Inductive day : Type :=
  | monday
  | tuesday
  | wednesday
  | thursday
  | friday
  | saturday
  | sunday.

(** Новый тип называется [day], а его членами являются [monday], [tuesday] и
    т.д.

    Определив [day], мы можем написать функции, которые работают с днями
    недели. *)

Definition next_working_day (d:day) : day :=
  match d with
  | monday    => tuesday
  | tuesday   => wednesday
  | wednesday => thursday
  | thursday  => friday
  | friday    => monday
  | saturday  => monday
  | sunday    => monday
  end.

(** Обратите внимание, что типы аргументов и возвращаемых значений этой функции
    объявлены здесь явно.  Как и в большинстве функциональных языков
    программирования, Coq часто может сам определять эти типы, если они не
    заданы явно -- т.е. он может выполнять _вывод типов_ -- но, как правило, мы
    выписываем их явно, чтобы облегчить чтение. *)

(** Определив функцию, мы можем проверить, работает ли она на некоторых
    примерах.  На самом деле в Coq есть три разных способа выполнения примеров.
    Во-первых, мы можем использовать команду [Compute] для вычисления составного
    выражения, включающего [next_working_day]. *)

Compute (next_working_day friday).
(* ==> monday : day *)

Compute (next_working_day (next_working_day saturday)).
(* ==> tuesday : day *)

(** (Мы показываем ответы Coq в комментариях; если с Вами сейчас есть Ваш
    компьютер, это отличный момент, чтобы запустить интерпретатор Coq в вашей
    любимой среде IDE (инструкции по установке смотрите выше) и попробовать его
    самостоятельно.  Загрузите этот файл, [Lecture1.v], из репозитория, найдите
    приведенный выше пример, отправьте его в Coq и понаблюдайте за
    результатом.) *)

(** Во-вторых, мы можем записать _ожидаемый_ результат в виде примера Coq: *)

Example test_next_working_day:
  (next_working_day (next_working_day saturday)) = tuesday.

(** Это объявление делает две вещи: оно создает утверждение (что вторым рабочим
    днем после [субботы] является [вторник]) и присваивает утверждению имя,
    которое можно использовать для ссылки на него позже. Создав утверждение, мы
    также можем попросить Coq проверить его следующим образом: *)

Proof. simpl. reflexivity.  Qed.

(** Детали сейчас не важны, но, по сути, этот небольшой скрипт можно прочитать
    как "Утверждение, которое мы только что сделали, можно доказать, заметив,
    что обе стороны равенства приводят к одному и тому же результату". *)

(** В-третьих, мы можем попросить Coq извлечь из нашего [Определения] программу
    на более традиционном языке программирования (OCaml, Scheme или Haskell) с
    помощью высокопроизводительного компилятора.  Это средство очень полезно,
    поскольку оно прокладывает нам путь от корректных-по-построению алгоритмов,
    написанных на Gallina, к эффективному машинному коду.

    (Конечно, мы доверяем корректности компилятора OCaml/Haskell/Scheme и
    средствам извлечения Coq самим по себе, но это все равно большой шаг вперед
    по сравнению с тем, как сегодня разрабатывается большинство программ!)

    Действительно, это одно из основных применений, для которых был разработан
    Coq. Мы вернемся к этой теме в следующих главах. *)

(** Инструкция [Require Export] в следующей строке указывает Coq использовать
    модуль [String] из стандартной библиотеки.  Мы будем использовать строки
    для различных целей в последующих занятиях, но нам нужно [Потребовать] это
    здесь, чтобы скрипты автопроверки могли использовать строки для своих
    целей. *)
From Coq Require Export String.

(* ================================================================= *)
(** ** Логические значения *)

(** Аналогично дням недели, определённым выше, мы можем определить стандартный
    тип логических значений [bool] с элементами [true] и [false]. *)

Inductive bool : Type :=
  | true
  | false.

(** Функции над логическими значениями могут быть определены таким же образом,
    как выше: *)

Definition negb (b:bool) : bool :=
  match b with
  | true => false
  | false => true
  end.

Definition andb (b1:bool) (b2:bool) : bool :=
  match b1 with
  | true => b2
  | false => false
  end.

Definition orb (b1:bool) (b2:bool) : bool :=
  match b1 with
  | true => true
  | false => b2
  end.

(** (Хотя здесь мы используем наши собственные логические значения ради создания
    всего с нуля, Coq, конечно же, по умолчанию предоставляет реализацию
    логических значений, а также множество полезных функций и лемм.  Везде, где
    это было возможно, мы давали нашим собственным определениям и теоремам
    названия, соответствующие тем, что есть в стандартной библиотеке.) *)

(** Последние два из них иллюстрируют синтаксис Coq для определения функций с
    несколькими аргументами.  Соответствующий синтаксис _применения_ функций с
    несколькими аргументами проиллюстрирован следующими "юнит-тестами", которые
    представляют собой полную спецификацию -- таблицу истинности -- для функции
    [orb].: *)

Example test_orb1:  (orb true  false) = true.
Proof. simpl. reflexivity.  Qed.
Example test_orb2:  (orb false false) = false.
Proof. simpl. reflexivity.  Qed.
Example test_orb3:  (orb false true)  = true.
Proof. simpl. reflexivity.  Qed.
Example test_orb4:  (orb true  true)  = true.
Proof. simpl. reflexivity.  Qed.

(** Мы также можем ввести немного знакомого инфиксного синтаксиса для логических
    операций, которые мы только что определили. Команда [Notation] определяет
    новую символьную запись для существующих определений. *)

Notation "x && y" := (andb x y).
Notation "x || y" := (orb x y).

Example test_orb5:  false || false || true = true.
Proof. simpl. reflexivity. Qed.

(** _Примечание о нотации_: В файлах [.v] мы используем квадратные скобки
    для выделения фрагментов кода Coq в комментариях; это соглашение, также
    используемое инструментом документации [coqdoc], визуально отделяет их от
    окружающего текста.  В HTML-версии файлов эти фрагменты текста выделены
    другим шрифтом. *)

(** Эти примеры также дают повод показать еще одну маленькую особенность
    Gallina: условные выражения... *)

Definition negb' (b:bool) : bool :=
  if b then false
  else true.

Definition andb' (b1:bool) (b2:bool) : bool :=
  if b1 then b2
  else false.

Definition orb' (b1:bool) (b2:bool) : bool :=
  if b1 then true
  else b2.

(** Условные выражения в Coq точно такие же, как и в любом другом языке, с одним
    небольшим обобщением:

    Поскольку тип [bool] не встроен, Coq фактически поддерживает условные
    выражения для _любого_ индуктивно определенного типа с ровно двумя
    конструкторами в его определении.  Условие считается истинным, если оно
    вычисляется как первый конструктор [Индуктивного] определения (которое,
    просто потому что мы так выбрали, в данном случае называется [true]), и
    ложной, если она вычисляется как второй. *)

(** Например, мы можем определить следующий тип данных [bw] с помощью двух
    конструкторов, представляющих черный ([b]) и белый ([w]) цвета, и определить
    функцию [invert], которая инвертирует значения этого типа с помощью
    условного выражения. *)

Inductive bw : Type :=
  | bw_black
  | bw_white.

Definition invert (x: bw) : bw :=
  if x then bw_white
  else bw_black.

Compute (invert bw_black).
(* ==> bw_white : bw *)

Compute (invert bw_white).
(* ==> bw_black : bw *)

(** **** Упражнение: 1 звезда, стандартное (nandb)

    Команда [Admitted] может использоваться как заглушка для неполного
    доказательства.  Мы используем ее в упражнениях, чтобы указать части,
    которые мы оставляем для Вас, т.е. ваша задача -- заменить [Допущенные]
    части настоящими доказательствами.

    Удалите "[Admitted.]" и завершите определение следующей функции; затем
    убедитесь, что Coq справляется с проверкой каждого из приведенных ниже
    [Примеров].  (Т.е. заполните каждое доказательство, следуя приведенной выше
    модели тестов [orb], и убедитесь, что Coq их принимает.) Функция должна
    возвращать [true], если один или оба ее входных сигнала равны [false].

    Подсказка: если [simpl] не упростит цель вашего доказательства, вероятно,
    это потому, что вы определили [nandb] без использования выражения [match].
    Попробуйте другое определение [nandb] или просто пропустите [simpl] и
    перейдите непосредственно к [reflexivity]. Мы объясним этот феномен позднее
    в рамках этого занятия. *)

Definition nandb (b1:bool) (b2:bool) : bool
  (* ЗАМЕНИТЕ ЭТУ СТРОКУ НА ":= _ваше_определение_ ." *). Admitted.

Example test_nandb1:               (nandb true false) = true.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
Example test_nandb2:               (nandb false false) = true.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
Example test_nandb3:               (nandb false true) = true.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
Example test_nandb4:               (nandb true true) = false.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** **** Упражнение: 1 звезда, стандартное (andb3)

    Сделайте то же самое для функции [andb3] ниже. Эта функция должна возвращать
    [true] когда все её входы [true], и [false] в противном случае. *)

Definition andb3 (b1:bool) (b2:bool) (b3:bool) : bool
  (* ЗАМЕНИТЕ ЭТУ СТРОКУ НА ":= _ваше_определение_ ." *). Admitted.

Example test_andb31:                 (andb3 true true true) = true.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
Example test_andb32:                 (andb3 false true true) = false.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
Example test_andb33:                 (andb3 true false true) = false.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
Example test_andb34:                 (andb3 true true false) = false.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(* ================================================================= *)
(** ** Типы *)

(** Каждое выражение в Coq имеет тип, описывающий, что именно оно вычисляет.
    Команда [Check] просит Coq распечатать тип выражения. *)

Check true.
(* ===> true : bool *)

(** Если после [Check] следует двоеточие и объявление типа, Coq проверит,
    соответствует ли тип выражения заданному типу и остановится с ошибкой, если
    это не так. *)

Check true
  : bool.
Check (negb true)
  : bool.

(** Функции, подобные [negb], сами по себе также являются значениями, как [true]
    и [false].  Их типы называются _типами функций_ и пишутся со стрелками. *)

Check negb
  : bool -> bool.

(** Тип [negb], записываемый как [bool -> bool] и произносимый как "[bool]
    стрелка [bool]", можно прочитать как "Получив на вход данные типа [bool],
    эта функция возвращает данные типа [bool]". Аналогично, тип [and],
    записанный как [bool -> bool -> bool], может быть прочитан следующим
    образом: "Получив на вход два значения, каждое из которых имеет тип [bool],
    эта функция возвращает значение типа [bool]". *)

(* ================================================================= *)
(** ** Новые типы из старых *)

(** Типы, которые мы определили до сих пор, являются примерами
    "типов-перечислений": их определения явно перечисляют конечный набор
    элементов, называемых _конструкторами_.  Вот более интересное определение
    типа, где один из конструкторов принимает аргумент: *)

Inductive rgb : Type :=
  | red
  | green
  | blue.

Inductive color : Type :=
  | black
  | white
  | primary (p : rgb).

(** Давайте изучим его более подробно.

    [Индуктивное] определение выполняет две функции:

    - Оно определяет набор новых _конструкторов_. Например, [red], [primary],
      [true], [false], [monday] и т.д. являются конструкторами.

    - Оно группирует их в новый именованный тип, например [bool], [rgb] или
      [color].

    _Конструкторные выражения_ формируются с помощью применения конструктора к
    некоторому (0 или более) количеству других конструкторов или конструкторных
    выражений, соблюдая заявленное количество и типы аргументов конструктора.
    Например, это правильные конструкторные выражения...
        - [red]
        - [true]
        - [primary red]
        - и т.д.
   ... а эти -- нет:
        - [red primary]
        - [true red]
        - [primary (primary red)]
        - и т.д. *)

(** В частности, определения [rgb] и [color] указывают, какие конструкторные
    выражения принадлежат множествам [rgb] и [color]:

    - [red], [green] и [blue] принадлежат набору [rgb].;
    - [black] и [white] относятся к множеству [color];
    - если [p] является конструкторным выражением, принадлежащим набору [rgb],
      то [primary p] ("конструктор [primary], примененный к аргументу [p]")
      является конструкторным выражением, принадлежащим множеству [color]; и
    - конструкторные выражения, сформированные этими способами, являются
      _единственными_ принадлежащими множествам [rgb] и [color]. *)

(** Мы можем определить функции на цветах, используя сопоставление с образцом,
    точно так же, как мы это делали для [day] и [bool]. *)

Definition monochrome (c : color) : bool :=
  match c with
  | black => true
  | white => true
  | primary p => false
  end.

(** Раз конструктор [primary] принимает аргумент, то образец, соответствующий
    [primary], должен содержать либо переменную, как мы только что сделали
    (обратите внимание, что мы можем свободно выбирать ее имя), либо константу
    соответствующего типа (как показано ниже). *)

Definition isred (c : color) : bool :=
  match c with
  | black => false
  | white => false
  | primary red => true
  | primary _ => false
  end.

(** Шаблон "[primary _]" здесь является сокращением для обозначения
    "конструктора [primary], применяемого к любому конструктору [rgb], кроме
    [red]". *)

(** (Пустой образец [_] имеет тот же эффект, что и фиктивная переменная-образец
    [p] в определении [monochrome].) *)

(* ================================================================= *)
(** ** Модули *)

(** Coq предоставляет _модульную систему_, помогающую в организации больших
    проектов.  Большая часть её функций нам не понадобятся, но одна из них здесь
    будет полезна: если мы поместим набор объявлений между маркерами [Module X]
    и [End X], то в оставшейся части файла после [Конца] на эти определения
    ссылаются как [X.foo] вместо просто [foo].  Мы будем использовать эту
    функцию для ограничения области видимости определений, чтобы свободно
    переиспользовать имена. *)

Module Playground.
  Definition foo : rgb := blue.
End Playground.

Definition foo : bool := true.

Check Playground.foo : rgb.
Check foo : bool.

(* ================================================================= *)
(** ** Кортежи *)

Module TuplePlayground.

(** Для создания типа кортежа можно использовать один конструктор с несколькими
    параметрами. В качестве примера рассмотрим представление четырех битов в
    ниббле (половина байта). Сначала мы определяем тип данных [bit], который
    напоминает [bool] (используя конструкторы [B0] и [B1] для двух возможных
    значений битов) и затем определяем тип данных [nybble], который по сути
    является кортежем из четырех битов. *)

Inductive bit : Type :=
  | B1
  | B0.

Inductive nybble : Type :=
  | bits (b0 b1 b2 b3 : bit).

Check (bits B1 B0 B1 B0)
  : nybble.

(** Конструктор [bits] действует как обёртка для его содержимого. Развёртывание
    может быть выполнено путем сопоставления с образцом, как в приведенной ниже
    функции [all_zero], которая проверяет, все ли биты в ниббле равны [B0].

    Мы используем символ подчеркивания (_), чтобы избежать придумывания имен
    переменных, которые не будут использоваться. *)

Definition all_zero (nb : nybble) : bool :=
  match nb with
  | (bits B0 B0 B0 B0) => true
  | (bits _ _ _ _) => false
  end.

Compute (all_zero (bits B1 B0 B1 B0)).
(* ===> false : bool *)
Compute (all_zero (bits B0 B0 B0 B0)).
(* ===> true : bool *)

End TuplePlayground.

(* ================================================================= *)
(** ** Числа *)

(** Мы поместили этот раздел в модуль, чтобы наше собственное определение
    натуральных чисел не мешалось определению из стандартной библиотеки.  В
    оставшейся части книги мы будем использовать определение из стандартной
    библиотеки. *)

Module NatPlayground.

(** Все типы, которые мы определили до сих пор -- как "перечисляемые типы",
    такие как [day], [bool] и [bit], так и типы кортежей, такие как [nybble],
    построенные на их основе -- конечны.  Натуральные числа, с другой стороны,
    представляют собой бесконечное множество, поэтому нам нужно будет
    использовать более мощный способ объявления типа для их представления.

    Существует множество вариантов представления чисел. Вы почти наверняка
    знакомы с десятичной системой счисления (основание 10), в которой цифры от 0
    до 9 используются, например, для образования числа 123. Скорее всего, вы
    также сталкивались с шестнадцатеричной системой счисления (основание 16), в
    которой то же самое число представлено как 7B, или восьмеричное (основание
    8), где оно равно 173, или двоичное (основание 2), где оно равно 1111011.
    Используя перечислимый тип для представления цифр, мы могли бы использовать
    любое из них в качестве нашего представления натуральных чисел.
    Действительно, есть обстоятельства, когда каждый из этих вариантов был бы
    полезен.

    Двоичное представление ценно при изготовлении микросхем, потому что цифры
    могут быть представлены только двумя различными уровнями напряжения тока,
    что приводит к упрощению схемы. Аналогично, в данном случае мы хотели бы
    выбрать представление, которое делает _доказательства_ проще.

    На самом деле, существует еще более простое представление чисел, чем в
    двоичной системе, а именно унарный код (основание 1), в котором используется
    только одна цифра (как, возможно, делали наши предки для подсчета дней,
    делая царапины на стенах их пещер). Для представления унарных чисел с
    помощью типа данных Coq мы используем два конструктора. Конструктор [O]
    (заглавная О) представляет ноль. Конструктор [S], применённый к
    представлению натурального числа n, представляет число n+1, где [S] означает
    "последующий", "successor" (или "царапина", "scratch").  Вот полное
    определение типа данных: *)

Inductive nat : Type :=
  | O
  | S (n : nat).

(** В таком определении, 0 представляется как [O], 1 -- как [S O], 2 -- как
    [S (S O)] и т.д. *)

(** Неофициально пункты определения могут быть прочитаны следующим образом:
      - [O] -- это натуральное число (помните, что это буква "[O]",
        а не цифра "[0]").
      - [S] можно поставить перед натуральным числом, чтобы получить другое
        натуральное число; то есть, если [n] -- натуральное число, то и [S n]
        тоже. *)

(** Опять же, давайте изучим это определение более подробно.  В определении
    [nat] говорится о том, какие выражения в множестве [nat] мы можем построить:

    - конструкторное выражение [O] принадлежит множеству [nat];
    - если [n] является конструкторным выражением, принадлежащим множеству
      [nat], то [S n] также является конструкторным выражением, принадлежащим
      набору [nat]; и
    - конструкторные выражения, сформированные этими двумя способами, являются
      единственными конструкторными выражениями, принадлежащими множеству
      [nat]. *)

(** Эти условия пользуются той самой мощью [Индуктивных] определений, о которых
    мы говорили ранее.  Из них следует, что множество конструкторных выражений
    [nat] состоит в точности из [O], [SO], [S (S O)], [S (S (S O))] и т.д., в то
    время как [true], [andb true false], [S (S false)] и [O (O (O S))] ему не
    принадлежат.

    Важным моментом здесь является то, что все, что мы делали до сих пор -- это
    просто определение представления чисел: способа их записи. Имена [O] и [S]
    являются произвольными, и на данный момент они не имеют никакого особого
    значения -- это просто два разных знака, которые мы можем использовать для
    записи чисел, вместе с правилом, которое гласит: [nat] будет записан в виде
    некоторой последовательности знаков [S], за которыми следует [O].  Если мы
    хотим, мы можем записать по сути то же самое определение другим образом: *)

Inductive otherNat : Type :=
  | stop
  | tick (foo : otherNat).

(** _Интерпретация_ этих меток зависит от того, как мы пользуемся ими при
    вычислениях. *)

(** Мы можем сделать это, написав функции, которые используют сопоставление с
    образцом для натуральных чисел, точно так же, как мы делали это выше для
    логических значений и дней -- например, вот функция, вычисляющая число,
    предшествующее данному: *)

Definition pred (n : nat) : nat :=
  match n with
  | O => O
  | S n' => n'
  end.

(** Вторую ветку можно прочитать так: "если [n] имеет форму [S n']
    для некоторого [n'], то верни [n']". *)

(** Следующая команда [End] закрывает текущий модуль, поэтому
    [nat] будет ссылаться на тип из стандартной библиотеки. *)

End NatPlayground.

(** Поскольку натуральные числа чрезвычайно распространенный тип данных, Coq
    предоставляет чуть-чуть встроенной магии для их ввода и печати: обычные
    десятичные числа могут использоваться в качестве альтернативы "унарной"
    записи через конструкторы [S] и [O].  По умолчанию Coq выводит числа в
    десятичной системе счисления: *)

Check (S (S (S (S O)))).
(* ===> 4 : nat *)

Definition minustwo (n : nat) : nat :=
  match n with
  | O => O
  | S O => O
  | S (S n') => n'
  end.

Compute (minustwo 4).
(* ===> 2 : nat *)

(** Конструктор [S] имеет тип [nat -> nat], как и функции, такие как [pred] и
    [minustwo]: *)

Check S        : nat -> nat.
Check pred     : nat -> nat.
Check minustwo : nat -> nat.

(** Все эти функции можно применить к числу, чтобы получить другое число.
    Однако существует фундаментальное различие между [S] и двумя другими
    функциями: такие функции, как [pred] и [minustwo], определяются путем
    задания _правил вычисления_ -- например, определение [pred] говорит, что
    [pred 2] можно упростить до [1], в то время как в определении [S] никакого
    поведения нет.  Хотя этот конструктор и _подобен_ функции в том смысле, что
    он может быть применён к аргументу, он _вообще_ ничего не делает!  Это
    просто способ записи чисел.

    Посмотрим на самые обыкновенные десятичные числа: число [1] -- это не
    вычисление; это кусок данных.  Когда мы пишем [111] для обозначения числа
    сто одиннадцать, мы используем [1], трижды, чтобы записать конкретное
    представление числа.

    Давайте продолжим и определим еще несколько функций над числами.

    Для наиболее интересных вычислений, связанных с числами, просто
    сопоставления с образцом недостаточно: нам также нужна рекурсия.  Например,
    чтобы проверить, является ли число [n] четным, нам может потребоваться
    рекурсивно проверить, является ли [n-2] четным.  Такие функции вводятся с
    помощью ключевого слова [Fixpoint] вместо [Definition]. *)

Fixpoint even (n:nat) : bool :=
  match n with
  | O        => true
  | S O      => false
  | S (S n') => even n'
  end.

(** Мы могли бы определить [odd] с помощью аналогичного объявления [Fixpoint],
    но вот более простой способ: *)

Definition odd (n:nat) : bool :=
  negb (even n).

Example test_odd1:    odd 1 = true.
Proof. simpl. reflexivity.  Qed.
Example test_odd2:    odd 4 = false.
Proof. simpl. reflexivity.  Qed.

(** (Если вы ознакомитесь с этими доказательствами в интерактивном режиме, вы
    можете заметить, что [simpl] на самом деле не влияет на цель -- вся работа
    выполняется с помощью [рефлексивности].  Вскоре мы обсудим, почему.)

    Естественно, мы также можем определять функции с несколькими аргументами с
    помощью рекурсии.  *)

Module NatPlayground2.

Fixpoint plus (n : nat) (m : nat) : nat :=
  match n with
  | O => m
  | S n' => S (plus n' m)
  end.

(** Прибавив три к двум, мы получим пять (ого!): *)

Compute (plus 3 2).
(* ===> 5 : nat *)

(** Упрощения выражения, которые Coq выполняет в этот момент, можно представить
    следующим образом: *)

(*      [plus 3 2]
   т.е. [plus (S (S (S O))) (S (S O))]
    ==> [S (plus (S (S O)) (S (S O)))]
          по второй клозе в [match]
    ==> [S (S (plus (S O) (S (S O))))]
          по второй клозе в [match]
    ==> [S (S (S (plus O (S (S O)))))]
          по второй клозе в [match]
    ==> [S (S (S (S (S O))))]
          по первой клозе в [match]
   т.е. [5]  *)

(** Для удобства записи, если два или более аргумента имеют одинаковый тип, они
    могут быть записаны вместе.  В определении ниже [(n m : nat)] означает то же
    самое, как если бы мы написали [(n : nat) (m : nat)]. *)

Fixpoint mult (n m : nat) : nat :=
  match n with
  | O => O
  | S n' => plus m (mult n' m)
  end.

Example test_mult1: (mult 3 3) = 9.
Proof. simpl. reflexivity.  Qed.

(** Мы можем сопоставить с образцом два выражения за раз, поставив запятую
    между ними: *)

Fixpoint minus (n m:nat) : nat :=
  match n, m with
  | O   , _    => O
  | S _ , O    => n
  | S n', S m' => minus n' m'
  end.

End NatPlayground2.

Fixpoint exp (base power : nat) : nat :=
  match power with
  | O => S O
  | S p => mult base (exp base p)
  end.

(** **** Упражнение: 1 звезда, стандартное (factorial)

    Вспомним стандартное определение факториала:

       0!  =  1
       n!  =  n * (n-1)!     (если n>0)

    Переведите его на Coq.

    Убедитесь, что вы поставили [:=] между заголовком, который мы предоставили,
    и Вашим определением.  Если Вы видите ошибку типа "The reference factorial
    was not found in the current environment", это означает, что Вы забыли
    [:=]. *)

Fixpoint factorial (n:nat) : nat
  (* ЗАМЕНИТЕ ЭТУ СТРОКУ НА ":= _ваше_определение_ ." *). Admitted.

Example test_factorial1:          (factorial 3) = 6.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
Example test_factorial2:          (factorial 5) = (mult 10 12).
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** Опять же, мы можем упростить чтение и запись числовых выражений,
    введя обозначения для сложения, вычитания и умножения. *)

Notation "x + y" := (plus x y)
                       (at level 50, left associativity)
                       : nat_scope.
Notation "x - y" := (minus x y)
                       (at level 50, left associativity)
                       : nat_scope.
Notation "x * y" := (mult x y)
                       (at level 40, left associativity)
                       : nat_scope.

Check ((0 + 1) + 1) : nat.

(** (Аннотации [level], [associativity] и [nat_scope] определяют, как эти
    обозначения обрабатываются синтаксическим анализатором Coq.  Подробности не
    важны для наших целей, но заинтересованные читатели могут обратиться к
    разделу "Подробнее о нотации" в конце этой главы.)

    Обратите внимание, что эти объявления не меняют определения, которые мы
    уже ввели: это просто инструкции для синтаксического анализатора Coq
    читать [x + y] как [plus xy] и, наоборот, отображать [plus xy] как
    [x + y]. *)

(** Когда мы говорим, что в Coq практически ничего не встроено, мы действительно
    имеем это в виду: даже проверка равенства -- это операция, определяемая
    пользователем! Вот функция [eqb], которая проверяет натуральные числа на
    равенство ([eq]), возвращающая логическое значение ([b]).  Обратите внимание
    на использование вложенных сопоставлений с образцом (мы также могли бы
    сопоставить с образцом оба аргумента вместе, как в определении [minus]). *)

Fixpoint eqb (n m : nat) : bool :=
  match n with
  | O => match m with
         | O => true
         | S m' => false
         end
  | S n' => match m with
            | O => false
            | S m' => eqb n' m'
            end
  end.

(** Аналогично, функция [leb] проверяет, является ли ее первый аргумент меньшим
    или равным второму, и возвращает логическое значение. *)

Fixpoint leb (n m : nat) : bool :=
  match n with
  | O => true
  | S n' =>
      match m with
      | O => false
      | S m' => leb n' m'
      end
  end.

Example test_leb1:                leb 2 2 = true.
Proof. simpl. reflexivity.  Qed.
Example test_leb2:                leb 2 4 = true.
Proof. simpl. reflexivity.  Qed.
Example test_leb3:                leb 4 2 = false.
Proof. simpl. reflexivity.  Qed.

(** Мы будем часто использовать эти функции (особенно [eqb]), поэтому давайте
    определим для них инфиксную нотацию. *)

Notation "x =? y" := (eqb x y) (at level 70) : nat_scope.
Notation "x <=? y" := (leb x y) (at level 70) : nat_scope.

Example test_leb3': (4 <=? 2) = false.
Proof. simpl. reflexivity.  Qed.

(** Теперь у нас есть два символа, которые выглядят как равенство: [=] и [=?].
    Позже мы расскажем гораздо больше об их различиях и сходствах. А пока
    главное, на что следует обратить внимание, это то, что [x = y] -- это
    логическое _утверждение_, "пропозиция", которую мы можем попытаться
    доказать, в то время как [x =? y] - это логическое _выражение_, значение
    которого (либо [истина], либо [ложь]) мы можем вычислить. *)

(** **** Упражнение: 1 звезда, стандартное (ltb)

    Функция [ltb] проверяет, меньше ли ([l]ess-[t]han) первый аргумент второго,
    и возвращает логическое значение ([b]).  Вместо того, чтобы объявлять новый
    [Fixpoint] для её вычисления, определите её в терминах ранее определенной
    функции.  (Можно обойтись только одной ранее определенной функцией, но Вы
    можете использовать две, если хотите.) *)

Definition ltb (n m : nat) : bool
  (* ЗАМЕНИТЕ ЭТУ СТРОКУ НА ":= _ваше_определение_ ." *). Admitted.

Notation "x <? y" := (ltb x y) (at level 70) : nat_scope.

Example test_ltb1:             (ltb 2 2) = false.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
Example test_ltb2:             (ltb 2 4) = true.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
Example test_ltb3:             (ltb 4 2) = false.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(* ################################################################# *)
(** * Доказательство через упрощения *)

(** Теперь, когда мы рассмотрели несколько типов данных и функций, давайте
    перейдем к описанию и доказательству их свойств и поведения.

    На самом деле, мы уже начали это делать: в каждом [Примере] в предыдущих
    разделах было сделано точное утверждение о поведении некоторых функций на
    некоторых конкретных входных данных.  Доказательства этих утверждений
    всегда были одинаковыми: используем [simpl] для упрощения обеих частей
    уравнения, затем используем [reflexivity] для проверки того, что обе части
    содержат одинаковые значения.

    Такое "доказательство путем упрощения" может быть использовано для
    установления более интересных свойств.  Например, тот факт, что [0] является
    "нейтральным элементом" для [+] слева, может быть доказан простым
    наблюдением, что [0 + n] сводится к [n] независимо от того, что такое [n] --
    факт, который можно вычитать непосредственно из определения [plus]. *)

Theorem plus_O_n : forall n : nat, 0 + n = n.
Proof.
  intros n. simpl. reflexivity.  Qed.

(** (Вы можете заметить, что приведенное выше утверждение отличается, если
    просматривать файл [.v] в IDE, от HTML-представления в вашем браузере. В
    файлах [.v] мы записываем квантор всеобщности [forall], используя
    зарезервированный идентификатор "forall".  Когда файлы [.v] преобразуются в
    HTML, он преобразуется в стандартный символ "перевёрнутое А".)

    Здесь уместно упомянуть, что [рефлексивность] в Coq -- это нечто более
    сильное, чем мы заявляли раньше. В примерах, которые мы видели, вызовы
    [simpl] на самом деле не требовались, потому что [reflexivity] автоматически
    выполнит некоторое упрощение при проверке равенства двух сторон; [simpl] был
    добавлен только для того, чтобы мы могли видеть промежуточное состояние
    после упрощения, но перед завершением доказательства.  Вот более короткое
    доказательство: *)

Theorem plus_O_n' : forall n : nat, 0 + n = n.
Proof.
  intros n. reflexivity. Qed.

(** Более того, будет полезно знать, что [reflexivity] делает несколько
    _большее_ упрощение, чем [simpl] - например, она пытается "развернуть"
    некоторые термины, заменив их на их определения.  Причина этого различия в
    том, что, если [reflexivity] срабатывает, конечная цель достигнута, и нам не
    нужно смотреть на то, какие раскрытые выражения создала [reflexivity]
    благодаря всем этим упрощениям и подстановкам; напротив, [simpl]
    используется в ситуациях, когда нам, возможно, придется прочитать и понять
    новую цель, которую эта команда создаёт, поэтому мы не хотели бы вслепую
    разворачивать определения и оставлять мешанину вместо цели.

    Внешний вид теоремы, которую мы только что сформулировали, и её
    доказательство почти в точности совпадают с более простыми примерами,
    которые мы видели ранее; есть всего лишь несколько отличий.

    Во-первых, мы использовали ключевое слово [Theorem] вместо [Example].
    Это различие в основном зависит от стиля; ключевые слова [Example] и
    [Theorem] (и несколько других, включая [Lemma], [Fact] и [Remark]) означают
    для Coq практически одно и то же.

    Во-вторых, мы добавили квантор [forall n:nat], так что наша теорема сообщает
    некоторый факт про _все_ натуральные числа [n].  Неформально, чтобы доказать
    теорему такого вида, мы обычно начинаем со слов "Предположим, что [n] -- это
    некоторое число..."  Формально это достигается в доказательстве с помощью
    команды [intros n], которая перемещает [n] из квантора в цели в _контекст_
    текущих предположений.

    Кстати, мы могли бы использовать другой идентификатор вместо [n] в клозе
    [intros] (хотя, конечно, это может сбить с толку людей, читающих
    доказательство): *)

Theorem plus_O_n'' : forall n : nat, 0 + n = n.
Proof.
  intros m. reflexivity. Qed.

(** Ключевые слова [intros], [simpl] и [reflexivity] являются примерами
    _тактик_.  Тактика - это команда, которая используется между [Proof] и [Qed]
    для направления процесса проверки выдвигаемых нами утверждений.  Мы
    рассмотрим еще несколько тактик в оставшейся части этого занятия и многие
    другие в следующих занятиях. *)

(** Другие подобные теоремы могут быть доказаны по той же схеме. *)

Theorem plus_1_l : forall n:nat, 1 + n = S n.
Proof.
  intros n. reflexivity.  Qed.

Theorem mult_0_l : forall n:nat, 0 * n = 0.
Proof.
  intros n. reflexivity.  Qed.

(** Суффикс [_l] в названиях этих теорем произносится как "слева". *)

(** Стоит ознакомиться с этими доказательствами в интерактивном режиме, чтобы
    увидеть, как меняются контекст и цель.  Возможно, вы захотите добавить
    вызовы [simpl] перед [reflexivity], чтобы увидеть упрощения, которые
    выполняет Coq в термах, прежде чем проверить их равенство. *)

(* ################################################################# *)
(** * Доказательства с помощью переписывания *)

(** Следующая теорема немного интереснее тех, что мы видели ранее: *)

Theorem plus_id_example : forall n m:nat,
  n = m ->
  n + n = m + m.

(** Вместо общего утверждения обо всех числах [n] и [m] в нем говорится о более
    конкретном свойстве, которое выполняется только тогда, когда [n = m].
    Символ стрелки произносится как "следует".

    Как и прежде, нам нужно уметь рассуждать, предполагая, что нам даны такие
    числа [n] и [m].  Нам также нужно принять гипотезу [n = m]. Тактика
    [intros] поможет перенести все три из них из цели в предположения в текущем
    контексте.

    Поскольку [n] и [m] являются произвольными числами, мы не можем просто
    использовать упрощение для доказательства этой теоремы.  Вместо этого мы
    сначала заметим, что если мы предполагаем, что [n = m], то мы можем заменить
    [n] на [m] в формулировке цели и получить равенство с одинаковым выражением
    с обеих сторон.  Тактика, по которой Coq выполнит такую замену, называется
    [rewrite]. *)

Proof.
  (* переместим оба квантора в контекст: *)
  intros n m.
  (* перенесём гипотезу в контекст: *)
  intros H.
  (* перепишем цель, используя гипотезу: *)
  rewrite -> H.
  reflexivity.  Qed.

(** В первой строке доказательства переменные [n] и [m] перемещаются из-под
    квантора всеобщности в контекст.  Во второй строке гипотеза [n = m]
    помещается в контекст и получает название [H]. Третья указывает Coq
    переписать текущую цель ([n + n = m + m]), заменив левую часть гипотезы о
    равенстве [H] на правую часть.

    (Символ стрелки в [rewrite] не имеет ничего общего с импликацией: он
    указывает Coq применить переписывание слева направо. На самом деле, мы можем
    опустить стрелку, и Coq по умолчанию будет переписывать слева направо.
    Чтобы переписать справа налево, используйте [rewrite <-]. Попробуйте внести
    это изменение в приведенное выше доказательство и посмотрите, что
    изменится.) *)

(** **** Упражнение: 1 звезда, стандартное (plus_id_exercise)

    Уберите "[Admitted.]" и завершите доказательство.  (Обратите внимание, что в
    теореме есть две гипотезы -- [n = m] и [m = o] -- каждая слева от стрелки
    импликации.) *)

Theorem plus_id_exercise : forall n m o : nat,
  n = m -> m = o -> n + m = m + o.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** Команда [Admitted] сообщает Coq, что мы хотим опустить доказательство этой
    теоремы и просто принять ее как данность.  Это часто полезно для разработки
    более длинных доказательств: мы можем сформулировать дополнительные леммы,
    которые, по нашему мнению, будут полезны для создания более сильных
    аргументов; используем [Admitted], чтобы принять их на веру на данный
    момент; продолжаем работать над основным доказательством, пока мы не будем
    уверены в его осмысленности; затем мы сможем вернуться и дозаполнить
    пропущенные доказательства.

    Однако будьте осторожны: каждый раз, когда ты говоришь, что доказательство
    [Принято], ты оставляешь для полной чепухи открытую настежь дверь в
    прекрасный, строгий, формально проверенный Coq-ом мир! *)

(** Команду [Check] также можно использовать для проверки утверждений ранее
    объявленных лемм и теорем.  Два примера ниже -- леммы о умножении, которые
    доказаны в стандартной библиотеке.  (Мы увидим, как доказать их самим, во
    второй части занятия.) *)

Check mult_n_O.
(* ===> forall n : nat, 0 = n * 0 *)

Check mult_n_Sm.
(* ===> forall n m : nat, n * m + n = n * S m *)

(** Мы можем использовать тактику [rewrite] не только с гипотезами из контекста,
    но и используя ранее доказанные теоремы. Если утверждение ранее доказанной
    теоремы включает переменные под кванторами, как в примере ниже, Coq
    попытается подставить вместо них соответствующие значения, сопоставив текст
    утверждения теоремы с текущей целью. *)

Theorem mult_n_0_m_0 : forall p q : nat,
  (p * 0) + (q * 0) = 0.
Proof.
  intros p q.
  rewrite <- mult_n_O.
  rewrite <- mult_n_O.
  reflexivity. Qed.

(** **** Упражнение: 1 звезда, стандартное (mult_n_1)

    Используя [mult_n_Sm] и [mult_n_0], докажите следующую теорему.
    (Напомним, [1] это [S O].) *)

Theorem mult_n_1 : forall p : nat,
  p * 1 = p.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

(** [] *)

(* ################################################################# *)
(** * Доказательство разбором случаев *)

(** Конечно, не всё можно доказать простым вычислением и переписывание: в целом,
    неизвестные, гипотетические значения (произвольные числа, логические
    значения, списки и т.д.) могут препятствовать упрощению.  Например, если мы
    попытаемся доказать следующий факт, используя [simpl], мы попадаем в тупик.
    (Затем мы используем команду [Abort], чтобы тактически отступить.) *)

Theorem plus_1_neq_0_firsttry : forall n : nat,
  (n + 1) =? 0 = false.
Proof.
  intros n.
  simpl.  (* ничего не делает! *)
Abort.

(** Причина этого в том, что определения как [eqb], так и [+] начинаются с
    сопоставления по образцу для их первого аргумента. Здесь первым аргументом
    для [+] является неизвестное число [n], а аргументом для [eqb] является
    составное выражение [n + 1]; ни то, ни другое не может быть упрощено.

    Чтобы продвинуться вперед, нам нужно рассмотреть возможные случаи
    внутреннего устройства [n] по отдельности.  Если [n] равно [O], то мы можем
    вычислить конечный результат [(n + 1) =? 0] и убедиться, что, действительно,
    он равен [false].  А если [n = S n'] для некоторого [n'], тогда -- хотя мы
    точно не знаем, что из себя представляет число [n + 1] -- мы можем
    вычислить, что, по крайней мере, оно будет начинаться с единицы [S]; и этого
    достаточно, чтобы вычислить, что, опять же, [(n + 1) =? 0] вернёт [false].

    Тактика, которая предписывает Coq рассматривать отдельно случаи, где [n = O]
    и где [n = S n'], называется [destruct]. *)

Theorem plus_1_neq_0 : forall n : nat,
  (n + 1) =? 0 = false.
Proof.
  intros n. destruct n as [| n'] eqn:E.
  - reflexivity.
  - reflexivity.   Qed.

(** [destruct] генерирует _две_ подцели, которые мы затем должны доказать по
    отдельности, чтобы заставить Coq принять доказательство.

    Аннотация "[as [| n']]" называется _образец для входа_.  Он указывает Coq,
    какие имена переменных вводить в каждую подцель.  В общем случае, в
    квадратных скобках содержится список списков имен, разделенных символом [|].
    В данном случае первый список пуст, поскольку конструктор [O] не принимает
    никаких аргументов.  Во втором списке содержится единственное имя [n'],
    поскольку [S] является унарным конструктором.

    В каждой подцели Coq запоминает предположение о [n], которое имеет отношение
    к этой подцели - либо [n = 0], либо [n = S n'] для некоторого n'.  Аннотация
    [eqn:E] указывает [destruct] присвоить этому уравнению имя [E].  (Пропуск
    аннотации [eqn:E] приведёт к тому, что Coq устранит эти предположения в
    подцелях.  Это немного упрощает доказательства, в которых допущения явно не
    используются, но лучше оставлять их из соображений документации, поскольку
    они могут помочь вам ориентироваться при работе с подцелями.)

    Знаки [-] во второй и третьей строках называются "буллетами", и они
    обозначают части доказательства, соответствующие двум сгенерированным
    подцелям.  Часть скрипта, которая следует за маркером -- это полное
    доказательство для соответствующей подцели.  В этом примере каждая из
    подцелей легко доказывается с помощью единственного вызова [reflexivity],
    которая сама по себе обеспечивает некоторое упрощение -- например, второй
    вызов упрощает [(S n' + 1) =? 0] до [false], сначала переписывая
    [(S n' + 1)] на [S (n' + 1)], затем разворачивая [eqb], и, наконец, упрощая
    [match].

    Отмечать отдельные случаи маркерами необязательно: если маркеров нет, Coq
    просто ожидает, что вы будете доказывать каждую подцель последовательно, по
    одной за раз. Но рекомендуется использовать маркеры.  Во-первых, они
    упрощают структуру доказательства, улучшая читаемость. Кроме того, маркеры
    указывают Coq, что перед проверкой следующей подцели необходимо убедиться в
    том, что подцель выполнена, что предотвращает смешение доказательств для
    разных подцелей. Эти детали становятся особенно важными в более крупных
    разработках, где хрупкие доказательства могут привести к длительному
    процессу отладки!

    В Coq не существует жестких правил оформления доказательств -- например, где
    следует прерывать строки и какие отступы должны быть у разделов
    доказательства, чтобы показать его вложенную структуру.  Однако, если места,
    где генерируется несколько подцелей, помечены четкими маркерами в начале
    строки, то доказательство будет читаемым практически независимо от того,
    какие решения будут приняты в отношении других аспектов компоновки.

    Здесь также уместно упомянуть еще один довольно очевидный совет по поводу
    длины строк.  Начинающие пользователи Coq иногда бросаются в крайности и
    либо пишут каждую тактику отдельно, либо пытаются уместить всё
    доказательство в одну строчку.  Хороший стиль находится где-то посередине.
    Например, разумной рекомендацией является ограничение в 80 (или, если у вас
    широкий экран либо хорошие глаза, 120) символов в строчке.

    Тактика [destruct] может быть использована с любым индуктивным типом данных.
    Например, мы используем его далее, чтобы доказать, что булево отрицание
    инволютивно, т.е. что отрицание обратно самому себе. *)

Theorem negb_involutive : forall b : bool,
  negb (negb b) = b.
Proof.
  intros b. destruct b eqn:E.
  - reflexivity.
  - reflexivity.  Qed.

(** Обратите внимание, что здесь в [destruct] нет клозы [as], потому что ни в
    одном из случаев [destruct] не требуется создавать какие-либо переменные,
    поэтому нет необходимости указывать какие-либо имена.  На самом деле, мы
    можем опустить клозу [as] из _любого_ вызова [destruct], и Coq заполнит
    имена переменных автоматически.  Правда, это считается дурным тоном,
    поскольку Coq чаще всего выбирает имена крайне неудачно.

    Иногда полезно вызвать [destruct] внутри подцели, создавая еще больше
    подцелей. В этом случае мы используем различные виды буллетов для
    обозначения целей на разных "уровнях". Например: *)

Theorem andb_commutative : forall b c, andb b c = andb c b.
Proof.
  intros b c. destruct b eqn:Eb.
  - destruct c eqn:Ec.
    + reflexivity.
    + reflexivity.
  - destruct c eqn:Ec.
    + reflexivity.
    + reflexivity.
Qed.

(** Каждая пара вызовов [reflexivity] соответствует подцелям, которые были
    сгенерированы после исполнения строчек с [destruct c] прямо над ними. *)

(** Кроме [-] и [+], мы можем использовать [*] (астериск, звёздочку), а также
    любой повтор буллета (например, [--] либо [***]) в качестве буллета.  Также
    мы можем заключать под-доказательства в фигурные скобки: *)

Theorem andb_commutative' : forall b c, andb b c = andb c b.
Proof.
  intros b c. destruct b eqn:Eb.
  { destruct c eqn:Ec.
    { reflexivity. }
    { reflexivity. } }
  { destruct c eqn:Ec.
    { reflexivity. }
    { reflexivity. } }
Qed.

(** Поскольку фигурные скобки обозначают как начало, так и конец доказательства,
    их можно использовать для нескольких уровней подцели, как в этом примере.
    Кроме того, фигурные скобки позволяют нам повторно использовать одни и те же
    формы маркеров на нескольких уровнях в доказательстве. Выбор скобок,
    маркеров или их комбинации -- это исключительно дело вкуса. *)

Theorem andb3_exchange :
  forall b c d, andb (andb b c) d = andb (andb b d) c.
Proof.
  intros b c d. destruct b eqn:Eb.
  - destruct c eqn:Ec.
    { destruct d eqn:Ed.
      - reflexivity.
      - reflexivity. }
    { destruct d eqn:Ed.
      - reflexivity.
      - reflexivity. }
  - destruct c eqn:Ec.
    { destruct d eqn:Ed.
      - reflexivity.
      - reflexivity. }
    { destruct d eqn:Ed.
      - reflexivity.
      - reflexivity. }
Qed.

(** **** Упражнение: 2 звезды, стандартное (andb_true_elim2)

    Докажите следующее утверждение, отмечая случаи (и под-случаи) с помощью
    буллетов, когда вы используете [destruct].

    Подсказка: В конечном итоге вам нужно будет деструктировать оба логических
    значения, как в приведенных выше теоремах. Но лучше отложить ввод гипотезы
    до тех пор, пока у вас не появится возможность упростить ее.

    Подсказка 2: Когда вы обнаружите противоречие в гипотезах, сосредоточьтесь
    на том, как [переписать] это противоречие. *)

Theorem andb_true_elim2 : forall b c : bool,
  andb b c = true -> c = true.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** Прежде чем подытожить первую половину занятия, давайте упомянем еще об одном
    удобстве.  Как вы, возможно, заметили, во многих доказательствах выполняется
    разбор случаев для переменной сразу после ее введения:

       intros x y. destruct y as [|y] eqn:E.

    Этот паттерн настолько распространен, что Coq предоставляет для него
    сокращенное описание: мы можем выполнить разбор случаев для переменной при
    её введении, используя образец для входа вместо имени переменной. Например,
    вот более краткое доказательство теоремы [plus_1_neq_0] выше.  (Также
    заметьте один недостаток этого сокращения: мы теряем предположение, которое
    мы делали в каждой из подцелей, которые мы ранее получали из аннотации
    [eqn:E].) *)

Theorem plus_1_neq_0' : forall n : nat,
  (n + 1) =? 0 = false.
Proof.
  intros [|n].
  - reflexivity.
  - reflexivity.  Qed.

(** Если нет аргументов конструктора, для которых нужны имена, мы можем просто
    написать [[]], чтобы по очереди разобрать случаи. *)

Theorem andb_commutative'' :
  forall b c, andb b c = andb c b.
Proof.
  intros [] [].
  - reflexivity.
  - reflexivity.
  - reflexivity.
  - reflexivity.
Qed.

(** **** Упражнение: 1 звезда, стандартное (zero_nbeq_plus_1) *)
Theorem zero_nbeq_plus_1 : forall n : nat,
  0 =? (n + 1) = false.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(* ================================================================= *)
(** ** Подробнее о нотации (необязательно) *)

(** (Как правило, разделы, помеченные как необязательные, не нужны для
    ознакомления с остальными материалами курса, за исключением, возможно,
    других необязательных разделов.  При первом чтении вы можете просто
    просмотреть эти разделы, чтобы знать, что там есть, и вернуться позднее.)

    Вспомним определения обозначений для инфиксных плюса и умножения: *)

Notation "x + y" := (plus x y)
                       (at level 50, left associativity)
                       : nat_scope.
Notation "x * y" := (mult x y)
                       (at level 40, left associativity)
                       : nat_scope.

(** Для каждой нотации в Coq мы можем указать её _приоритет_ и
    _ассоциативность_.  Приоритет [n] указывается записью [at level n]; это
    помогает Coq считывать составные выражения.  Ассоциативность же помогает
    устранить неоднозначность выражений, содержащий несколько повторений одного
    и того же символа. Например, параметры, указанные выше для [+] и [*],
    говорят о том, что выражение [1+2*3*4] является сокращением для
    [(1+((2*3)*4))]. Coq использует приоритеты от 0 до 100 и _левую_ ([left]),
    _правую_ ([right]) или _никакую_ ([no]) ассоциативность.  Мы увидим больше
    примеров позже, например, когда будем работать со списками.

    Каждая нотация также связана со своей _областью видимости_. Coq пытается
    угадать используемую область из контекста, поэтому, когда он видит
    [S (O*O)], он угадывает [nat_scope], но когда он видит пару [bool*bool]
    (которую мы увидим позднее), он угадывает [type_scope].  Иногда необходимо
    помочь ему, написав, например, [(x*y)%nat]; иногда и сам Coq при печати
    использует [%nat], чтобы указать, из какой области берётся та или иная
    нотация.

    Области видимости также применяются к цифровым обозначениям ([3], [4], [5],
    [42], и т.д.), поэтому иногда вы увидите [0%nat], что означает [O]
    (натуральное число [0], которое мы используем в этой главе) или [0%Z], что
    означает целое число, равное нулю (которое взято из другой части стандартной
    библиотеки).

    Pro tip: механизм нотаций в Coq не особенно мощный. Не ждите от него слишком
    многого. *)

(* ================================================================= *)
(** ** Неподвижные точки и структурная рекурсия (необязательно) *)

(** Вот копия определения сложения: *)

Fixpoint plus' (n : nat) (m : nat) : nat :=
  match n with
  | O => m
  | S n' => S (plus' n' m)
  end.

(** Когда Coq проверяет это определение, он замечает, что [plus'] "уменьшается
    в первом аргументе".  Это означает, что мы выполняем _структурную рекурсию_
    по аргументу [n], т.е. мы выполняем рекурсивные вызовы только для строго
    меньших значений [n].  Это означает, что все вызовы [plus'] в конечном итоге
    завершатся.  Coq требует, чтобы некоторый аргумент определения _каждой_
    [Неподвижной точки] был "убывающим".

    Это требование является фундаментальной особенностью дизайна Coq: в
    частности, оно гарантирует, что каждая функция, которая может быть
    определена в Coq, завершится на всех входных данных.  Однако, поскольку
    "анализ убывания" в Coq не очень сложен, иногда приходится писать функции
    несколько неестественным образом. *)

(** **** Упражнение: 2 звезды, стандартное, необязательное (decreasing)

    Чтобы ощутить это, найдите способ написать разумное определение [Fixpoint]
    (например, простой функции для чисел), которое _завершается_ на всех входных
    данных, но которое Coq отклоняет из-за своих ограничений.

    (Если вы решите включить это необязательное упражнение в домашнее задание,
    обязательно закомментируйте свое решение, чтобы Coq не отклонил весь файл
    целиком!) *)

(* ЗАПОЛНИТЕ ЗДЕСЬ

    [] *)

(* ################################################################# *)
(** * Больше упражнений *)

(* ================================================================= *)
(** ** Разминка *)

(** **** Упражнение: 1 звезда, стандартное (identity_fn_applied_twice)

    Используйте тактики, которые вы освоили на данный момент, в доказательстве
    следующей теоремы о булевых функциях. *)

Theorem identity_fn_applied_twice :
  forall (f : bool -> bool),
  (forall (x : bool), f x = x) ->
  forall (b : bool), f (f b) = b.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

(** [] *)

(** **** Упражнение: 1 звезда, стандартное (negation_fn_applied_twice)

    Теперь сформулируйте и докажите теорему [negation_fn_applied_twice],
    аналогичную предыдущей, но в которой вторая гипотеза гласит, что
    функция [f] обладает свойством, что [f x = negb x]. *)

(* ЗАПОЛНИТЕ ЗДЕСЬ *)

(* Не меняйте следующую строчку: *)
Definition manual_grade_for_negation_fn_applied_twice : option (nat*string) := None.
(** (Определение выше используется при автопроверке.)

    [] *)

(** **** Упражнение: 3 звезды, стандартное, необязательное (andb_eq_orb)

   Докажите следующую теорему.  (Подсказка: это может быть немного сложно, в
   зависимости от того, как вы подойдёте к доказательству.  Вероятно, вам
   понадобятся и [destruct] и [rewrite], но [уничтожать] все, что попадается на
   глаза -- не лучший подход.) *)

Theorem andb_eq_orb :
  forall (b c : bool),
  (andb b c = orb b c) ->
  b = c.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

(** [] *)

(* ================================================================= *)
(** ** Сдача после дедлайна: формализация *)

(** Предположим, что на некотором курсе действует политика выставления оценок,
    основанная на опозданиях, при которой итоговая оценка студента по системе
    A-B-C-D-F снижается, если он сдает слишком много домашних заданий с
    опозданием.

    В следующей серии задач мы смоделируем эту ситуацию, используя средства Coq,
    которые мы видели до сих пор, и докажем некоторые простые факты об этой
    политике выставления оценок. *)

Module LateDays.

(** Сначала мы вводим тип данных для моделирования "буквенной" части оценки. *)
Inductive letter : Type :=
  | A | B | C | D | F.

(** Затем мы определяем модификаторы: [Natural] [A] это просто "обычная" оценка
    [A]. *)
Inductive modifier : Type :=
  | Plus | Natural | Minus.

(** Тогда полная [оценка] - это просто [буква] и [модификатор].

    Неформально мы могли бы написать "A-" вместо [Grade A Minus] и, аналогично,
    "C" вместо [Grade C Natural]. *)
Inductive grade : Type :=
  Grade (l:letter) (m:modifier).

(** Мы захотим иметь возможность определить, когда одна оценка "лучше" другой.
    Другими словами, нам нужен способ сравнить две оценки.  Как и в случае с
    натуральными числами, мы могли бы определить функции, имеющие логическое
    значение [grade_eqb], [grade_ltb] и т.д., и это будет работать нормально.
    Однако мы также можем определить немного более информативный тип для
    сравнения двух значений, как показано ниже.  Этот тип данных имеет три
    конструктора, которые можно использовать для указания того, являются ли два
    значения "равными", "меньше" или "больше" друг друга. (Это определение также
    содержится в стандартной библиотеке Coq.)  *)

Inductive comparison : Type :=
  | Eq         (* равно, "equal" *)
  | Lt         (* меньше чем, "less than" *)
  | Gt.        (* больше чем, "greater than" *)

(** Используя сопоставление с образцом, нетрудно определить операцию сравнения
    для двух букв [l1] и [l2] (см. ниже). В этом определении используются две
    особенности сопоставления с образцом: во-первых, напомним, что мы можем
    сопоставлять одновременно два значения, разделяя их и соответствующие
    образцы запятой [,]. Это просто удобное сокращение для вложенного
    сопоставления.  Например, сопоставление слева ниже это просто сокращение для
    более низкоуровневой "расширенной версии", показанной справа:

  match l1, l2 with          match l1 with
  | A, A => Eq               | A => match l2 with
  | A, _ => Gt                      | A => Eq
  end                               | _ => Gt
                                    end
                             end
*)
(** В качестве другого сокращения мы также можем сопоставить сразу несколько
    образцов, используя [|] в шаблоне.  Например, образец [C , (A | B)]
    захватывает сразу два случая: [C, A] и [C, B]. *)

Definition letter_comparison (l1 l2 : letter) : comparison :=
  match l1, l2 with
  | A, A => Eq
  | A, _ => Gt
  | B, A => Lt
  | B, B => Eq
  | B, _ => Gt
  | C, (A | B) => Lt
  | C, C => Eq
  | C, _ => Gt
  | D, (A | B | C) => Lt
  | D, D => Eq
  | D, _ => Gt
  | F, (A | B | C | D) => Lt
  | F, F => Eq
  end.

(** Мы можем протестировать операцию [letter_comparison], опробовав ее на
    нескольких примерах. *)
Compute letter_comparison B A.
(** ==> Lt *)
Compute letter_comparison D D.
(** ==> Eq *)
Compute letter_comparison B F.
(** ==> Gt *)

(** В качестве дополнительной проверки на разумность мы можем доказать, что
    функция [letter_comparison] действительно выдает результат [Eq] при
    сравнении буквы [l] с самой собой. *)
(** **** Упражнение: 1 звезда, стандартное (letter_comparison) *)
Theorem letter_comparison_Eq :
  forall l, letter_comparison l l = Eq.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** Мы можем следовать той же стратегии, чтобы определить операцию сравнения
    для двух модификаторов оценки.  Мы считаем, что они должны быть упорядочены
    следующим образом: [Plus > Natural > Minus]. *)
Definition modifier_comparison (m1 m2 : modifier) : comparison :=
  match m1, m2 with
  | Plus, Plus => Eq
  | Plus, _ => Gt
  | Natural, Plus => Lt
  | Natural, Natural => Eq
  | Natural, _ => Gt
  | Minus, (Plus | Natural) => Lt
  | Minus, Minus => Eq
  end.

(** **** Упражнение: 2 звезды, стандартное (grade_comparison)

    Используйте сопоставление с образцом для завершения следующего определения.

    (Такое упорядочение оценок иногда называют "лексикографическим" порядком:
    сначала мы сравниваем буквы, а модификаторы учитываем только в том случае,
    если буквы равны.  Т.е. все варианты оценки [A] лучше, чем все варианты
    [B].)

    Подсказка: сопоставляйте [g1] и [g2] одновременно, но не пытайтесь
    перечислить все варианты.  Вместо этого проведите разбор случаев для
    результата подходящего вызова [letter_comparison], чтобы в итоге получить
    только [3] варианта. *)

Definition grade_comparison (g1 g2 : grade) : comparison
  (* ЗАМЕНИТЕ ЭТУ СТРОКУ НА ":= _ваше_определение_ ." *). Admitted.

(** Следующие "юнит-тесты" вашей функции [grade_comparison] должны пройти,
    как только вы правильно ее определите. *)

Example test_grade_comparison1 :
  (grade_comparison (Grade A Minus) (Grade B Plus)) = Gt.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Example test_grade_comparison2 :
  (grade_comparison (Grade A Minus) (Grade A Plus)) = Lt.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Example test_grade_comparison3 :
  (grade_comparison (Grade F Plus) (Grade F Plus)) = Eq.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Example test_grade_comparison4 :
  (grade_comparison (Grade B Minus) (Grade C Plus)) = Gt.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

(** [] *)

(** Теперь, когда у нас есть определение оценок и то, как они соотносятся
    друг с другом, давайте реализуем функцию штрафа за опоздание. *)

(** Сначала мы определяем, что значит понизить [буквенный] компонент оценки.
    Поскольку [F] уже является самой низкой из возможных оценок, мы просто
    оставляем её без изменений. *)
Definition lower_letter (l : letter) : letter :=
  match l with
  | A => B
  | B => C
  | C => D
  | D => F
  | F => F  (* Нельзя получить меньше [F]! *)
  end.

(** Наша формализация уже может помочь нам понять некоторые важные крайние
    случаи в нашей политике выставления оценок.  Например, мы могли бы ожидать,
    что если мы используем функцию [lower_letter], то ее результат действительно
    будет ниже, как утверждается в следующей теореме.  Но эта теорема
    недоказуема!  (Вы понимаете почему?) *)
Theorem lower_letter_lowers: forall (l : letter),
  letter_comparison (lower_letter l) l = Lt.
Proof.
  intros l.
  destruct l.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. (* Здесь-то мы и застряли. *)
Abort.

(** Проблема, конечно же, связана с "крайним случаем" понижения
    [F], в чём мы можем убедиться следующим образом: *)
Theorem lower_letter_F_is_F:
  lower_letter F = F.
Proof.
  simpl. reflexivity.
Qed.

(** Вооружившись новым знанием, мы можем сформулировать улучшенную версию
    теоремы, которая уже будет доказуема.  В этой версии гипотеза о [F] гласит,
    что [F] строго меньше, чем [l], что исключает проблемный случай, описанный
    выше. Другими словами, до тех пор, пока [l] больше, чем [F], оно будет
    уменьшаться. *)
(** **** Упражнение: 2 звезды, стандартное (lower_letter_lowers)

    Докажите следующую теорему. *)

Theorem lower_letter_lowers:
  forall (l : letter),
    letter_comparison F l = Lt ->
    letter_comparison (lower_letter l) l = Lt.
Proof.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

(** [] *)

(** **** Упражнение: 2 звезды, стандартное (lower_grade)

    Теперь мы можем использовать определение [lower_letter] в качестве
    вспомогательного средства для определения того, что значит понизить оценку
    на одну ступень.  Заполните приведенное ниже определение так, чтобы оно
    понизило оценку [g] на одну ступень (если только это уже не [оценка F с
    минусом], которая должна остаться неизменной).  Как только вы правильно ее
    реализуете, последующие "юнит-тесты" должны выполняться без ошибок.

    Подсказка: Чтобы это определение было кратким, чтобы его свойства было легко
    доказывать, вы, вероятно, захотите использовать вложенное сопоставление с
    образцом. Внешний [match] не должен производить сопоставление с буквенной
    частью оценки -- он должен учитывать только модификатор. _Не стоит_ пытаться
    перечислить все случаи.

    Наше решение содержит менее 10 строк кода. *)
Definition lower_grade (g : grade) : grade
  (* ЗАМЕНИТЕ ЭТУ СТРОКУ НА ":= _ваше_определение_ ." *). Admitted.

Example lower_grade_A_Plus :
  lower_grade (Grade A Plus) = (Grade A Natural).
Proof.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Example lower_grade_A_Natural :
  lower_grade (Grade A Natural) = (Grade A Minus).
Proof.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Example lower_grade_A_Minus :
  lower_grade (Grade A Minus) = (Grade B Plus).
Proof.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Example lower_grade_B_Plus :
  lower_grade (Grade B Plus) = (Grade B Natural).
Proof.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Example lower_grade_F_Natural :
  lower_grade (Grade F Natural) = (Grade F Minus).
Proof.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Example lower_grade_twice :
  lower_grade (lower_grade (Grade B Minus)) = (Grade C Natural).
Proof.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Example lower_grade_thrice :
  lower_grade (lower_grade (lower_grade (Grade B Minus))) = (Grade C Minus).
Proof.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

(** Coq не различает [Примеры] и [Теоремы]. Мы формулируем нижеследующее как
    [Теорему] только в качестве намека на то, что мы будем использовать это
    утверждение в доказательствах ниже. *)
Theorem lower_grade_F_Minus : lower_grade (Grade F Minus) = (Grade F Minus).
Proof.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

(* GRADE_THEOREM 0.25: lower_grade_A_Plus *)
(* GRADE_THEOREM 0.25: lower_grade_A_Natural *)
(* GRADE_THEOREM 0.25: lower_grade_A_Minus *)
(* GRADE_THEOREM 0.25: lower_grade_B_Plus *)
(* GRADE_THEOREM 0.25: lower_grade_F_Natural *)
(* GRADE_THEOREM 0.25: lower_grade_twice *)
(* GRADE_THEOREM 0.25: lower_grade_thrice *)
(* GRADE_THEOREM 0.25: lower_grade_F_Minus

    [] *)

(** **** Упражнение: 3 звезды, стандартное (lower_grade_lowers)

    Докажите следующую теорему, которая гласит, что до тех пор, пока оценка
    начинается выше F-, [lower_grade] действительно понижает оценку.  Как
    обычно, разрушать все, что попадается на глаза -- _плохая_ идея.
    Разумное использование [destruct] вместе с переписыванием -- это уже
    стратегия получше.

    Подсказка: Если вы определили свою функцию [grade_comparison] так, как было
    предложено, вам нужно будет использовать [rewrite], используя
    [letter_comparison_Eq], в двух случаях.  Последний случай -- единственный,
    в котором вам нужно деструктировать [букву].  В случае для [F], вероятно,
    пригодится [lower_grade_F_Minus].  *)
Theorem lower_grade_lowers :
  forall (g : grade),
    grade_comparison (Grade F Minus) g = Lt ->
    grade_comparison (lower_grade g) g = Lt.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

(** [] *)

(** Теперь, когда мы реализовали и протестировали функцию, которая снижает
    оценку на одну ступень, мы можем внедрить специальную политику в отношении
    работ, сданных после дедлайна. При заданном количестве дней опоздания
    ([late_days]) функция [apply_late_policy] вычисляет итоговую оценку на
    основе [g], начальной оценки.

    Эта функция кодирует следующую политику:

    # дней опоздания  штраф
         0 - 8        штрафов нет
         9 - 16       понизить оценку на одну ступень (A+ => A, A => A-, A- => B+ и т.д.)
        17 - 20       понизить оценку на две ступени
          >= 21       понизить оценку на три ступени (на целую букву)

      # late days     penalty
         0 - 8        no penalty
         9 - 16       lower grade by one step (A+ => A, A => A-, A- => B+, etc.)
        17 - 20       lower grade by two steps
          >= 21       lower grade by three steps (a whole letter)
*)
Definition apply_late_policy (late_days : nat) (g : grade) : grade :=
  if late_days <? 9 then g
  else if late_days <? 17 then lower_grade g
  else if late_days <? 21 then lower_grade (lower_grade g)
  else lower_grade (lower_grade (lower_grade g)).

(** Иногда полезно уметь "разворачивать" определение, чтобы иметь возможность
    продвинуться в доказательстве.  Вскоре мы увидим, как сделать это гораздо
    более простым способом автоматически, но пока легко доказать, что
    использование любого определения вроде [apply_late_policy] равно его правой
    части, просто используя рефлексивность.

    Этот результат полезен, поскольку позволяет нам использовать [rewrite] для
    раскрытия внутренней части определения. *)
Theorem apply_late_policy_unfold :
  forall (late_days : nat) (g : grade),
    (apply_late_policy late_days g)
    =
    (if late_days <? 9 then g  else
       if late_days <? 17 then lower_grade g
       else if late_days <? 21 then lower_grade (lower_grade g)
            else lower_grade (lower_grade (lower_grade g))).
Proof.
  intros. reflexivity.
Qed.

(** Теперь давайте докажем некоторые свойства этой политики. *)

(** Следующая теорема гласит, что если ученик набирает не более восьми дней
    опоздания, его оценка за семестр не меняется. Это легко доказать: как только
    Вы используете [apply_late_policy_unfold], можно переписать оставшуюся цель,
    используя гипотезу. *)

(** **** Упражнение: 2 звезды, стандартное (no_penalty_for_mostly_on_time) *)
Theorem no_penalty_for_mostly_on_time :
  forall (late_days : nat) (g : grade),
    (late_days <? 9 = true) ->
    apply_late_policy late_days g = g.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

(** [] *)

(** Следующая теорема гласит, что если ученик накапливает от 9 до 16 дней
    опозданий, его итоговая оценка снижается на одну ступень. *)

(** **** Упражнение: 2 звезды, стандартное (graded_lowered_once) *)
Theorem grade_lowered_once :
  forall (late_days : nat) (g : grade),
    (late_days <? 9 = false) ->
    (late_days <? 17 = true) ->
    (apply_late_policy late_days g) = (lower_grade g).
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

(** [] *)
End LateDays.

(* ================================================================= *)
(** ** Двоичные нумералы *)

(** **** Упражнение: 3 звезды, стандартное (binary)

    Мы можем обобщить наше унарное представление натуральных чисел до
    более эффективного двоичного представления, рассматривая двоичное число как
    последовательность конструкторов [B0] и [B1] (представляющих 0s и 1s),
    заканчивающихся [Z]. Для сравнения, в унарном представлении число -- это
    последовательность конструкторов [S], заканчивающаяся символом [O].

    Например:

       десятичная              двоичная                        унарная
           0                       Z                              O
           1                    B1 Z                            S O
           2                B0 (B1 Z)                        S (S O)
           3                B1 (B1 Z)                     S (S (S O))
           4            B0 (B0 (B1 Z))                 S (S (S (S O)))
           5            B1 (B0 (B1 Z))              S (S (S (S (S O))))
           6            B0 (B1 (B1 Z))           S (S (S (S (S (S O)))))
           7            B1 (B1 (B1 Z))        S (S (S (S (S (S (S O))))))
           8        B0 (B0 (B0 (B1 Z)))    S (S (S (S (S (S (S (S O)))))))

    Обратите внимание, что младший бит расположен слева, а старший справа, в
    отличие от обычного способа записи двоичных чисел.  Такой выбор упрощает
    работу с ними.

    (Вопрос на понимание: какой унарный нумерал соответствует [B0 Z]?) *)

Inductive bin : Type :=
  | Z
  | B0 (n : bin)
  | B1 (n : bin).

(** Завершите приведенные ниже определения функции инкремента [inc]
    для двоичных чисел и функции [bin_to_nat] для преобразования
    двоичных чисел в унарные. *)

Fixpoint incr (m:bin) : bin
  (* ЗАМЕНИТЕ ЭТУ СТРОКУ НА ":= _ваше_определение_ ." *). Admitted.

Fixpoint bin_to_nat (m:bin) : nat
  (* ЗАМЕНИТЕ ЭТУ СТРОКУ НА ":= _ваше_определение_ ." *). Admitted.

(** Следующие "юнит-тесты" ваших функций инкремента и преобразования двоичного
    кода в унарный должны выполняться успешно после того, как вы правильно
    определили эти функции. Конечно, модульные тесты не в полной мере
    демонстрируют корректность ваших функций!  Мы вернемся к этой мысли в конце
    занятия. *)

Example test_bin_incr1 : (incr (B1 Z)) = B0 (B1 Z).
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Example test_bin_incr2 : (incr (B0 (B1 Z))) = B1 (B1 Z).
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Example test_bin_incr3 : (incr (B1 (B1 Z))) = B0 (B0 (B1 Z)).
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Example test_bin_incr4 : bin_to_nat (B0 (B1 Z)) = 2.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Example test_bin_incr5 :
        bin_to_nat (incr (B1 Z)) = 1 + bin_to_nat (B1 Z).
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Example test_bin_incr6 :
        bin_to_nat (incr (incr (B1 Z))) = 2 + bin_to_nat (B1 Z).
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

(** [] *)

(* ################################################################# *)
(** * Необязательно: Тестирование Ваших решений *)

(** К каждому занятию прилагается тестовый файл, содержащий скрипты, которые
    проверяют, выполнили ли вы необходимые упражнения. Они же запускаются в CI
    для автоматической оценки Ваших решений. Вы также можете использовать эти
    тестовые файлы, если хотите убедиться, что вы ничего не пропустили.

    Важно: Этот шаг является необязательным: если вы выполнили все
    необязательные упражнения и Coq принял ваши ответы, это уже это показывает,
    что вы находитесь в отличной форме.

    Тестовый файл для этого занятия называется [Lecture1Test.v]. Чтобы запустить
    его, убедитесь, что вы сохранили [Lecture1.v] на диск.  Сперва запустите
    [coqc -Q . Lecture1.v] , а затем [coqc -Q . Lecture1Test.v]; или, если у вас
    установлен make, вы можете запустить [make Lecture1Test.vo]. (Убедитесь, что
    вы делаете это в каталоге, который также содержит файл с именем
    [_CoqProject], содержащий одну строку [-Q . LF].)

    Если Вы случайно удалили упражнение или изменили его название, то
    [make Lecture1Test.vo] завершится ошибкой, в которой будет указано название
    отсутствующего упражнения.  В противном случае вы получите много полезной
    информации:

    - Сначала будут представлены все результаты, полученные самим [Lecture1.v].
      В конце вы увидите [COQC Lecture1Test.v].

    - Во-вторых, для каждого обязательного упражнения будет выведен отчет, в
      котором сообщается его сложность (количество звезд или какая-то дробь,
      если упражнение состоит из нескольких частей), правильный ли у него тип и
      на какие предположения он опирается.

      Если _тип_ не [ok], это означает, что вы доказали неправильную вещь:
      скорее всего, вы случайно изменили утверждение теоремы во время
      доказательства.  В этом случае автогрейдер не начислит вам никаких баллов,
      поэтому обязательно исправьте теорему.

      _Предположения_ -- это любые недоказанные теоремы, на которые ваше решение
      полагается.  "Closed under the global context" -- это причудливый способ
      сказать "нет": вы решили упражнение. (Ура!)  С другой стороны, список
      аксиом означает, что вы еще не решили их полностью упражнение. (Но
      смотрите ниже раздел "Допустимые аксиомы".) Если само название упражнения
      есть в списке, это означает, что вы его не выполнили; вероятно, вы его
      приняли на веру ([Admitted]).

    - В-третьих, вы увидите максимальное количество баллов в стандартной и
      расширенной версиях задания.  Это число основано на количестве звёзд в
      обязательных упражнениях.  (В данном файле нет продвинутых упражнений.)

    - В-четвертых, вы увидите список "Разрешённых аксиом".  Это недоказанные
      теоремы, от которых может зависеть ваше решение, помимо фундаментальных
      аксиом логики Coq-а.  Возможно, вы увидите что-то о [функциональной
      экстенсиональности] для этого занятия; мы вскоре рассмотрим, что это
      значит.

    - Наконец, вы увидите сводную информацию о том, решили ли вы каждое из
      упражнений.  Обратите внимание, что краткое изложение не включает
      критическую информацию о том, подходит ли данный тип (то есть, не изменили
      ли вы формулировку теоремы): вы должны посмотреть эту информацию выше.

    Упражнения, которые оцениваются вручную, также будут отображаться в выводе.
    Но поскольку они должны оцениваться человеком, скрипт не сможет ничего о них
    рассказать. *)

(** * Индукция: доказательства по индукции *)

(* ################################################################# *)
(** * Доказательство по индукции *)

(** Мы можем доказать, что [0] является нейтральным элементом для [+] _слева_,
    используя только [рефлексивность].  Но доказательство того, что это также
    нейтральный элемент _справа_ ... *)

Theorem add_0_r_firsttry : forall n:nat,
  n + 0 = n.

(** ... невозможно сделать таким же простым способом.  Простое применение
  [рефлексивности] не работает, поскольку [n] в [n + 0] является произвольным
  неизвестным числом, поэтому [match] в определении [+] не может быть упрощён.
*)

Proof.
  intros n.
  simpl. (* Ничего не делает! *)
Abort.

(** Разбор случаев с помощью [destruct n] тоже не позволяет особо продвинуться:
    тот случай, где мы предполагаем, что [n = 0], проходит нормально, но в
    случае, когда [n = S n'] для некоторого [n'], мы точно так же застреваем. *)

Theorem add_0_r_secondtry : forall n:nat,
  n + 0 = n.
Proof.
  intros n. destruct n as [| n'] eqn:E.
  - (* n = 0 *)
    reflexivity. (* пока хорошо... *)
  - (* n = S n' *)
    simpl.       (* ...а тут мы опять застряли *)
Abort.

(** Мы могли бы использовать [destruct n'], чтобы продвинуться еще на один шаг,
    но, поскольку [n] может быть сколь угодно большим, мы никогда не получим то,
    что нам нужно, если будем продолжать в том же духе. *)

(** Чтобы доказывать интересные факты о числах, списках и других индуктивно
    определяемых множествах, нам часто требуется более мощная техника
    доказательств: _по индукции_.

    Вспомним (вероятно, из курса дискретной математики) _принцип математической
    индукции_: если [P(n)] -- некоторое утверждение о натуральном числе [n], и
    мы хотим показать, что [P] выполнено для всех чисел [n], мы можем рассуждать
    следующим образом:
         - показать, что [P(O)] выполнено;
         - показать, что для любого [n'], если выполняется [P(n')], то
           выполняется и [P(S n')];
         - заключить, что [P(n)] выполняется для всех [n].

    В Coq шаги те же: мы начинаем с цели доказать [P(n)] для всех [n] и
    разбиваем эту задачу (с помощью тактики [induction]) на две отдельные
    подцели: в одной мы должны показать [P(O)], а в другой --
    [P(n') -> P(S n')].  Вот как это работает для данной теоремы: *)

Theorem add_0_r : forall n:nat, n + 0 = n.
Proof.
  intros n. induction n as [| n' IHn'].
  - (* n = 0 *)    reflexivity.
  - (* n = S n' *) simpl. rewrite -> IHn'. reflexivity.  Qed.

(** Как и [destruct], тактика [induction] получает клозу [as...], в которой
    указываются имена переменных, которые будут введены в подцелях.  Поскольку
    подцелей две, предложение [as...] состоит из двух частей, разделенных
    символом [|].  (Строго говоря, мы можем опустить предложение [as...] и Coq
    выберет имена для нас.  На практике это плохая идея, так как автоматический
    выбор Coq, как правило, приводит к путанице.)

    В первой подцели [n] заменяется на [0].  Новые переменные
    не вводятся (поэтому первая часть [as...] пуста), и цель становится
    [0 = 0 + 0], что легко доказать через упрощение.

    Во второй подцели [n] заменяется на [S n'], а предположение [n' + 0 = n']
    добавляется в контекст с именем [IHn'] (т.е. гипотеза индукции для [n']).
    Эти два имени указаны во второй части предложения [as...].  Целью в этом
    случае становится [S n' = (S n') + 0], что упрощается до
    [S n' = S (n' + 0)], что, в свою очередь, следует из [IHn']. *)

Theorem minus_n_n : forall n,
  minus n n = 0.
Proof.
  (* РАЗБИРАЕМ НА ЗАНЯТИИ *)
  intros n. induction n as [| n' IHn'].
  - (* n = 0 *)
    simpl. reflexivity.
  - (* n = S n' *)
    simpl. rewrite -> IHn'. reflexivity.  Qed.

(** (Использование тактики [intros] в этих доказательствах на самом деле
    излишне.  При применении к цели, содержащей переменные под квантором
    всеобщности, тактика [induction] автоматически перенесет их в контекст по
    мере необходимости.) *)

(** **** Упражнение: 2 звезды, стандартное, особенно полезное (basic_induction)

    Докажите с помощью индукции. Возможно, вам понадобятся ранее полученные
    результаты. *)

Theorem mul_0_r : forall n:nat,
  n * 0 = 0.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Theorem plus_n_Sm : forall n m : nat,
  S (n + m) = n + (S m).
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Theorem add_comm : forall n m : nat,
  n + m = m + n.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Theorem add_assoc : forall n m p : nat,
  n + (m + p) = (n + m) + p.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** **** Упражнение: 2 звезды, стандартное (double_plus)

    Рассмотрим следующую функцию, которая удваивает свой аргумент: *)

Fixpoint double (n:nat) :=
  match n with
  | O => O
  | S n' => S (S (double n'))
  end.

(** Используйте индукцию, чтобы доказать следующий простой факт о [double]: *)

Lemma double_plus : forall n, double n = n + n .
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** **** Упражнение: 2 звезды, стандартное (eqb_refl)

    Следующая теорема связывает вычислительное равенство [=?] в
    [nat] с равенством по определению [=] в [bool]. *)
Theorem eqb_refl : forall n : nat,
  (n =? n) = true.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** **** Упражнение: 2 звезды, стандартное, optional (even_S)

    Одним из неудобных аспектов нашего определения [even n] является рекурсивный
    вызов [n - 2]. Это затрудняет доказательство свойств [even] при выполнении
    индукции по [n], поскольку нам может понадобиться индукционная гипотеза о
    [n - 2]. Следующая лемма дает альтернативную характеристику [even (S n)],
    которая лучше работает с индукцией: *)

Theorem even_S : forall n : nat,
  even (S n) = negb (even n).
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(* ################################################################# *)
(** * Доказательства внутри доказательств *)

(** В Coq, как и в неформальной математике, большие доказательства часто
    разбивают на последовательность теорем, причем более поздние доказательства
    ссылаются на более ранние теоремы.  Но иногда доказательство будет включать
    в себя некоторые другие факты, которые слишком тривиальны и не представляют
    интереса, чтобы утруждать себя присвоением ему собственного имени на верхнем
    уровне.  В таких случаях удобно иметь возможность просто сформулировать и
    доказать необходимую "под-теорему" прямо в том месте, где она используется.
    Тактика [assert] позволяет нам это делать. *)

Theorem mult_0_plus' : forall n m : nat,
  (n + 0 + 0) * m = n * m.
Proof.
  intros n m.
  assert (H: n + 0 + 0 = n).
    { rewrite add_comm. simpl. rewrite add_comm. reflexivity. }
  rewrite -> H.
  reflexivity.  Qed.

(** Тактика [assert] создаёт две подцели.  Первая -- это утверждение леммы;
    добавляя к нему префикс [H:], мы называем утверждение [H].  (Мы также можем
    назвать утверждение с помощью [as] точно так же, как мы делали это выше с
    помощью [destruct] и [induction], т.е. [assert (n + 0 + 0 = n) as H].)
    Обратите внимание, что мы заключаем доказательство этого утверждения в
    фигурные скобки [{ ... }], как для удобства чтения, так и для того, чтобы
    при интерактивном использовании Coq нам было легче увидеть, когда мы
    закончим это дополнительное доказательство.  Вторая цель -- точно такая же,
    как и до вызова [assert], за исключением того, что в контексте теперь у нас
    есть предположение [H], что [n + 0 + 0 = n]. То есть, [assert] порождает
    одну подцель, где мы должны доказать утверждаемый факт, и вторую подцель,
    где мы можем использовать утверждаемый факт, чтобы добиться прогресса в том,
    что мы пытались доказать с самого начала. *)

(** В качестве другого примера предположим, что мы хотим доказать, что [(n + m)
    + (p + q) = (m + n) + (p + q)]. Единственное различие между двумя сторонами
    [=] заключается в том, что аргументы [m] и [n] для первого внутреннего [+]
    меняются местами, поэтому, похоже, мы должны иметь возможность использовать
    коммутативность сложения ([add_comm]), чтобы переписать одно в другое.
    Однако тактика [rewrite] не слишком умна в отношении того, _где_ она
    применяет переписывание.  Здесь есть три варианта использования [+],
    и оказывается, что [rewrite -> add_comm] повлияет только на
    _внешний_ плюс... *)

Theorem plus_rearrange_firsttry : forall n m p q : nat,
  (n + m) + (p + q) = (m + n) + (p + q).
Proof.
  intros n m p q.
  (* Нам просто нужно заменить (n + m) на (m + n)... выглядит так, как будто
     add_comm должен помочь! *)
  rewrite add_comm.
  (* Не работает... Coq переписывает не тот плюс! :-( *)
Abort.

(** Чтобы использовать [add_comm] там, где нам это нужно, мы можем ввести
    локальную лемму, утверждающую, что [n + m = m + n] (для _конкретных_ [m] и
    [n], о котором мы здесь говорим), доказать эту лемму, используя [add_comm],
    а затем использовать ее для выполнения желаемого переписывания. *)

Theorem plus_rearrange : forall n m p q : nat,
  (n + m) + (p + q) = (m + n) + (p + q).
Proof.
  intros n m p q.
  assert (H: n + m = m + n).
  { rewrite add_comm. reflexivity. }
  rewrite H. reflexivity.  Qed.

(* ################################################################# *)
(** * Формальные и неформальные доказательства *)

(** "_Неформальные доказательства -- это алгоритмы;
    формальные доказательства -- это код_." *)

(** Что представляет собой успешное доказательство математического утверждения?
    Этот вопрос волновал философов на протяжении тысячелетий, но приблизительное
    определение может быть таким: Доказательство математического утверждения [P]
    -- это письменный (или устный) текст, который вселяет в читателя или
    слушателя уверенность в том, что [P] истинно -- неопровержимый аргумент в
    пользу истинности [P].  То есть, доказательство -- это акт коммуникации.

    В актах коммуникации могут участвовать разные типы читателей.  С одной
    стороны, "читателем" может быть программа, подобная Coq, и в этом случае
    "вера", которая прививается, заключается в том, что [P] может быть
    механически выведена из определенного набора формальных логических правил, а
    доказательство -- это рецепт, которым руководствуется программа при проверке
    этого факта.  Такие _рецепты_ -- это формальные доказательства.

    В качестве альтернативы, читателем может быть человек, и в этом случае
    доказательство будет написано на русском или каком-либо другом естественном
    языке и, следовательно, обязательно будет _неформальным_.  Здесь критерии
    успеха указаны менее четко.  "Достоверное" доказательство -- это такое,
    которое заставляет читателя поверить в [P].  Но одно и то же доказательство
    может быть прочитано множеством разных читателей, некоторых из которых может
    убедить определенный способ формулировки аргумента, в то время как другие
    могут и не поверить. Некоторые читатели могут быть особенно педантичными,
    неопытными или просто толстокожими; единственный способ убедить их -- это
    привести аргументацию в мельчайших деталях.  Но другие читатели, более
    знакомые с этой областью, могут счесть все эти подробности настолько
    ошеломляющими, что они теряют общую нить; все, чего они хотят, -- это чтобы
    им рассказали об основных идеях, поскольку им легче самим разобраться в
    деталях, чем продираться через их изложение их в письменном виде. В конечном
    счете, универсального стандарта не существует, потому что не существует 
    единого способа написания неформального доказательства, которое
    гарантированно убедило бы каждого мыслимого читателя.

    Однако на практике математики разработали богатый набор условных обозначений
    и идиом для написания статей о сложных математических объектах, которые --
    по крайней мере, в рамках определенного сообщества -- делают коммуникацию
    довольно надежной.  Условности этой стилизованной формы общения задают
    достаточно четкий стандарт для рассуждений о качестве доказательств.

    Поскольку в этом курсе мы используем Coq, мы будем работать в значительной
    степени с формальными доказательствами.  Но это не значит, что мы можем
    полностью забыть о неформальных доказательствах!  Формальные доказательства
    полезны во многих отношениях, но это _не очень_ эффективный способ передачи
    идей между людьми. *)

(** Например, вот доказательство того, что сложение является ассоциативным: *)

Theorem add_assoc' : forall n m p : nat,
  n + (m + p) = (n + m) + p.
Proof. intros n m p. induction n as [| n' IHn']. reflexivity.
  simpl. rewrite IHn'. reflexivity.  Qed.

(** Coq это вполне устраивает.  Однако человеку в этом сложно разобраться.  Мы
    можем использовать комментарии и маркеры, чтобы показать структуру более
    четко... *)

Theorem add_assoc'' : forall n m p : nat,
  n + (m + p) = (n + m) + p.
Proof.
  intros n m p. induction n as [| n' IHn'].
  - (* n = 0 *)
    reflexivity.
  - (* n = S n' *)
    simpl. rewrite IHn'. reflexivity.   Qed.

(** ... и если вы привыкли к Coq, то, возможно, сможете прокрутить в уме одну
    тактику за другой и представить состояние контекста и стека целей в каждой
    точке, но если бы доказательство было хотя бы немного сложнее, это было бы
    практически невозможно.

    (Педантичный) математик написал бы доказательство как-то так: *)

(** - _Теорема_: Для любых [n], [m] и [p],

      n + (m + p) = (n + m) + p.

    _Доказательство_: Индукцией по [n].

    - Во-первых, пусть [n = 0].  Мы должны показать, что

        0 + (m + p) = (0 + m) + p.

      Это напрямую следует из определения [+].

    - Далее, пусть [n = S n'], где

        n' + (m + p) = (n' + m) + p.

      Нам теперь нужно показать, что

        (S n') + (m + p) = ((S n') + m) + p.

      По определению [+], это следует из

        S (n' + (m + p)) = S ((n' + m) + p),

      что непосредственно следует из индукционной гипотезы.  _ЧТД_. *)

(** Общая форма доказательства в основном схожа, и, конечно, это не случайно:
    Coq был разработан таким образом, что тактика [induction] генерирует те же
    подцели, в том же порядке, что и основные пункты, которые написал бы
    математик.  Но существуют существенные различия в деталях: формальное
    доказательство в некоторых отношениях гораздо более явно (например,
    при использовании [рефлексивности]), но гораздо менее явно в других (в
    частности, "состояние доказательства" в любой заданной точке доказательства
    Coq полностью неявно, в то время как неофициальное доказательство несколько
    раз напоминает читателю, как обстоят дела). *)

(** **** Упражнение: 2 звезды, продвинутое, особенно полезное (add_comm_informal)

    Переведите Ваше решение [add_comm] в неформальное доказательство:

    Теорема: Сложение коммутативно.

    Доказательство: (* ЗАПОЛНИТЕ ЗДЕСЬ *)
*)

(* Не меняйте следующую строчку: *)
Definition manual_grade_for_add_comm_informal : option (nat*string) := None.
(** [] *)

(** **** Упражнение: 2 звезды, стандартное, необязательное (eqb_refl_informal)

    Напишите неформальное доказательство следующей теоремы, используя
    неформальное доказательство [add_assoc] в качестве примера.  Просто
    перефразировать тактики Coq на русский недостаточно!

    Теорема: [(n =? n) = true] для любого [n].

    Доказательство: (* ЗАПОЛНИТЕ ЗДЕСЬ *)
*)

(* Не меняйте следующую строчку: *)
Definition manual_grade_for_eqb_refl_informal : option (nat*string) := None.
(** [] *)

(* ################################################################# *)
(** * Больше упражнений *)

(** **** Упражнение: 3 звезды, стандартное, особенно полезное (mul_comm)

    Используйте [assert] в ходе доказательства [add_shuffle3].
    Индукция здесь не нужна. *)

Theorem add_shuffle3 : forall n m p : nat,
  n + (m + p) = m + (n + p).
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

(** Теперь докажите коммутативность умножения.  Вы, вероятно, захотите найти
    (или определить и доказать) "вспомогательную" теорему, которая будет
    использоваться при доказательстве основной теоремы.
    Подсказка: что такое [n * (1 + k)]? *)

Theorem mul_comm : forall m n : nat,
  m * n = n * m.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** **** Упражнение: 2 звезды, стандартное, необязательное (plus_leb_compat_l)

    Если гипотеза имеет вид [H: P -> a = b], то [rewrite H] перепишет [a] в цели
    на [b] и добавит [P] в качестве новой подцели. Используйте это в шаге
    индукции в этом упражнении. *)

Check leb.

Theorem plus_leb_compat_l : forall n m p : nat,
  n <=? m = true -> (p + n) <=? (p + m) = true.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

(** [] *)

(** **** Упражнение: 3 звезды, стандартное, необязательное (more_exercises)

    Возьмите лист бумаги.  Для каждой из следующих теорем сначала _подумайте_ о
    том, можно ли (а) доказать ее, используя только упрощение и переписывание,
    (б) для этого также требуется разбор случаев ([destruct]), или (c)
    доказательство требует индукции.  Запишите свой прогноз.  Затем завершите
    доказательства.  (Нет необходимости сдавать свой лист бумаги; это просто для
    того, чтобы вы подумали, прежде чем начать писать код!) *)

Theorem leb_refl : forall n:nat,
  (n <=? n) = true.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Theorem zero_neqb_S : forall n:nat,
  0 =? (S n) = false.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Theorem andb_false_r : forall b : bool,
  andb b false = false.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Theorem S_neqb_0 : forall n:nat,
  (S n) =? 0 = false.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Theorem mult_1_l : forall n:nat, 1 * n = n.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Theorem all3_spec : forall b c : bool,
  orb
    (andb b c)
    (orb (negb b)
         (negb c))
  = true.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Theorem mult_plus_distr_r : forall n m p : nat,
  (n + m) * p = (n * p) + (m * p).
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Theorem mult_assoc : forall n m p : nat,
  n * (m * p) = (n * m) * p.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** **** Упражнение: 2 звезды, стандартное, необязательное (add_shuffle3')

   Тактика [replace] позволяет указать конкретное подвыражение, которое нужно
   переписать, и на что вы хотите его переписать: [replace (t) with (u)]
   заменяет (все копии) выражения [t] в цели на выражение [u] и генерирует
   [t = u] в качестве дополнительной подцели. Это часто полезно, когда простое
   [переписывание] действует не на ту часть цели.

   Используйте тактику [replace], чтобы выполнить доказательство
   [add_shuffle 3'], точно так же, как [add_shuffle 3], но без [assert]. *)

Theorem add_shuffle3' : forall n m p : nat,
  n + (m + p) = m + (n + p).
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(* ################################################################# *)
(** * Из Nat в Bin и обратно *)

(** Вспомним определение [bin]: *)

Print bin.

(** В первой части занятия мы провели небольшое юнит-тестирование [bin_to_nat],
    но не смогли доказать его корректность. Сейчас мы сделаем это. *)

(** **** Упражнение: 3 звезды, стандартное, особенно полезное (binary_commute)

    Докажите, что следующая диаграмма коммутирует:

                            incr
              bin ----------------------> bin
               |                           |
    bin_to_nat |                           |  bin_to_nat
               |                           |
               v                           v
              nat ----------------------> nat
                             S

    То есть, увеличение двоичного числа и последующее преобразование его в
    (унарное) натуральное число дает тот же результат, как при преобразовании в
    натуральное число и последующем увеличении.

    Если вы хотите изменить свои предыдущие определения [inc] или [bin_to_nat],
    чтобы упростить доказательство этого свойства, не стесняйтесь сделать это!
*)

Theorem bin_to_nat_pres_incr : forall b : bin,
  bin_to_nat (incr b) = 1 + bin_to_nat b.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

(** [] *)

(** **** Упражнение: 3 звезды, стандартное (nat_bin_nat) *)

(** Напишите функцию для конвертации их унарной записи в бинарную. *)

Fixpoint nat_to_bin (n:nat) : bin
  (* ЗАМЕНИТЕ ЭТУ СТРОКУ НА ":= _ваше_определение_ ." *). Admitted.

(** Докажите, что, если мы начнем с любого [nat], преобразуем его в [bin] и
    преобразуем обратно, мы получим тот же [nat], с которого мы начали.

    Подсказка: Это доказательство должно пройти гладко, используя предыдущее
    упражнение о [incr] в качестве леммы. Если нет, пересмотрите свои
    определения о задействованных функциях и подумайте, являются ли они более
    сложными, чем необходимо: общий вид доказательства с помощью индукции будет
    соответствовать рекурсивной структуре проверяемой программы, поэтому
    постарайтесь сделать рекурсии как можно более простыми. *)

Theorem nat_bin_nat : forall n, bin_to_nat (nat_to_bin n) = n.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

(** [] *)

(* ################################################################# *)
(** * Из Bin в Nat и обратно (продвинутое) *)

(** Обратное направление - начать с [bin], преобразовать в [nat], затем
    преобразовать обратно в [bin] - оказывается проблематичным. То есть
    следующая теорема опровержима. *)

Theorem bin_nat_bin_fails : forall b, nat_to_bin (bin_to_nat b) = b.
Abort.

(** Давайте разберемся, почему эта теорема не работает и как доказать ее
    модифицированную версию. Мы начнем с некоторых лемм, которые могут
    показаться несвязанными, но, как окажется, очень полезными. *)

(** **** Упражнение: 2 звезды, продвинутое (double_bin) *)

(** Докажите эту лемму о [double], которую мы определили ранее на этом
    занятии. *)

Lemma double_incr : forall n : nat, double (S n) = S (S (double n)).
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

(** Теперь определите аналогичную функцию удвоения для [bin]. *)

Definition double_bin (b:bin) : bin
  (* ЗАМЕНИТЕ ЭТУ СТРОКУ НА ":= _ваше_определение_ ." *). Admitted.

(** Убедитесь, что ваша функция правильно удваивает ноль. *)

Example double_bin_zero : double_bin Z = Z.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

(** Докажите эту лемму, которая соответствует [double_incr]. *)

Lemma double_incr_bin : forall b,
    double_bin (incr b) = incr (incr (double_bin b)).
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

(** [] *)

(** Давайте вернемся к нашей желанной теореме: *)

Theorem bin_nat_bin_fails : forall b, nat_to_bin (bin_to_nat b) = b.
Abort.

(** Теорема не выполняется, потому что существуют некоторые [bin] такие, что мы
    не обязательно вернемся к исходному [bin], но вместо этого к
    "эквивалентному" [bin].  (Мы намеренно оставляем это понятие неопределенным,
    чтобы вы могли подумать.)

    Объясните в комментарии ниже, почему возникает этот сбой. Ваше объяснение не
    будет оцениваться, но важно, чтобы Вы уяснили его для себя, прежде чем
    переходить к следующей части. Если Вы застряли здесь, подумайте об
    альтернативных реализациях [double_bin], которые, возможно, не удовлетворяют
    [double_bin_zero], но в остальном похожи на правильное. *)

(* ЗАПОЛНИТЕ ЗДЕСЬ *)

(** Чтобы решить эту проблему, мы можем ввести функцию _нормализации_, которая
    выбирает простейший [bin] из всех эквивалентных [bin]. Тогда мы сможем
    доказать, что преобразование из [bin] в [nat] и обратно приводит к
    нормализованным, простейшим [bin]-ам. *)

(** **** Упражнение: 4 звезды, продвинутое (bin_nat_bin) *)

(** Определите [normalize]. Вам нужно будет сделать его как можно более простым,
    насколько это возможно, для того, чтобы последующие проверки прошли гладко.
    Не используйте [bin_to_nat] или [nat_to_bin], но используйте [double_bin].

    Подсказка: Структурируйте рекурсию таким образом, чтобы она _всегда_
    доходила до конца [bin]-а и обрабатывала каждый бит только один раз. Не
    пытайтесь "заглядывать вперед" в будущие биты. *)

Fixpoint normalize (b:bin) : bin
  (* ЗАМЕНИТЕ ЭТУ СТРОКУ НА ":= _ваше_определение_ ." *). Admitted.

(** Было бы разумно сделать несколько [Примеров] доказательств, чтобы убедиться,
    что ваше определение [normalize] работает так, как вы предполагаете, прежде
    чем продолжить. Они не будут оцениваться, но заполните их ниже. *)

(* ЗАПОЛНИТЕ ЗДЕСЬ *)

(** Наконец, докажите основную теорему. С шагом индукции может быть немного
    сложнее.

    Подсказка: Начните с попытки доказать основное утверждение, посмотрите, где
    вы застряли, и посмотрите, сможете ли вы придумать лемму -- возможно,
    требующую своё собственное индуктивное доказательство -- что позволит
    продвинуться в основном доказательстве. Мы использовали одну лемму для
    случая [B0] (в которой также используется [double_incr_bin]) и другую для
    случая [B1]. *)

Theorem bin_nat_bin : forall b, nat_to_bin (bin_to_nat b) = normalize b.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

(** [] *)
