(** * Предисловие *)

(* ################################################################# *)
(** * Добро пожаловать! *)

(** Это вводный материал к курсу по Coq в Центральном Университете, основанный
    на серии электронных учебников о различных аспектах _Оснований ПО_,
    математических оснований создания надёжного программного обеспечения
    ({http://softwarefoundations.cis.upenn.edu}).  В рамках данного курса мы
    затронем базовые понятия логики, доказательства теорем с помощью компьютера,
    использование средства для интерактивных доказательств Coq, функциональное
    программирование, операционную семантику и техники изучения свойств
    программ.  Знание логики и/или теории языков программирования НЕ
    предполагается, однако наличие общей математической культуры не повредит.

    Отличительная особенность нашего курса (как и исходной серии книг) состоит в
    том, что он на 100% формализован и проверяем машиной: все материалы курса
    это буквально скрипты для Coq.  Предполагается, что читатель изучает
    материал одновременно с запуском интерактивной сессии в Coq.  Все тонкости
    материала полностью формализованы в Coq и абсолютное большинство упражнений
    созданы для выполнения с помощью Coq.

    В рамках данного курса всего будет 8 файлов, по числу занятий. В каждом из
    них есть как разбираемые на занятии упражнения, так и задачи для
    самостоятельного решения, на основе которых будет выставлена оценка.

(* ################################################################# *)
(** * Обзор *)

(** Создавать надёжное ПО тяжело -- ОЧЕНЬ тяжело.  Масштаб и сложность
    современных систем, масса привлечённых к разработке людей и набор
    предъявляемых к ним требований делают затруднительным хотя бы более-менее
    правильную реализацию продуктов, не говоря уже о 100%-ной корректности.
    Вдобавок растущая вовлечённость обработки информации в каждый аспект
    общественной жизни многократно увеличивает цену ошибок, багов и проблем с
    безопасностью.

    По мере взросления отрасли, специалисты компьютерных наук и разработчики
    придумали множество техник для улучшения надёжности программных систем,
    начиная от методик управления командами разработчиков (эджайл, экстремальное
    программирование и т.д.) и парадигм в разработке библиотек (например,
    model-view-controller, publish-subscribe, и т.д.) и языков программирования
    (ООП, функциональное программирование, ...) до математических техник для
    формального задания (спецификации) свойств программ, а также инструментов,
    помогающих в проверке этих свойств.  В рамках данного курса мы
    сосредоточимся на последней категории.

    В первой половине курса мы затронем следующие темы:

    (1) базовые инструменты из _логики_ для формулировки и доказательства
        математически точных утверждений о программах;

    (2) использование _ассистентов в формальных доказательствх_ (_proof
        assistants_) для конструирования строгих логических аргументов;

    (3) _функциональное программирование_, и как методику программирования,
        которая упрощает рассуждения о программах, и как мост между
        программированием и логикой. *)

(* ================================================================= *)
(** ** Логика *)

(** Логика -- это область исследований, предметом которых являются
    _доказательства_ -- неопровержимые аргументы в пользу истинности конкретных
    утверждений.  О центральной роли логики в компьютерных науках написаны тонны
    книг; Манна и Уолдингер назвали это "математическим анализом компьютерных
    наук", в то время как статья Халперна и др. _Эффективность логики в
    компьютерных науках_ содержит множество способов, с помощью которых логика
    предлагает важнейшие инструменты и идеи для анализа программ и алгоритмов.
    Действительно, они отмечают, что "На самом деле логика оказалась значительно
    более эффективной в компьютерных науках, чем в математике.  Это весьма
    примечательно, особенно с учетом того, что за последние сто лет математика
    во многом придала импульс развитию логики."

    В частности, фундаментальные инструменты _индуктивных доказательств_ широко
    распространены во всех областях компьютерных наук.  Вы наверняка видели их
    раньше, возможно, в курсе дискретной математики или анализа алгоритмов, но в
    этом курсе мы рассмотрим их более подробно чем вы, вероятно, делали это до
    сих пор. *)

(* ================================================================= *)
(** ** Инструменты интерактивного доказательства теорем *)

(** Обмен идеями между логикой и информатикой не был однонаправленным: CS также
    привнесли много нового в логику. В частности, было разработано множество
    программных средств, помогающих создавать доказательства логических
    утверждений.  Эти инструменты делятся на две большие категории:

       - _Aвтоматизированные средства доказательства теорем_ обеспечивают
         "кнопочное" управление: вы даете им предложение, и они возвращают либо
         _ИСТИНА_, либо _ЛОЖЬ_ (или, иногда, _НЕ ЗНАЮ: НЕ ХВАТИЛО ВРЕМЕНИ_).
         Хотя их возможности к рассуждениям по-прежнему ограничены, за последние
         десятилетия они значительно усовершенствовались и в настоящее время
         используются во множестве ситуаций.  Примеры таких инструментов
         включают в себя SAT-решатели, SMT-солверы и средства проверки моделей.

       - _Инструменты интерактивного доказательства теорем_ (proof assistants)
         -- это гибридные инструменты, автоматизирующие более рутинные аспекты
         создания доказательств, но которые в то же время направляются человеком
         в более сложных аспектах.  Широко используемые ассистенты включают в
         себя Isabelle, Agda, Twelf, ACL2, PVS, F*, HOL4, Lean, Coq и многие
         другие.

    Этот курс основан на Coq, proof assistant-е, который разрабатывается с 1983
    года и который в последние годы привлёк большое сообщество пользователей как
    в научных кругах, так и в индустрии.  Coq предоставляет богатую среду для
    интерактивной разработки формальных рассуждений, проверяемых машиной.  Ядро
    системы Coq -- это простая программа проверки правильности доказательства,
    которая гарантирует, что все шаги в логическом рассуждении корректны.  В
    дополнение к этому ядру среда Coq предоставляет высокоуровневые средства для
    разработки доказательств, включая большую библиотеку общих определений и
    лемм, мощные _тактики_ построения сложных доказательств полуавтоматически, и
    специальный язык программирования для определения новых тактик для
    автоматизации доказательств в специфичных ситуациях.

    Coq стал ключевым стимулирующим фактором для огромного разнообразия работ по
    компьютерным наукам и математике:

    - В качестве _платформы для моделирования языков программирования_, он стал
      стандартным инструментом для исследователей, которым необходимо описывать
      объёмные определения языков и исследовать их свойства.  Например, он
      использовался для проверки безопасности платформы Java Card, для
      формальных спецификаций набора инструкций x86 и LLVM, языков
      программирования (того же C).

    - В качестве _среды для разработки формально сертифицированного программного
      и аппаратного обеспечения_, Coq использовался, например, для создания
      CompCert, полностью верифицированного оптимизирующего компилятора для C, и
      CertiKOS, полностью верифицированного гипервизора, для проверки
      корректности тонких мест в алгоритмах, использующих вычисления c плавающей
      запятой, и является основой для CertiCrypt, FCF и SS Prove, фреймворков
      для проверки безопасности криптографических алгоритмов. Он также
      используется для создания верифицированных реализаций архитектуры
      процессора RISC-V с открытым исходным кодом.

    - В качестве _реалистичной среды для функционального программирования с
      зависимыми типами_, он вдохновил многочисленные инновации.  Например,
      Хоарова теория типов позволяет рассуждать о "предварительных условиях" и
      "постусловиях" (расширение _логики Хоара_, которую мы увидим позже в этом
      курсе) в Coq.

    - В качестве _proof assistant-a для логики высшего порядка_, Coq был
      использован для проверки ряда важных результатов в математике. Например,
      его способность производить сложные вычисления по ходу доказательства
      позволила разработать первое формально верифицированное доказательство
      Теоремы о четырёх красках.  Принятие не-верифицированной версии этого
      доказательства ранее было спорным вопросом среди математиков, потому что
      она требовала компьютерного перебора большого количества вариантов. В свою
      очередь, в формализации на Coq проверяется всё, в том числе и правильность
      произведённых вычислений.  Совсем недавно были предприняты еще более
      масштабные усилия, приведшие к формализации на Coq теоремы Фейта-Томпсона,
      первого важного шага в классификации конечных простых групп.

   Кстати, если вам интересно происхождение названия, вот что написано на
   официальном веб-сайте Coq в Inria (французском национальном исследовательском
   центре, где в основном разрабатывался Coq): "У некоторых французских
   компьютерщиков есть традиция называть свои программы видами животных: Caml,
   Elan, Foc или Phox являются примерами этого негласного соглашения.
   По-французски "coq" означает "петух", а ещё это звучит как аббревиатура
   названия Исчисления Конструкций (Calculus of Constructions, CoC), на котором
   он основан."  Петух также является национальным символом Франции, а C-o-q --
   это первые три буквы фамилии Тьерри Коканда, одного из первых разработчиков
   Coq. *)

(* ================================================================= *)
(** ** Функциональное программирование *)

(** Термин _функциональное программирование_ применяется как к набору идиом
    программирования, которые могут быть использованы практически в любом
    языке программирования, так и к семейству языков программирования,
    разработанных с учетом этих идиом, включающему Haskell, OCaml, Standard ML,
    F##, Scala, Scheme, Racket, Common Lisp, Clojure, Erlang, F* и Coq.

    Функциональное программирование разрабатывалось на протяжении многих
    десятилетий -- действительно, его корни уходят в лямбда-исчисление Черча,
    которое было изобретено в 1930-х годах, задолго до появления первых
    электронных компьютеров!  Но с начала 90-х годов он вызвал всплеск интереса
    среди промышленных инженеров и разработчиков языков программирования, сыграв
    ключевую роль в высокоприбыльных системах в таких компаниях, как Jane Street
    Capital, Microsoft, Facebook, Twitter и Ericsson.

    Самый основной принцип функционального программирования заключается в том,
    что вычисления, насколько это возможно, должны быть _чистыми_ в том смысле,
    что единственным эффектом исполнения должно быть получение результата в виде
    данных: в нём не должно быть _сайд-эффектов_, таких как ввод-вывод,
    присвоения значений изменяемым переменным, перенаправления указателей и т.д.
    Например, в то время как _императивная_ функция сортировки может взять
    список чисел и переставить его указатели, чтобы упорядочить список, чистая
    функция сортировки возьмет исходный список и вернет _новый_ список,
    содержащий те же числа в отсортированном порядке.

    Существенным преимуществом этого стиля программирования является то, что он
    облегчает понимание программы и рассуждение о её свойствах.  Если каждая
    операция со структурой данных приводит к созданию новой структуры данных,
    оставляя старую структуру неизменной, то нет необходимости беспокоиться о
    том, как эта структура используется совместно и может ли изменение в одной
    части программы нарушить инвариант, на который опирается другая часть
    программы.  Эти соображения особенно важны в конкурентных системах, где
    каждая часть изменяемого состояния, доступная из нескольких потоков,
    является потенциальным источником опасных ошибок. Действительно, большая
    часть современного интереса к применению функционального программирования в
    промышленности обусловлено его более простым поведением при наличии
    параллелизма.

    Еще одна причина нынешнего ажиотажа по поводу функционального
    программирования связана с первой: функциональные программы часто гораздо
    проще распараллеливать и физически распространять, чем их императивные
    аналоги.  Если запуск вычислений не дает никакого эффекта кроме получения
    конкретного значения, неважно, _где_ эти вычисления запускать.  Аналогично,
    если к структуре данных никогда не применяется разрушающее изменение, её
    можно свободно копировать между ядрами или по сети.  Действительно, идиома
    "Map-Reduce", которая лежит в основе обработчиков массово распределённых
    запросов вроде Hadoop и используется в Google для индексации всего
    Интернета, является классическим примером функционального программирования.

    Для целей данного курса функциональное программирование имеет еще одну
    важную черту: оно служит связующим звеном между логикой и компьютерными
    науками.  Действительно, Coq сам по себе можно рассматривать как сочетание
    небольшого, но чрезвычайно выразительного функционального языка
    программирования плюс набор инструментов для формулирования и доказательства
    логических утверждений.  Более того, при более внимательном рассмотрении мы
    обнаружим, что эти две стороны Coq на самом деле являются аспектами одного и
    того же базового механизма -- другими словами, _доказательства -- это
    программы_.  *)

(* ================================================================= *)
(** ** Дополнительная литература *)

(** Этот курс задуман как самостоятельный, но слушатели, которые хотят
    глубже разобраться в отдельных темах, найдут некоторые рекомендации для
    дальнейшего чтения в главе [Postscript]. Библиографию всех цитируемых работ
    можно найти в файле [Bib].*)

(* ################################################################# *)
(** * Практические аспекты *)

(* ================================================================= *)
(** ** Системные Требования *)

(** Coq работает на Windows, Linux, и macOS.  Материалы этого курса были
    протестированы на версии Coq 8.19.2.

    Вам потребуется:

    - Свежая версия Coq, доступная на домашней странице Coq
      ({https://coq.inria.fr/download}). "Coq Platform", как правило, установить
      проще всего, особенно на Windows.

      Если Вы используете комбинацию VSCode + Docker, описанную ниже, Вам не
      потребуется устанавливать Coq отдельно.

    - IDE для взаимодействия с Coq.  Есть несколько вариантов:

        - _VsCoq_ это расширение для VS Code, предлагающее простой интерфейс в
          знакомой IDE.  Это "рекомендованный по умолчанию" вариант. Если Вы
          установили Coq с официального сайта, то Вы можете использовать только
          версию "VsCoq Legacy", которая в любом случае более стабильна. Если Вы
          используете менеджер пакетов opam, Вы также можете попробовать
          "VsCoq 2". Это расширение более экспериментальное, но и
          функциональности в нём намного больше.

          VsCoq может быть использован как обычная IDE, либо может быть совмещён
          с Docker (см. ниже) для более легковесной установки.

        - _Proof General_ это IDE, основанная на Emacs.  Обычно, её предпочитают
          пользователи, которым уже привычен Emacs. Он требует отдельной
          установки и настройки (загуглите "Proof General", но, как правило,
          всё, что Вам нужно сделать, это [M-x package-list-packages],
          затем выбрать пакет [proof-general] из списка и нажать [i] для
          установки, затем [x] для исполнения).

          Желающим поэкспериментировать с Coq внутри Emacs могут понравиться
          такие расширения как [company-coq] и [control-lock].

        - _CoqIDE_ это упрощённая самостоятельная IDE.  Она распространяется
          вместе с Coq, так что должна быть доступна сразу, как Вы установите
          Coq. Также её можно собрать из исходников, но на некоторых платформах
          это может потребовать установки дополнительных пакетов для
          GUI-фреймворков и пр.

          Пользователям, которым нравится CoqIDE, стоит попробовать запустить
          его с выключенными режимами "asynchronous" и "error resilience": [[
          coqide -async-proofs off \
          -async-proofs-command-error-resilience off Foo.v &
          ]]

        - Ваш покорный слуга предпочитает использовать _NeoVim_ с плагином
          _Coqtail_. *)

(* ----------------------------------------------------------------- *)
(** *** Coq с VSCode и Docker *)

(** VS Code может взаимодействовать с платформой виртуализации Docker для
    компиляции скриптов на Coq без необходимости какой-либо отдельной
    установки Coq.  Чтобы все настроить, выполните следующие действия:

    - Установите Docker с помощью [https://www.docker.com/get-started/] или
      убедитесь, что у Вашей текущей установки актуальная версия.

    - Убедитесь, что Docker запущен.

    - Установите VS Code из [https://code.visualstudio.com] и запустите его.

    - Установите расширение Remote Containers для VS Code из [
        https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-containers
        ]

    - Склонируйте к себе репозиторий курса (в VS Code это можно сделать, выбрав
      опцию "Clone Git Repository...").  Помимо файла [.v] для каждой главы,
      этот репозиторий будет содержать подпапку [.devcontainer] с инструкциями
      для VSCode о том, где найти соответствующий образ Docker, и файл
      [_CoqProject], наличие которого является триггером для запуска VsCoq.

    - Откройте репозиторий в VS Code. IDE должна спросить вас, хотите ли вы
      запустить проект в соответствующем контейнере Docker.  (Если вас не
      спросят, вы можете открыть командную палитру, нажав клавишу F1, и
      выполнить команду “Dev Containers: Reopen in Container”.)

    - Убедитесь, что VSCoq работает, дважды щелкнув файл [Lecture1.v] в списке
      слева (вы должны увидеть мигающий курсор в открывшемся окне; если нет, вы
      можете щелкнуть на этом окне, чтобы выбрать его), и несколько раз нажмите
      [alt+стрелка вниз] (в Mac OS -- [control+option+стрелка вниз]).  Вы должны
      увидеть, как курсор перемещается по файлу, а область над курсором
      становится подсвеченной.

    - Чтобы узнать, какие ещё сочетания клавиш доступны, нажмите клавишу F1 и
      затем введите [Coq:] или посетите веб-страницы VSCoq:
      [https://github.com/coq-community/vscoq/tree/vscoq1].  *)

(* ================================================================= *)
(** ** Упражнения *)

(** Каждая глава содержит множество упражнений.  Каждое из них отмечено
    "звездным рейтингом", который можно интерпретировать следующим образом:

       - Одна звездочка: простые упражнения, которые подчеркивают некоторые
         моменты в тексте и которые для большинства слушателей должны занять
         всего минуту или две. Возьмите за привычку выполнять их по мере чтения.

       - Две звезды: простые упражнения (пять-десять минут).

       - Три звезды: упражнения, требующие некоторого размышления (от десяти
         минут до получаса).

       - Четыре и пять звезд: более сложные упражнения (дольше получаса).

    Имейте в виду, что автогрейдер присваивает дополнительные баллы за более
    сложные упражнения:

      1 звездочка = 1 балл
      2 звездочки = 2 балла
      3 звездочки = 3 балла
      4 звездочки = 6 баллов
      5 звездочек = 10 баллов

    Некоторые упражнения помечены как "продвинутые", а некоторые - как
    "необязательные".  Выполнение только обязательных, не-продвинутых упражнений
    должно обеспечивать хорошее усвоение базового материала.  Необязательные
    упражнения дают немного дополнительной практики в работе с ключевыми
    понятиями и знакомят с второстепенными темами, которые могут представлять
    интерес для некоторых слушателей.  Продвинутые упражнения предназначены для
    слушателей, которым нужен дополнительный челлендж и более глубокое
    погружение.

    _Пожалуйста, не размещайте решения упражнений в публичном доступе_.
    Оригинальная серия книг, Software Foundations, широко используется как для
    самостоятельного изучения, так и для университетских курсов.  Наличие
    легкодоступных решений делает его гораздо менее полезным для курсов, которые
    обычно содержат домашние задания с оценкой.  Мы особенно просим слушателей
    не размещать решения к упражнениям в тех местах, где их могут найти
    поисковые системы. *)

(* ================================================================= *)
(** ** Загрузка материалов *)

(** Архив с расширением .tar, содержащий все исходники к "публичному релизу"
    оригинальной книги (в виде коллекции скриптов на Coq и файлов HTML) доступен
    по ссылке {https://softwarefoundations.cis.upenn.edu}.

    Наши слегка отредактированные и переведённые на русский язык файлы доступны
    в приватном репозитории курса. По ходу прохождения курса, в нём будут
    появляться новые материалы каждую неделю. *)

(* ################################################################# *)
(** * Ресурсы *)

(* ================================================================= *)
(** ** Лекционные видео *)

(** Лекции по двум летним интенсивам, основанным на оригинальной книге _Logical
    Foundations_ (входит в программу регулярной летней школы DeepSpec) можно
    найти по следующим ссылкам: {https://deepspec.org/event/dsss17} и
    {https://deepspec.org/event/dsss18/}.  Качество видео в лекциях за 2017
    поначалу не очень хорошее, но в дальнейшем становится гораздо лучше. *)

(** * Основы: Функциональное Программмирование на Coq *)

(* ################################################################# *)
(** * Введение *)

(** Функциональный стиль программирования основан на простой, повседневной
    математической интуиции: если процедура или метод не имеют побочных
    эффектов, то (игнорируя эффективность) все, что нам нужно знать для работы с
    ним -- это то, как он сопоставляет входные данные с выходными, то есть мы
    можем думать о нём просто как о конкретном методе вычисления математической
    функции.  Это одно из значений слова "функциональный" в словосочетании
    "функциональное программирование".  Прямая связь между программами и
    простыми математическими объектами поддерживает как формальную корректность
    доказательств, так и обоснованные неформальные рассуждения о поведении
    программы.

    Другой смысл, в котором функциональное программирование является
    "функциональным", заключается в том, что оно подчеркивает использование
    функций в качестве значений _первого класса_ -- т.е. значений, которые могут
    передаваться в качестве аргументов другим функциям, возвращаться в качестве
    результатов, включаться в структуры данных и т.д.  Понимание того, что
    функции можно рассматривать как данные, порождает множество полезных и
    мощных идиом программирования.

    Другие общие черты функциональных языков включают в себя _алгебраические
    типы данных_ и _сопоставление c шаблоном_, которые упрощают создание сложных
    структур данных и манипулирование ими, а также _полиморфные системы типов_,
    поддерживающие абстракцию и повторное использование кода.  В Coq доступны
    все эти функции.

    В первой четверти этого занятия представлены наиболее важные элементы
    собственного функционального языка программирования Coq, _Gallina_.  Во
    второй части представлены некоторые базовые _тактики_, которые можно
    использовать для доказательства свойств программ, написанных на Gallina. *)

(* ################################################################# *)
(** * Сдача домашних заданий *)

(** Мы используем скрипты на Coq для автопроверки Ваших домашних заданий.  Чтобы
    эти скрипты работали корректно (и чтобы вы получили полную оценку за свою
    работу!), пожалуйста, внимательно следуйте этим правилам:

      - Не меняйте названия упражнений. В противном случае скрипты для
        выставления оценок не смогут найти Ваше решение.
      - Не удаляйте упражнения.  Если вы пропустите какое-либо упражнение
        (например, поскольку оно помечено как "необязательное" или потому что вы
        не можете его решить), можно оставить частичное доказательство в вашем
        файле [.v]; в этом случае, пожалуйста, убедитесь, что оно заканчивается
        ключевым словом [Admitted] (а не, например, [Abort]).
      - В своих решениях можно использовать дополнительные определения
        (вспомогательных функций, полезных лемм и т.д.).  Вы можете поместить их
        перед теоремой, которую вас просят доказать.
      - Если вы вводите вспомогательную лемму, которую вы в конечном итоге не
        можете доказать, заканчивайте её словом [Admitted], затем не забудьте
        также закончить основную теорему, в которой вы ее используете, словом
        [Admitted], а не [Qed].  Это поможет вам получить частичный балл в том
        случае, если вы используете эту основную теорему для решения
        последующего упражнения.

    Вы также заметите, что каждый файл (например, [Lecture1.v]) сопровождается
    _тестирующим скриптом_ ([Lecture1Test.v]), который автоматически
    подсчитывает баллы за готовые домашние задания в этой главе.  Эти скрипты в
    основном предназначены для автопроверки, но вы также можете воспользоваться
    ими, чтобы еще раз проверить, правильно ли отформатирован ваш файл, прежде
    чем сдать его.  Ввполните в терминале команду "[make Lecture1Test.vo]" или
    выполните следующие действия:

       coqc -Q . Lecture1.v
       coqc -Q . Lecture1Test.v

    Более подробную информацию о том, как интерпретировать выходные данные
    тестирующих скриптов, смотрите далее.

    Сам тестирующий скрипт ([Lecture1Test.v]) сдавать не нужно!

    Для сдачи домашних заданий сделайте следующее:

      - Создайте приватную копию репозитория курса.
      - Выдайте лектору доступ к Вашей приватной копии.
      - Решайте домашнее задание прямо в файлах [Lecture1.v], [Lecture2.v],...
      - Для сдачи домашнего задания на проверку создавайте коммиты с Вашими
        изменениями и отправляйте их в Вашу приватную копию.
      - В репозитории настроен GitHub Workflow, запускающий автопроверку при
        каждом коммите в основную ветку. Это поможет и Вам, и проверяющему сразу
        увидеть результаты проверки. *)

(* ################################################################# *)
(** * Типы данных и функции *)

(* ================================================================= *)
(** ** Типы-перечисления *)

(** Одной из примечательных особенностей Coq является то, что встроенная в него
    функциональность _чрезвычайно_ ограничена.  Например, вместо предоставления
    обычного набора атомарных типов данных (логические значения, целые числа,
    строки и т.д.), Coq предлагает мощный механизм для определения новых типов
    данных с нуля, предоставляя возможность задать все эти знакомые типы на
    уровне библиотек.

    Естественно, дистрибутив Coq поставляется с обширной стандартной
    библиотекой, предоставляющей определения логических значений, чисел и многих
    распространенных структур данных, таких как списки и хэш-таблицы.  Но в этих
    библиотечных определениях нет ничего волшебного или примитивного.  Чтобы
    проиллюстрировать это, в этом курсе мы подробно рассмотрим (почти) все
    определения, которые нам нужны, вместо того чтобы брать их из стандартной
    библиотеки. *)

(* ================================================================= *)
(** ** Дни недели *)

(** Чтобы увидеть, как работает этот механизм определений, давайте начнем с
    очень простого примера.  Следующее объявление сообщает Coq-у, что мы
    определяем набор значений данных -- _тип_. *)

Inductive day : Type :=
  | monday
  | tuesday
  | wednesday
  | thursday
  | friday
  | saturday
  | sunday.

(** Новый тип называется [day], а его членами являются [monday], [tuesday] и
    т.д.

    Определив [day], мы можем написать функции, которые работают с днями
    недели. *)

Definition next_working_day (d:day) : day :=
  match d with
  | monday    => tuesday
  | tuesday   => wednesday
  | wednesday => thursday
  | thursday  => friday
  | friday    => monday
  | saturday  => monday
  | sunday    => monday
  end.

(** Обратите внимание, что типы аргументов и возвращаемых значений этой функции
    объявлены здесь явно.  Как и в большинстве функциональных языков
    программирования, Coq часто может сам определять эти типы, если они не
    заданы явно -- т.е. он может выполнять _вывод типов_ -- но, как правило, мы
    выписываем их явно, чтобы облегчить чтение. *)

(** Определив функцию, мы можем проверить, работает ли она на некоторых
    примерах.  На самом деле в Coq есть три разных способа выполнения примеров.
    Во-первых, мы можем использовать команду [Compute] для вычисления составного
    выражения, включающего [next_working_day]. *)

Compute (next_working_day friday).
(* ==> monday : day *)

Compute (next_working_day (next_working_day saturday)).
(* ==> tuesday : day *)

(** (Мы показываем ответы Coq в комментариях; если с Вами сейчас есть Ваш
    компьютер, это отличный момент, чтобы запустить интерпретатор Coq в вашей
    любимой среде IDE (инструкции по установке смотрите выше) и попробовать его
    самостоятельно.  Загрузите этот файл, [Lecture1.v], из репозитория, найдите
    приведенный выше пример, отправьте его в Coq и понаблюдайте за
    результатом.) *)

(** Во-вторых, мы можем записать _ожидаемый_ результат в виде примера Coq: *)

Example test_next_working_day:
  (next_working_day (next_working_day saturday)) = tuesday.

(** Это объявление делает две вещи: оно создает утверждение (что вторым рабочим
    днем после [субботы] является [вторник]) и присваивает утверждению имя,
    которое можно использовать для ссылки на него позже. Создав утверждение, мы
    также можем попросить Coq проверить его следующим образом: *)

Proof. simpl. reflexivity.  Qed.

(** Детали сейчас не важны, но, по сути, этот небольшой скрипт можно прочитать
    как "Утверждение, которое мы только что сделали, можно доказать, заметив,
    что обе стороны равенства приводят к одному и тому же результату". *)

(** В-третьих, мы можем попросить Coq извлечь из нашего [Определения] программу
    на более традиционном языке программирования (OCaml, Scheme или Haskell) с
    помощью высокопроизводительного компилятора.  Это средство очень полезно,
    поскольку оно прокладывает нам путь от корректных-по-построению алгоритмов,
    написанных на Gallina, к эффективному машинному коду.

    (Конечно, мы доверяем корректности компилятора OCaml/Haskell/Scheme и
    средствам извлечения Coq самим по себе, но это все равно большой шаг вперед
    по сравнению с тем, как сегодня разрабатывается большинство программ!)

    Действительно, это одно из основных применений, для которых был разработан
    Coq. Мы вернемся к этой теме в следующих главах. *)

(** Инструкция [Require Export] в следующей строке указывает Coq использовать
    модуль [String] из стандартной библиотеки.  Мы будем использовать строки
    для различных целей в последующих занятиях, но нам нужно [Потребовать] это
    здесь, чтобы скрипты автопроверки могли использовать строки для своих
    целей. *)
From Coq Require Export String.

(* ================================================================= *)
(** ** Логические значения *)

(** Аналогично дням недели, определённым выше, мы можем определить стандартный
    тип логических значений [bool] с элементами [true] и [false]. *)

Inductive bool : Type :=
  | true
  | false.

(** Функции над логическими значениями могут быть определены таким же образом,
    как выше: *)

Definition negb (b:bool) : bool :=
  match b with
  | true => false
  | false => true
  end.

Definition andb (b1:bool) (b2:bool) : bool :=
  match b1 with
  | true => b2
  | false => false
  end.

Definition orb (b1:bool) (b2:bool) : bool :=
  match b1 with
  | true => true
  | false => b2
  end.

(** (Хотя здесь мы используем наши собственные логические значения ради создания
    всего с нуля, Coq, конечно же, по умолчанию предоставляет реализацию
    логических значений, а также множество полезных функций и лемм.  Везде, где
    это было возможно, мы давали нашим собственным определениям и теоремам
    названия, соответствующие тем, что есть в стандартной библиотеке.) *)

(** Последние два из них иллюстрируют синтаксис Coq для определения функций с
    несколькими аргументами.  Соответствующий синтаксис _применения_ функций с
    несколькими аргументами проиллюстрирован следующими "юнит-тестами", которые
    представляют собой полную спецификацию -- таблицу истинности -- для функции
    [orb].: *)

Example test_orb1:  (orb true  false) = true.
Proof. simpl. reflexivity.  Qed.
Example test_orb2:  (orb false false) = false.
Proof. simpl. reflexivity.  Qed.
Example test_orb3:  (orb false true)  = true.
Proof. simpl. reflexivity.  Qed.
Example test_orb4:  (orb true  true)  = true.
Proof. simpl. reflexivity.  Qed.

(** Мы также можем ввести немного знакомого инфиксного синтаксиса для логических
    операций, которые мы только что определили. Команда [Notation] определяет
    новую символьную запись для существующих определений. *)

Notation "x && y" := (andb x y).
Notation "x || y" := (orb x y).

Example test_orb5:  false || false || true = true.
Proof. simpl. reflexivity. Qed.

(** _Примечание о нотации_: В файлах [.v] мы используем квадратные скобки
    для выделения фрагментов кода Coq в комментариях; это соглашение, также
    используемое инструментом документации [coqdoc], визуально отделяет их от
    окружающего текста.  В HTML-версии файлов эти фрагменты текста выделены
    другим шрифтом. *)

(** Эти примеры также дают повод показать еще одну маленькую особенность
    Gallina: условные выражения... *)

Definition negb' (b:bool) : bool :=
  if b then false
  else true.

Definition andb' (b1:bool) (b2:bool) : bool :=
  if b1 then b2
  else false.

Definition orb' (b1:bool) (b2:bool) : bool :=
  if b1 then true
  else b2.

(** Условные выражения в Coq точно такие же, как и в любом другом языке, с одним
    небольшим обобщением:

    Поскольку тип [bool] не встроен, Coq фактически поддерживает условные
    выражения для _любого_ индуктивно определенного типа с ровно двумя
    конструкторами в его определении.  Условие считается истинным, если оно
    вычисляется как первый конструктор [Индуктивного] определения (которое,
    просто потому что мы так выбрали, в данном случае называется [true]), и
    ложной, если она вычисляется как второй. *)

(** Например, мы можем определить следующий тип данных [bw] с помощью двух
    конструкторов, представляющих черный ([b]) и белый ([w]) цвета, и определить
    функцию [invert], которая инвертирует значения этого типа с помощью
    условного выражения. *)

Inductive bw : Type :=
  | bw_black
  | bw_white.

Definition invert (x: bw) : bw :=
  if x then bw_white
  else bw_black.

Compute (invert bw_black).
(* ==> bw_white : bw *)

Compute (invert bw_white).
(* ==> bw_black : bw *)

(** **** Упражнение: 1 звезда, стандартное (nandb)

    Команда [Admitted] может использоваться как заглушка для неполного
    доказательства.  Мы используем ее в упражнениях, чтобы указать части,
    которые мы оставляем для Вас, т.е. ваша задача -- заменить [Допущенные]
    части настоящими доказательствами.

    Удалите "[Admitted.]" и завершите определение следующей функции; затем
    убедитесь, что Coq справляется с проверкой каждого из приведенных ниже
    [Примеров].  (Т.е. заполните каждое доказательство, следуя приведенной выше
    модели тестов [orb], и убедитесь, что Coq их принимает.) Функция должна
    возвращать [true], если один или оба ее входных сигнала равны [false].

    Подсказка: если [simpl] не упростит цель вашего доказательства, вероятно,
    это потому, что вы определили [nandb] без использования выражения [match].
    Попробуйте другое определение [nandb] или просто пропустите [simpl] и
    перейдите непосредственно к [reflexivity]. Мы объясним этот феномен позднее
    в рамках этого занятия. *)

Definition nandb (b1:bool) (b2:bool) : bool
  (* ЗАМЕНИТЕ ЭТУ СТРОКУ НА ":= _ваше_определение_ ." *). Admitted.

Example test_nandb1:               (nandb true false) = true.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
Example test_nandb2:               (nandb false false) = true.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
Example test_nandb3:               (nandb false true) = true.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
Example test_nandb4:               (nandb true true) = false.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** **** Упражнение: 1 звезда, стандартное (andb3)

    Сделайте то же самое для функции [andb3] ниже. Эта функция должна возвращать
    [true] когда все её входы [true], и [false] в противном случае. *)

Definition andb3 (b1:bool) (b2:bool) (b3:bool) : bool
  (* ЗАМЕНИТЕ ЭТУ СТРОЧКУ НА ":= _ваше_определение_ ." *). Admitted.

Example test_andb31:                 (andb3 true true true) = true.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
Example test_andb32:                 (andb3 false true true) = false.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
Example test_andb33:                 (andb3 true false true) = false.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
Example test_andb34:                 (andb3 true true false) = false.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(* ================================================================= *)
(** ** Типы *)

(** Каждое выражение в Coq имеет тип, описывающий, что именно оно вычисляет.
    Команда [Check] просит Coq распечатать тип выражения. *)

Check true.
(* ===> true : bool *)

(** Если после [Check] следует двоеточие и объявление типа, Coq проверит,
    соответствует ли тип выражения заданному типу и остановится с ошибкой, если
    это не так. *)

Check true
  : bool.
Check (negb true)
  : bool.

(** Функции, подобные [negb], сами по себе также являются значениями, как [true]
    и [false].  Их типы называются _типами функций_ и пишутся со стрелками. *)

Check negb
  : bool -> bool.

(** Тип [negb], записываемый как [bool -> bool] и произносимый как "[bool]
    стрелка [bool]", можно прочитать как "Получив на вход данные типа [bool],
    эта функция возвращает данные типа [bool]". Аналогично, тип [and],
    записанный как [bool -> bool -> bool], может быть прочитан следующим
    образом: "Получив на вход два значения, каждое из которых имеет тип [bool],
    эта функция возвращает значение типа [bool]". *)

(* ================================================================= *)
(** ** Новые Типы из Старых *)

(** Типы, которые мы определили до сих пор, являются примерами
    "типов-перечислений": их определения явно перечисляют конечный набор
    элементов, называемых _конструкторами_.  Вот более интересное определение
    типа, где один из конструкторов принимает аргумент: *)

Inductive rgb : Type :=
  | red
  | green
  | blue.

Inductive color : Type :=
  | black
  | white
  | primary (p : rgb).

(** Давайте изучим его более подробно.

    [Индуктивное] определение выполняет две функции:

    - Оно определяет набор новых _конструкторов_. Например, [red], [primary],
      [true], [false], [monday] и т.д. являются конструкторами.

    - Оно группирует их в новый именованный тип, например [bool], [rgb] или
      [color].

    _Конструкторные выражения_ формируются с помощью применения конструктора к
    некоторому (0 или более) количеству других конструкторов или конструкторных
    выражений, соблюдая заявленное количество и типы аргументов конструктора.
    Например, это правильные конструкторные выражения...
        - [red]
        - [true]
        - [primary red]
        - и т.д.
   ... а эти -- нет:
        - [red primary]
        - [true red]
        - [primary (primary red)]
        - и т.д. *)

(** В частности, определения [rgb] и [color] указывают, какие конструкторные
    выражения принадлежат множествам [rgb] и [color]:

    - [red], [green] и [blue] принадлежат набору [rgb].;
    - [black] и [white] относятся к множеству [color];
    - если [p] является конструкторным выражением, принадлежащим набору [rgb],
      то [primary p] ("конструктор [primary], примененный к аргументу [p]")
      является конструкторным выражением, принадлежащим множеству [color]; и
    - конструкторные выражения, сформированные этими способами, являются
      _единственными_ принадлежащими множествам [rgb] и [color]. *)

(** Мы можем определить функции на цветах, используя сопоставление с образцом,
    точно так же, как мы это делали для [day] и [bool]. *)

Definition monochrome (c : color) : bool :=
  match c with
  | black => true
  | white => true
  | primary p => false
  end.

(** Поскольку конструктор [primary] принимает аргумент, шаблон, соответствующий
    [primary], должен содержать либо переменную, как мы только что сделали
    (обратите внимание, что мы можем свободно выбирать ее имя), либо константу
    соответствующего типа (как показано ниже). *)

Definition isred (c : color) : bool :=
  match c with
  | black => false
  | white => false
  | primary red => true
  | primary _ => false
  end.

(** Шаблон "[primary _]" здесь является сокращением для обозначения
    "конструктора [primary], применяемого к любому конструктору [rgb], кроме
    [red]". *)

(** (Универсальный шаблон [_] имеет тот же эффект, что и фиктивная
    переменная шаблона [p] в определении [monochrome].) *)

(* ================================================================= *)
(** ** Modules *)

(** Coq provides a _module system_ to aid in organizing large
    developments.  We won't need most of its features, but one is
    useful here: If we enclose a collection of declarations between
    [Module X] and [End X] markers, then, in the remainder of the file
    after the [End], these definitions are referred to by names like
    [X.foo] instead of just [foo].  We will use this feature to limit
    the scope of definitions, so that we are free to reuse names. *)

Module Playground.
  Definition foo : rgb := blue.
End Playground.

Definition foo : bool := true.

Check Playground.foo : rgb.
Check foo : bool.

(* ================================================================= *)
(** ** Tuples *)

Module TuplePlayground.

(** A single constructor with multiple parameters can be used
    to create a tuple type. As an example, consider representing
    the four bits in a nybble (half a byte). We first define
    a datatype [bit] that resembles [bool] (using the
    constructors [B0] and [B1] for the two possible bit values)
    and then define the datatype [nybble], which is essentially
    a tuple of four bits. *)

Inductive bit : Type :=
  | B1
  | B0.

Inductive nybble : Type :=
  | bits (b0 b1 b2 b3 : bit).

Check (bits B1 B0 B1 B0)
  : nybble.

(** The [bits] constructor acts as a wrapper for its contents.
    Unwrapping can be done by pattern-matching, as in the [all_zero]
    function below, which tests a nybble to see if all its bits are
    [B0].

    We use underscore (_) as a _wildcard pattern_ to avoid inventing
    variable names that will not be used. *)

Definition all_zero (nb : nybble) : bool :=
  match nb with
  | (bits B0 B0 B0 B0) => true
  | (bits _ _ _ _) => false
  end.

Compute (all_zero (bits B1 B0 B1 B0)).
(* ===> false : bool *)
Compute (all_zero (bits B0 B0 B0 B0)).
(* ===> true : bool *)

End TuplePlayground.

(* ================================================================= *)
(** ** Numbers *)

(** We put this section in a module so that our own definition of
    natural numbers does not interfere with the one from the
    standard library.  In the rest of the book, we'll want to use
    the standard library's. *)

Module NatPlayground.

(** All the types we have defined so far -- both "enumerated
    types" such as [day], [bool], and [bit] and tuple types such as
    [nybble] built from them -- are finite.  The natural numbers, on
    the other hand, are an infinite set, so we'll need to use a
    slightly richer form of type declaration to represent them.

    There are many representations of numbers to choose from. You are
    almost certainly most familiar with decimal notation (base 10),
    using the digits 0 through 9, for example, to form the number 123.
    You may very likely also have encountered hexadecimal
    notation (base 16), in which the same number is represented as 7B,
    or octal (base 8), where it is 173, or binary (base 2), where it
    is 1111011. Using an enumerated type to represent digits, we could
    use any of these as our representation natural numbers. Indeed,
    there are circumstances where each of these choices would be
    useful.

    The binary representation is valuable in computer hardware because
    the digits can be represented with just two distinct voltage
    levels, resulting in simple circuitry. Analogously, we wish here
    to choose a representation that makes _proofs_ simpler.

    In fact, there is a representation of numbers that is even simpler
    than binary, namely unary (base 1), in which only a single digit
    is used (as our forebears might have done to count days by making
    scratches on the walls of their caves). To represent unary numbers
    with a Coq datatype, we use two constructors. The capital-letter
    [O] constructor represents zero. The [S] constructor can be
    applied to the representation of the natural number n, yieldimng
    the representation of n+1, where [S] stands for "successor" (or
    "scratch").  Here is the complete datatype definition: *)

Inductive nat : Type :=
  | O
  | S (n : nat).

(** With this definition, 0 is represented by [O], 1 by [S O],
    2 by [S (S O)], and so on. *)

(** Informally, the clauses of the definition can be read:
      - [O] is a natural number (remember this is the letter "[O],"
        not the numeral "[0]").
      - [S] can be put in front of a natural number to yield another
        one -- i.e., if [n] is a natural number, then [S n] is too. *)

(** Again, let's look at this a bit more closely.  The definition
    of [nat] says how expressions in the set [nat] can be built:

    - the constructor expression [O] belongs to the set [nat];
    - if [n] is a constructor expression belonging to the set [nat],
      then [S n] is also a constructor expression belonging to the set
      [nat]; and
    - constructor expressions formed in these two ways are the only
      ones belonging to the set [nat]. *)

(** These conditions are the precise force of the [Inductive]
    declaration that we gave to Coq.  They imply that the constructor
    expression [O], the constructor expression [S O], the constructor
    expression [S (S O)], the constructor expression [S (S (S O))],
    and so on all belong to the set [nat], while other constructor
    expressions like [true], [andb true false], [S (S false)], and
    [O (O (O S))] do not.

    A critical point here is that what we've done so far is just to
    define a _representation_ of numbers: a way of writing them down.
    The names [O] and [S] are arbitrary, and at this point they have
    no special meaning -- they are just two different marks that we
    can use to write down numbers, together with a rule that says any
    [nat] will be written as some string of [S] marks followed by an
    [O].  If we like, we can write essentially the same definition
    this way: *)

Inductive otherNat : Type :=
  | stop
  | tick (foo : otherNat).

(** The _interpretation_ of these marks arises from how we use them to
    compute. *)

(** We can do this by writing functions that pattern match on
    representations of natural numbers just as we did above with
    booleans and days -- for example, here is the predecessor
    function: *)

Definition pred (n : nat) : nat :=
  match n with
  | O => O
  | S n' => n'
  end.

(** The second branch can be read: "if [n] has the form [S n']
    for some [n'], then return [n']."  *)

(** The following [End] command closes the current module, so
    [nat] will refer back to the type from the standard library. *)

End NatPlayground.

(** Because natural numbers are such a pervasive kind of data,
    Coq does provide a tiny bit of built-in magic for parsing and
    printing them: ordinary decimal numerals can be used as an
    alternative to the "unary" notation defined by the constructors
    [S] and [O].  Coq prints numbers in decimal form by default: *)

Check (S (S (S (S O)))).
(* ===> 4 : nat *)

Definition minustwo (n : nat) : nat :=
  match n with
  | O => O
  | S O => O
  | S (S n') => n'
  end.

Compute (minustwo 4).
(* ===> 2 : nat *)

(** The constructor [S] has the type [nat -> nat], just like functions
    such as [pred] and [minustwo]: *)

Check S        : nat -> nat.
Check pred     : nat -> nat.
Check minustwo : nat -> nat.

(** These are all things that can be applied to a number to yield a
    number.  However, there is a fundamental difference between [S]
    and the other two: functions like [pred] and [minustwo] are
    defined by giving _computation rules_ -- e.g., the definition of
    [pred] says that [pred 2] can be simplified to [1] -- while the
    definition of [S] has no such behavior attached.  Although it is
    _like_ a function in the sense that it can be applied to an
    argument, it does not _do_ anything at all!  It is just a way of
    writing down numbers.

    Think about standard decimal numerals: the numeral [1] is not a
    computation; it's a piece of data.  When we write [111] to mean
    the number one hundred and eleven, we are using [1], three times,
    to write down a concrete representation of a number.

    Let's go on and define some more functions over numbers.

    For most interesting computations involving numbers, simple
    pattern matching is not enough: we also need recursion.  For
    example, to check that a number [n] is even, we may need to
    recursively check whether [n-2] is even.  Such functions are
    introduced with the keyword [Fixpoint] instead of [Definition]. *)

Fixpoint even (n:nat) : bool :=
  match n with
  | O        => true
  | S O      => false
  | S (S n') => even n'
  end.

(** We could define [odd] by a similar [Fixpoint] declaration, but
    here is a simpler way: *)

Definition odd (n:nat) : bool :=
  negb (even n).

Example test_odd1:    odd 1 = true.
Proof. simpl. reflexivity.  Qed.
Example test_odd2:    odd 4 = false.
Proof. simpl. reflexivity.  Qed.

(** (You may notice if you step through these proofs that
    [simpl] actually has no effect on the goal -- all of the work is
    done by [reflexivity].  We'll discuss why shortly.)

    Naturally, we can also define multi-argument functions by
    recursion.  *)

Module NatPlayground2.

Fixpoint plus (n : nat) (m : nat) : nat :=
  match n with
  | O => m
  | S n' => S (plus n' m)
  end.

(** Adding three to two gives us five (whew!): *)

Compute (plus 3 2).
(* ===> 5 : nat *)

(** The steps of simplification that Coq performs here can be
    visualized as follows: *)

(*      [plus 3 2]
   i.e. [plus (S (S (S O))) (S (S O))]
    ==> [S (plus (S (S O)) (S (S O)))]
          by the second clause of the [match]
    ==> [S (S (plus (S O) (S (S O))))]
          by the second clause of the [match]
    ==> [S (S (S (plus O (S (S O)))))]
          by the second clause of the [match]
    ==> [S (S (S (S (S O))))]
          by the first clause of the [match]
   i.e. [5]  *)

(** As a notational convenience, if two or more arguments have
    the same type, they can be written together.  In the following
    definition, [(n m : nat)] means just the same as if we had written
    [(n : nat) (m : nat)]. *)

Fixpoint mult (n m : nat) : nat :=
  match n with
  | O => O
  | S n' => plus m (mult n' m)
  end.

Example test_mult1: (mult 3 3) = 9.
Proof. simpl. reflexivity.  Qed.

(** We can match two expressions at once by putting a comma
    between them: *)

Fixpoint minus (n m:nat) : nat :=
  match n, m with
  | O   , _    => O
  | S _ , O    => n
  | S n', S m' => minus n' m'
  end.

End NatPlayground2.

Fixpoint exp (base power : nat) : nat :=
  match power with
  | O => S O
  | S p => mult base (exp base p)
  end.

(** **** Exercise: 1 star, standard (factorial)

    Recall the standard mathematical factorial function:

       factorial(0)  =  1
       factorial(n)  =  n * factorial(n-1)     (if n>0)

    Translate this into Coq.

    Make sure you put a [:=] between the header we've provided and
    your definition.  If you see an error like "The reference
    factorial was not found in the current environment," it means
    you've forgotten the [:=]. *)

Fixpoint factorial (n:nat) : nat
  (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.

Example test_factorial1:          (factorial 3) = 6.
(* FILL IN HERE *) Admitted.
Example test_factorial2:          (factorial 5) = (mult 10 12).
(* FILL IN HERE *) Admitted.
(** [] *)

(** Again, we can make numerical expressions easier to read and write
    by introducing notations for addition, subtraction, and
    multiplication. *)

Notation "x + y" := (plus x y)
                       (at level 50, left associativity)
                       : nat_scope.
Notation "x - y" := (minus x y)
                       (at level 50, left associativity)
                       : nat_scope.
Notation "x * y" := (mult x y)
                       (at level 40, left associativity)
                       : nat_scope.

Check ((0 + 1) + 1) : nat.

(** (The [level], [associativity], and [nat_scope] annotations
    control how these notations are treated by Coq's parser.  The
    details are not important for present purposes, but interested
    readers can refer to the "More on Notation" section at the end of
    this chapter.)

    Note that these declarations do not change the definitions we've
    already made: they are simply instructions to Coq's parser to
    accept [x + y] in place of [plus x y] and, conversely, to its
    pretty-printer to display [plus x y] as [x + y]. *)

(** When we say that Coq comes with almost nothing built-in, we really
    mean it: even testing equality is a user-defined operation!
    Here is a function [eqb], which tests natural numbers for
    [eq]uality, yielding a [b]oolean.  Note the use of nested
    [match]es (we could also have used a simultaneous match, as
    in [minus].) *)

Fixpoint eqb (n m : nat) : bool :=
  match n with
  | O => match m with
         | O => true
         | S m' => false
         end
  | S n' => match m with
            | O => false
            | S m' => eqb n' m'
            end
  end.

(** Similarly, the [leb] function tests whether its first argument is
    less than or equal to its second argument, yielding a boolean. *)

Fixpoint leb (n m : nat) : bool :=
  match n with
  | O => true
  | S n' =>
      match m with
      | O => false
      | S m' => leb n' m'
      end
  end.

Example test_leb1:                leb 2 2 = true.
Proof. simpl. reflexivity.  Qed.
Example test_leb2:                leb 2 4 = true.
Proof. simpl. reflexivity.  Qed.
Example test_leb3:                leb 4 2 = false.
Proof. simpl. reflexivity.  Qed.

(** We'll be using these (especially [eqb]) a lot, so let's give
    them infix notations. *)

Notation "x =? y" := (eqb x y) (at level 70) : nat_scope.
Notation "x <=? y" := (leb x y) (at level 70) : nat_scope.

Example test_leb3': (4 <=? 2) = false.
Proof. simpl. reflexivity.  Qed.

(** We now have two symbols that both look like equality: [=]
    and [=?].  We'll have much more to say about their differences and
    similarities later. For now, the main thing to notice is that
    [x = y] is a logical _claim_ -- a "proposition" -- that we can try to
    prove, while [x =? y] is a boolean _expression_ whose value (either
    [true] or [false]) we can compute. *)

(** **** Exercise: 1 star, standard (ltb)

    The [ltb] function tests natural numbers for [l]ess-[t]han,
    yielding a [b]oolean.  Instead of making up a new [Fixpoint] for
    this one, define it in terms of a previously defined
    function.  (It can be done with just one previously defined
    function, but you can use two if you want.) *)

Definition ltb (n m : nat) : bool
  (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.

Notation "x <? y" := (ltb x y) (at level 70) : nat_scope.

Example test_ltb1:             (ltb 2 2) = false.
(* FILL IN HERE *) Admitted.
Example test_ltb2:             (ltb 2 4) = true.
(* FILL IN HERE *) Admitted.
Example test_ltb3:             (ltb 4 2) = false.
(* FILL IN HERE *) Admitted.
(** [] *)

(* ################################################################# *)
(** * Proof by Simplification *)

(** Now that we've looked at a few datatypes and functions,
    let's turn to stating and proving properties of their behavior.

    Actually, we've already started doing this: each [Example] in the
    previous sections made a precise claim about the behavior of some
    function on some particular inputs.  The proofs of these claims
    were always the same: use [simpl] to simplify both sides of the
    equation, then use [reflexivity] to check that both sides contain
    identical values.

    The same sort of "proof by simplification" can be used to
    establish more interesting properties as well.  For example, the
    fact that [0] is a "neutral element" for [+] on the left can be
    proved just by observing that [0 + n] reduces to [n] no matter
    what [n] is -- a fact that can be read off directly from the
    definition of [plus]. *)

Theorem plus_O_n : forall n : nat, 0 + n = n.
Proof.
  intros n. simpl. reflexivity.  Qed.

(** (You may notice that the above statement looks different if
    you look at the [.v] file in your IDE than it does if you view the
    HTML rendition in your browser. In [.v] files, we write the
    universal quantifier [forall] using the reserved identifier
    "forall."  When the [.v] files are converted to HTML, this gets
    transformed into the standard upside-down-A symbol.)

    This is a good place to mention that [reflexivity] is a bit more
    powerful than we have acknowledged. In the examples we have seen,
    the calls to [simpl] were actually not required because
    [reflexivity] will do some simplification automatically when
    checking that two sides are equal; [simpl] was just added so that
    we could see the intermediate state, after simplification but
    before finishing the proof.  Here is a shorter proof: *)

Theorem plus_O_n' : forall n : nat, 0 + n = n.
Proof.
  intros n. reflexivity. Qed.

(** Moreover, it will be useful to know that [reflexivity] does
    somewhat _more_ simplification than [simpl] does -- for example,
    it tries "unfolding" defined terms, replacing them with their
    right-hand sides.  The reason for this difference is that, if
    reflexivity succeeds, the whole goal is finished and we don't need
    to look at whatever expanded expressions [reflexivity] has created
    by all this simplification and unfolding; by contrast, [simpl] is
    used in situations where we may have to read and understand the
    new goal that it creates, so we would not want it blindly
    expanding definitions and leaving the goal in a messy state.

    The form of the theorem we just stated and its proof are almost
    exactly the same as the simpler examples we saw earlier; there are
    just a few differences.

    First, we've used the keyword [Theorem] instead of [Example].
    This difference is mostly a matter of style; the keywords
    [Example] and [Theorem] (and a few others, including [Lemma],
    [Fact], and [Remark]) mean pretty much the same thing to Coq.

    Second, we've added the quantifier [forall n:nat], so that our
    theorem talks about _all_ natural numbers [n].  Informally, to
    prove theorems of this form, we generally start by saying "Suppose
    [n] is some number..."  Formally, this is achieved in the proof by
    [intros n], which moves [n] from the quantifier in the goal to a
    _context_ of current assumptions.

    Incidentally, we could have used another identifier instead of [n]
    in the [intros] clause, (though of course this might be confusing
    to human readers of the proof): *)

Theorem plus_O_n'' : forall n : nat, 0 + n = n.
Proof.
  intros m. reflexivity. Qed.

(** The keywords [intros], [simpl], and [reflexivity] are
    examples of _tactics_.  A tactic is a command that is used between
    [Proof] and [Qed] to guide the process of checking some claim we
    are making.  We will see several more tactics in the rest of this
    chapter and many more in future chapters. *)

(** Other similar theorems can be proved with the same pattern. *)

Theorem plus_1_l : forall n:nat, 1 + n = S n.
Proof.
  intros n. reflexivity.  Qed.

Theorem mult_0_l : forall n:nat, 0 * n = 0.
Proof.
  intros n. reflexivity.  Qed.

(** The [_l] suffix in the names of these theorems is
    pronounced "on the left." *)

(** It is worth stepping through these proofs to observe how the
    context and the goal change.  You may want to add calls to [simpl]
    before [reflexivity] to see the simplifications that Coq performs
    on the terms before checking that they are equal. *)

(* ################################################################# *)
(** * Proof by Rewriting *)

(** The following theorem is a bit more interesting than the
    ones we've seen: *)

Theorem plus_id_example : forall n m:nat,
  n = m ->
  n + n = m + m.

(** Instead of making a universal claim about all numbers [n] and [m],
    it talks about a more specialized property that only holds when
    [n = m].  The arrow symbol is pronounced "implies."

    As before, we need to be able to reason by assuming we are given such
    numbers [n] and [m].  We also need to assume the hypothesis
    [n = m]. The [intros] tactic will serve to move all three of these
    from the goal into assumptions in the current context.

    Since [n] and [m] are arbitrary numbers, we can't just use
    simplification to prove this theorem.  Instead, we prove it by
    observing that, if we are assuming [n = m], then we can replace
    [n] with [m] in the goal statement and obtain an equality with the
    same expression on both sides.  The tactic that tells Coq to
    perform this replacement is called [rewrite]. *)

Proof.
  (* move both quantifiers into the context: *)
  intros n m.
  (* move the hypothesis into the context: *)
  intros H.
  (* rewrite the goal using the hypothesis: *)
  rewrite -> H.
  reflexivity.  Qed.

(** The first line of the proof moves the universally quantified
    variables [n] and [m] into the context.  The second moves the
    hypothesis [n = m] into the context and gives it the name [H].
    The third tells Coq to rewrite the current goal ([n + n = m + m])
    by replacing the left side of the equality hypothesis [H] with the
    right side.

    (The arrow symbol in the [rewrite] has nothing to do with
    implication: it tells Coq to apply the rewrite from left to right.
    In fact, we can omit the arrow, and Coq will default to rewriting
    left to right.  To rewrite from right to left, use [rewrite <-].
    Try making this change in the above proof and see what changes.) *)
(** **** Exercise: 1 star, standard (plus_id_exercise)

    Remove "[Admitted.]" and fill in the proof.  (Note that the
    theorem has _two_ hypotheses -- [n = m] and [m = o] -- each to the
    left of an implication arrow.) *)

Theorem plus_id_exercise : forall n m o : nat,
  n = m -> m = o -> n + m = m + o.
Proof.
  (* FILL IN HERE *) Admitted.
(** [] *)

(** The [Admitted] command tells Coq that we want to skip trying
    to prove this theorem and just accept it as a given.  This is
    often useful for developing longer proofs: we can state subsidiary
    lemmas that we believe will be useful for making some larger
    argument, use [Admitted] to accept them on faith for the moment,
    and continue working on the main argument until we are sure it
    makes sense; then we can go back and fill in the proofs we
    skipped.

    Be careful, though: every time you say [Admitted] you are leaving
    a door open for total nonsense to enter Coq's nice, rigorous,
    formally checked world! *)

(** The [Check] command can also be used to examine the statements of
    previously declared lemmas and theorems.  The two examples below
    are lemmas about multiplication that are proved in the standard
    library.  (We will see how to prove them ourselves in the next
    chapter.) *)

Check mult_n_O.
(* ===> forall n : nat, 0 = n * 0 *)

Check mult_n_Sm.
(* ===> forall n m : nat, n * m + n = n * S m *)

(** We can use the [rewrite] tactic with a previously proved theorem
    instead of a hypothesis from the context. If the statement of the
    previously proved theorem involves quantified variables, as in the
    example below, Coq will try to fill in appropriate values for them
    by matching the body of the previous theorem statement against the
    current goal. *)

Theorem mult_n_0_m_0 : forall p q : nat,
  (p * 0) + (q * 0) = 0.
Proof.
  intros p q.
  rewrite <- mult_n_O.
  rewrite <- mult_n_O.
  reflexivity. Qed.

(** **** Exercise: 1 star, standard (mult_n_1)

    Use [mult_n_Sm] and [mult_n_0] to prove the following
    theorem.  (Recall that [1] is [S O].) *)

Theorem mult_n_1 : forall p : nat,
  p * 1 = p.
Proof.
  (* FILL IN HERE *) Admitted.

(** [] *)

(* ################################################################# *)
(** * Proof by Case Analysis *)

(** Of course, not everything can be proved by simple
    calculation and rewriting: In general, unknown, hypothetical
    values (arbitrary numbers, booleans, lists, etc.) can block
    simplification.  For example, if we try to prove the following
    fact using the [simpl] tactic as above, we get stuck.  (We then
    use the [Abort] command to give up on it for the moment.)*)

Theorem plus_1_neq_0_firsttry : forall n : nat,
  (n + 1) =? 0 = false.
Proof.
  intros n.
  simpl.  (* does nothing! *)
Abort.

(** The reason for this is that the definitions of both [eqb]
    and [+] begin by performing a [match] on their first argument.
    Here, the first argument to [+] is the unknown number [n] and the
    argument to [eqb] is the compound expression [n + 1]; neither can
    be simplified.

    To make progress, we need to consider the possible forms of [n]
    separately.  If [n] is [O], then we can calculate the final result
    of [(n + 1) =? 0] and check that it is, indeed, [false].  And if
    [n = S n'] for some [n'], then -- although we don't know exactly
    what number [n + 1] represents -- we can calculate that at least
    it will begin with one [S]; and this is enough to calculate that,
    again, [(n + 1) =? 0] will yield [false].

    The tactic that tells Coq to consider, separately, the cases where
    [n = O] and where [n = S n'] is called [destruct]. *)

Theorem plus_1_neq_0 : forall n : nat,
  (n + 1) =? 0 = false.
Proof.
  intros n. destruct n as [| n'] eqn:E.
  - reflexivity.
  - reflexivity.   Qed.

(** The [destruct] generates _two_ subgoals, which we must then
    prove, separately, in order to get Coq to accept the theorem.

    The annotation "[as [| n']]" is called an _intro pattern_.  It
    tells Coq what variable names to introduce in each subgoal.  In
    general, what goes between the square brackets is a _list of
    lists_ of names, separated by [|].  In this case, the first
    component is empty, since the [O] constructor doesn't take any
    arguments.  The second component gives a single name, [n'], since
    [S] is a unary constructor.

    In each subgoal, Coq remembers the assumption about [n] that is
    relevant for this subgoal -- either [n = 0] or [n = S n'] for some
    n'.  The [eqn:E] annotation tells [destruct] to give the name [E]
    to this equation.  (Leaving off the [eqn:E] annotation causes Coq
    to elide these assumptions in the subgoals.  This slightly
    streamlines proofs where the assumptions are not explicitly used,
    but it is better practice to keep them for the sake of
    documentation, as they can help keep you oriented when working
    with the subgoals.)

    The [-] signs on the second and third lines are called _bullets_,
    and they mark the parts of the proof that correspond to the two
    generated subgoals.  The part of the proof script that comes after
    a bullet is the entire proof for the corresponding subgoal.  In
    this example, each of the subgoals is easily proved by a single
    use of [reflexivity], which itself performs some simplification --
    e.g., the second one simplifies [(S n' + 1) =? 0] to [false] by
    first rewriting [(S n' + 1)] to [S (n' + 1)], then unfolding
    [eqb], and then simplifying the [match].

    Marking cases with bullets is optional: if bullets are not
    present, Coq simply expects you to prove each subgoal in sequence,
    one at a time. But it is a good idea to use bullets.  For one
    thing, they make the structure of a proof apparent, improving
    readability. Moreover, bullets instruct Coq to ensure that a
    subgoal is complete before trying to verify the next one,
    preventing proofs for different subgoals from getting mixed
    up. These issues become especially important in larger
    developments, where fragile proofs can lead to long debugging
    sessions!

    There are no hard and fast rules for how proofs should be
    formatted in Coq -- e.g., where lines should be broken and how
    sections of the proof should be indented to indicate their nested
    structure.  However, if the places where multiple subgoals are
    generated are marked with explicit bullets at the beginning of
    lines, then the proof will be readable almost no matter what
    choices are made about other aspects of layout.

    This is also a good place to mention one other piece of somewhat
    obvious advice about line lengths.  Beginning Coq users sometimes
    tend to the extremes, either writing each tactic on its own line
    or writing entire proofs on a single line.  Good style lies
    somewhere in the middle.  One reasonable guideline is to limit
    yourself to 80- (or, if you have a wide screen or good eyes,
    120-) character lines.

    The [destruct] tactic can be used with any inductively defined
    datatype.  For example, we use it next to prove that boolean
    negation is involutive -- i.e., that negation is its own
    inverse. *)

Theorem negb_involutive : forall b : bool,
  negb (negb b) = b.
Proof.
  intros b. destruct b eqn:E.
  - reflexivity.
  - reflexivity.  Qed.

(** Note that the [destruct] here has no [as] clause because
    none of the subcases of the [destruct] need to bind any variables,
    so there is no need to specify any names.  In fact, we can omit
    the [as] clause from _any_ [destruct] and Coq will fill in
    variable names automatically.  This is generally considered bad
    style, since Coq often makes confusing choices of names when left
    to its own devices.

    It is sometimes useful to invoke [destruct] inside a subgoal,
    generating yet more proof obligations. In this case, we use
    different kinds of bullets to mark goals on different "levels."
    For example: *)

Theorem andb_commutative : forall b c, andb b c = andb c b.
Proof.
  intros b c. destruct b eqn:Eb.
  - destruct c eqn:Ec.
    + reflexivity.
    + reflexivity.
  - destruct c eqn:Ec.
    + reflexivity.
    + reflexivity.
Qed.

(** Each pair of calls to [reflexivity] corresponds to the
    subgoals that were generated after the execution of the [destruct c]
    line right above it. *)

(** Besides [-] and [+], we can use [*] (asterisk) or any repetition
    of a bullet symbol (e.g. [--] or [***]) as a bullet.  We can also
    enclose sub-proofs in curly braces: *)

Theorem andb_commutative' : forall b c, andb b c = andb c b.
Proof.
  intros b c. destruct b eqn:Eb.
  { destruct c eqn:Ec.
    { reflexivity. }
    { reflexivity. } }
  { destruct c eqn:Ec.
    { reflexivity. }
    { reflexivity. } }
Qed.

(** Since curly braces mark both the beginning and the end of a proof,
    they can be used for multiple subgoal levels, as this example
    shows. Furthermore, curly braces allow us to reuse the same bullet
    shapes at multiple levels in a proof. The choice of braces,
    bullets, or a combination of the two is purely a matter of
    taste. *)

Theorem andb3_exchange :
  forall b c d, andb (andb b c) d = andb (andb b d) c.
Proof.
  intros b c d. destruct b eqn:Eb.
  - destruct c eqn:Ec.
    { destruct d eqn:Ed.
      - reflexivity.
      - reflexivity. }
    { destruct d eqn:Ed.
      - reflexivity.
      - reflexivity. }
  - destruct c eqn:Ec.
    { destruct d eqn:Ed.
      - reflexivity.
      - reflexivity. }
    { destruct d eqn:Ed.
      - reflexivity.
      - reflexivity. }
Qed.

(** **** Exercise: 2 stars, standard (andb_true_elim2)

    Prove the following claim, marking cases (and subcases) with
    bullets when you use [destruct].

    Hint: You will eventually need to destruct both booleans, as in
    the theorems above. But its best to delay introducing the
    hypothesis until after you have an opportunity to simplify it.

    Hint 2: When you reach a contradiction in the hypotheses, focus on
    how to [rewrite] with that contradiction. *)

Theorem andb_true_elim2 : forall b c : bool,
  andb b c = true -> c = true.
Proof.
  (* FILL IN HERE *) Admitted.
(** [] *)

(** Before closing the chapter, let's mention one final
    convenience.  As you may have noticed, many proofs perform case
    analysis on a variable right after introducing it:

       intros x y. destruct y as [|y] eqn:E.

    This pattern is so common that Coq provides a shorthand for it: we
    can perform case analysis on a variable when introducing it by
    using an intro pattern instead of a variable name. For instance,
    here is a shorter proof of the [plus_1_neq_0] theorem
    above.  (You'll also note one downside of this shorthand: we lose
    the equation recording the assumption we are making in each
    subgoal, which we previously got from the [eqn:E] annotation.) *)

Theorem plus_1_neq_0' : forall n : nat,
  (n + 1) =? 0 = false.
Proof.
  intros [|n].
  - reflexivity.
  - reflexivity.  Qed.

(** If there are no constructor arguments that need names, we can just
    write [[]] to get the case analysis. *)

Theorem andb_commutative'' :
  forall b c, andb b c = andb c b.
Proof.
  intros [] [].
  - reflexivity.
  - reflexivity.
  - reflexivity.
  - reflexivity.
Qed.

(** **** Exercise: 1 star, standard (zero_nbeq_plus_1) *)
Theorem zero_nbeq_plus_1 : forall n : nat,
  0 =? (n + 1) = false.
Proof.
  (* FILL IN HERE *) Admitted.
(** [] *)

(* ================================================================= *)
(** ** More on Notation (Optional) *)

(** (In general, sections marked Optional are not needed to follow the
    rest of the book, except possibly other Optional sections.  On a
    first reading, you might want to just skim these sections so that
    you know what's there for future reference.)

    Recall the notation definitions for infix plus and times: *)

Notation "x + y" := (plus x y)
                       (at level 50, left associativity)
                       : nat_scope.
Notation "x * y" := (mult x y)
                       (at level 40, left associativity)
                       : nat_scope.

(** For each notation symbol in Coq, we can specify its _precedence
    level_ and its _associativity_.  The precedence level [n] is
    specified by writing [at level n]; this helps Coq parse compound
    expressions.  The associativity setting helps to disambiguate
    expressions containing multiple occurrences of the same
    symbol. For example, the parameters specified above for [+] and
    [*] say that the expression [1+2*3*4] is shorthand for
    [(1+((2*3)*4))]. Coq uses precedence levels from 0 to 100, and
    _left_, _right_, or _no_ associativity.  We will see more examples
    of this later, e.g., in the [Lists] chapter.

    Each notation symbol is also associated with a _notation scope_.
    Coq tries to guess what scope is meant from context, so when it
    sees [S (O*O)] it guesses [nat_scope], but when it sees the pair
    type type [bool*bool] (which we'll see in a later chapter) it
    guesses [type_scope].  Occasionally, it is necessary to help it
    out by writing, for example, [(x*y)%nat], and sometimes in what
    Coq prints it will use [%nat] to indicate what scope a notation is
    in.

    Notation scopes also apply to numeral notations ([3], [4], [5],
    [42], etc.), so you may sometimes see [0%nat], which means
    [O] (the natural number [0] that we're using in this chapter), or
    [0%Z], which means the integer zero (which comes from a different
    part of the standard library).

    Pro tip: Coq's notation mechanism is not especially powerful.
    Don't expect too much from it. *)

(* ================================================================= *)
(** ** Fixpoints and Structural Recursion (Optional) *)

(** Here is a copy of the definition of addition: *)

Fixpoint plus' (n : nat) (m : nat) : nat :=
  match n with
  | O => m
  | S n' => S (plus' n' m)
  end.

(** When Coq checks this definition, it notes that [plus'] is
    "decreasing on 1st argument."  What this means is that we are
    performing a _structural recursion_ over the argument [n] -- i.e.,
    that we make recursive calls only on strictly smaller values of
    [n].  This implies that all calls to [plus'] will eventually
    terminate.  Coq demands that some argument of _every_ [Fixpoint]
    definition be "decreasing."

    This requirement is a fundamental feature of Coq's design: In
    particular, it guarantees that every function that can be defined
    in Coq will terminate on all inputs.  However, because Coq's
    "decreasing analysis" is not very sophisticated, it is sometimes
    necessary to write functions in slightly unnatural ways. *)

(** **** Exercise: 2 stars, standard, optional (decreasing)

    To get a concrete sense of this, find a way to write a sensible
    [Fixpoint] definition (of a simple function on numbers, say) that
    _does_ terminate on all inputs, but that Coq will reject because
    of this restriction.

    (If you choose to turn in this optional exercise as part of a
    homework assignment, make sure you comment out your solution so
    that it doesn't cause Coq to reject the whole file!) *)

(* FILL IN HERE

    [] *)

(* ################################################################# *)
(** * More Exercises *)

(* ================================================================= *)
(** ** Warmups *)

(** **** Exercise: 1 star, standard (identity_fn_applied_twice)

    Use the tactics you have learned so far to prove the following
    theorem about boolean functions. *)

Theorem identity_fn_applied_twice :
  forall (f : bool -> bool),
  (forall (x : bool), f x = x) ->
  forall (b : bool), f (f b) = b.
Proof.
  (* FILL IN HERE *) Admitted.

(** [] *)

(** **** Exercise: 1 star, standard (negation_fn_applied_twice)

    Now state and prove a theorem [negation_fn_applied_twice] similar
    to the previous one but where the second hypothesis says that the
    function [f] has the property that [f x = negb x]. *)

(* FILL IN HERE *)

(* Do not modify the following line: *)
Definition manual_grade_for_negation_fn_applied_twice : option (nat*string) := None.
(** (The last definition is used by the autograder.)

    [] *)

(** **** Exercise: 3 stars, standard, optional (andb_eq_orb)

    Prove the following theorem.  (Hint: This can be a bit tricky,
    depending on how you approach it.  You will probably need both
    [destruct] and [rewrite], but destructing everything in sight is
    not the best way.) *)

Theorem andb_eq_orb :
  forall (b c : bool),
  (andb b c = orb b c) ->
  b = c.
Proof.
  (* FILL IN HERE *) Admitted.

(** [] *)

(* ================================================================= *)
(** ** Course Late Policies, Formalized *)

(** Suppose that a course has a grading policy based on late days,
    where a student's final letter grade is lowered if they submit too
    many homework assignments late.

    In the next series of problems, we model this situation using the
    features of Coq that we have seen so far and prove some simple
    facts about this grading policy.  *)

Module LateDays.

(** First, we inroduce a datatype for modeling the "letter" component
    of a grade. *)
Inductive letter : Type :=
  | A | B | C | D | F.

(** Then we define the modifiers -- a [Natural] [A] is just a "plain"
    grade of [A]. *)
Inductive modifier : Type :=
  | Plus | Natural | Minus.

(** A full [grade], then, is just a [letter] and a [modifier].

    We might write, informally, "A-" for the Coq value [Grade A Minus],
    and similarly "C" for the Coq value [Grade C Natural]. *)
Inductive grade : Type :=
  Grade (l:letter) (m:modifier).

(** We will want to be able to say when one grade is "better" than
    another.  In other words, we need a way to compare two grades.  As
    with natural numbers, we could define [bool]-valued functions
    [grade_eqb], [grade_ltb], etc., and that would work fine.
    However, we can also define a slightly more informative type for
    comparing two values, as shown below.  This datatype has three
    constructors that can be used to indicate whether two values are
    "equal", "less than", or "greater than" one another. (This
    definition also appears in the Coq standard libary.)  *)

Inductive comparison : Type :=
  | Eq         (* "equal" *)
  | Lt         (* "less than" *)
  | Gt.        (* "greater than" *)

(** Using pattern matching, it is not difficult to define the
    comparison operation for two letters [l1] and [l2] (see below).
    This definition uses two features of [match] patterns: First,
    recall that we can match against _two_ values simultaneously by
    separating them and the corresponding patterns with comma [,].
    This is simply a convenient abbreviation for nested pattern
    matching.  For example, the match expression on the left below is
    just shorthand for the lower-level "expanded version" shown on the
    right:

  match l1, l2 with          match l1 with
  | A, A => Eq               | A => match l2 with
  | A, _ => Gt                      | A => Eq
  end                               | _ => Gt
                                    end
                             end
*)
(** As another shorthand, we can also match one of several
    possibilites by using [|] in the pattern.  For example the pattern
    [C , (A | B)] stands for two cases: [C, A] and [C, B]. *)

Definition letter_comparison (l1 l2 : letter) : comparison :=
  match l1, l2 with
  | A, A => Eq
  | A, _ => Gt
  | B, A => Lt
  | B, B => Eq
  | B, _ => Gt
  | C, (A | B) => Lt
  | C, C => Eq
  | C, _ => Gt
  | D, (A | B | C) => Lt
  | D, D => Eq
  | D, _ => Gt
  | F, (A | B | C | D) => Lt
  | F, F => Eq
  end.

(** We can test the [letter_comparison] operation by trying it out on a few
    examples. *)
Compute letter_comparison B A.
(** ==> Lt *)
Compute letter_comparison D D.
(** ==> Eq *)
Compute letter_comparison B F.
(** ==> Gt *)

(** As a further sanity check, we can prove that the
    [letter_comparison] function does indeed give the result [Eq] when
    comparing a letter [l] against itself.  *)
(** **** Exercise: 1 star, standard (letter_comparison) *)
Theorem letter_comparison_Eq :
  forall l, letter_comparison l l = Eq.
Proof.
  (* FILL IN HERE *) Admitted.
(** [] *)

(** We can follow the same strategy to define the comparison operation
    for two grade modifiers.  We consider them to be ordered as
    [Plus > Natural > Minus]. *)
Definition modifier_comparison (m1 m2 : modifier) : comparison :=
  match m1, m2 with
  | Plus, Plus => Eq
  | Plus, _ => Gt
  | Natural, Plus => Lt
  | Natural, Natural => Eq
  | Natural, _ => Gt
  | Minus, (Plus | Natural) => Lt
  | Minus, Minus => Eq
  end.

(** **** Exercise: 2 stars, standard (grade_comparison)

    Use pattern matching to complete the following definition.

    (This ordering on grades is sometimes called "lexicographic"
    ordering: we first compare the letters, and we only consider the
    modifiers in the case that the letters are equal.  I.e. all grade
    variants of [A] are greater than all grade variants of [B].)

    Hint: match against [g1] and [g2] simultaneously, but don't try to
    enumerate all the cases.  Instead do case analysis on the result
    of a suitable call to [letter_comparison] to end up with just [3]
    possibilities. *)

Definition grade_comparison (g1 g2 : grade) : comparison
  (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.

(** The following "unit tests" of your [grade_comparison] function
    should pass once you have defined it correctly. *)

Example test_grade_comparison1 :
  (grade_comparison (Grade A Minus) (Grade B Plus)) = Gt.
(* FILL IN HERE *) Admitted.

Example test_grade_comparison2 :
  (grade_comparison (Grade A Minus) (Grade A Plus)) = Lt.
(* FILL IN HERE *) Admitted.

Example test_grade_comparison3 :
  (grade_comparison (Grade F Plus) (Grade F Plus)) = Eq.
(* FILL IN HERE *) Admitted.

Example test_grade_comparison4 :
  (grade_comparison (Grade B Minus) (Grade C Plus)) = Gt.
(* FILL IN HERE *) Admitted.

(** [] *)

(** Now that we have a definition of grades and how they compare to
    one another, let us implement a late-penalty fuction. *)

(** First, we define what it means to lower the [letter] component of
    a grade.  Since [F] is already the lowest grade possible, we just
    leave it alone.  *)
Definition lower_letter (l : letter) : letter :=
  match l with
  | A => B
  | B => C
  | C => D
  | D => F
  | F => F  (* Can't go lower than [F]! *)
  end.

(** Our formalization can already help us understand some corner cases
    of the grading policy.  For example, we might expect that if we
    use the [lower_letter] function its result will actually be lower,
    as claimed in the following theorem.  But this theorem is not
    provable!  (Do you see why?) *)
Theorem lower_letter_lowers: forall (l : letter),
  letter_comparison (lower_letter l) l = Lt.
Proof.
  intros l.
  destruct l.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. (* We get stuck here. *)
Abort.

(** The problem, of course, has to do with the "edge case" of lowering
    [F], as we can see like this: *)
Theorem lower_letter_F_is_F:
  lower_letter F = F.
Proof.
  simpl. reflexivity.
Qed.

(** With this insight, we can state a better version of the lower
    letter theorem that actually is provable.  In this version, the
    hypothesis about [F] says that [F] is strictly smaller than [l],
    which rules out the problematic case above. In other words, as
    long as [l] is bigger than [F], it will be lowered. *)
(** **** Exercise: 2 stars, standard (lower_letter_lowers)

    Prove the following theorem. *)

Theorem lower_letter_lowers:
  forall (l : letter),
    letter_comparison F l = Lt ->
    letter_comparison (lower_letter l) l = Lt.
Proof.
(* FILL IN HERE *) Admitted.

(** [] *)

(** **** Exercise: 2 stars, standard (lower_grade)

    We can now use the [lower_letter] definition as a helper to define
    what it means to lower a grade by one step.  Complete the
    definition below so that it sends a grade [g] to one step lower
    (unless it is already [Grade F Minus], which should remain
    unchanged).  Once you have implemented it correctly, the subsequent
    "unit test" examples should hold trivially.

    Hint: To make this a succinct definition that is easy to prove
    properties about, you will probably want to use nested pattern
    matching. The outer match should not match on the specific letter
    component of the grade -- it should consider only the modifier.
    You should definitely _not_ try to enumerate all of the
    cases.

    Our solution is under 10 lines of code total. *)
Definition lower_grade (g : grade) : grade
  (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.

Example lower_grade_A_Plus :
  lower_grade (Grade A Plus) = (Grade A Natural).
Proof.
(* FILL IN HERE *) Admitted.

Example lower_grade_A_Natural :
  lower_grade (Grade A Natural) = (Grade A Minus).
Proof.
(* FILL IN HERE *) Admitted.

Example lower_grade_A_Minus :
  lower_grade (Grade A Minus) = (Grade B Plus).
Proof.
(* FILL IN HERE *) Admitted.

Example lower_grade_B_Plus :
  lower_grade (Grade B Plus) = (Grade B Natural).
Proof.
(* FILL IN HERE *) Admitted.

Example lower_grade_F_Natural :
  lower_grade (Grade F Natural) = (Grade F Minus).
Proof.
(* FILL IN HERE *) Admitted.

Example lower_grade_twice :
  lower_grade (lower_grade (Grade B Minus)) = (Grade C Natural).
Proof.
(* FILL IN HERE *) Admitted.

Example lower_grade_thrice :
  lower_grade (lower_grade (lower_grade (Grade B Minus))) = (Grade C Minus).
Proof.
(* FILL IN HERE *) Admitted.

(** Coq makes no distinction between an [Example] and a [Theorem]. We
    state the following as a [Theorem] only as a hint that we will use
    it in proofs below. *)
Theorem lower_grade_F_Minus : lower_grade (Grade F Minus) = (Grade F Minus).
Proof.
(* FILL IN HERE *) Admitted.

(* GRADE_THEOREM 0.25: lower_grade_A_Plus *)
(* GRADE_THEOREM 0.25: lower_grade_A_Natural *)
(* GRADE_THEOREM 0.25: lower_grade_A_Minus *)
(* GRADE_THEOREM 0.25: lower_grade_B_Plus *)
(* GRADE_THEOREM 0.25: lower_grade_F_Natural *)
(* GRADE_THEOREM 0.25: lower_grade_twice *)
(* GRADE_THEOREM 0.25: lower_grade_thrice *)
(* GRADE_THEOREM 0.25: lower_grade_F_Minus

    [] *)

(** **** Exercise: 3 stars, standard (lower_grade_lowers)

    Prove the following theorem, which says that, as long as the grade
    starts out above F-, the [lower_grade] option does indeed lower
    the grade.  As usual, destructing everything in sight is _not_ a
    good idea.  Judicious use of [destruct] along with rewriting is a
    better strategy.

    Hint: If you defined your [grade_comparison] function as
    suggested, you will need to rewrite using [letter_comparison_Eq]
    in two cases.  The remaining case is the only one in which you
    need to destruct a [letter].  The case for [F] will probably
    benefit from [lower_grade_F_Minus].  *)
Theorem lower_grade_lowers :
  forall (g : grade),
    grade_comparison (Grade F Minus) g = Lt ->
    grade_comparison (lower_grade g) g = Lt.
Proof.
  (* FILL IN HERE *) Admitted.

(** [] *)

(** Now that we have implemented and tested a function that lowers a
    grade by one step, we can implement a specific late-days policy.
    Given a number of [late_days], the [apply_late_policy] function
    computes the final grade from [g], the initial grade.

    This function encodes the following policy:

      # late days     penalty
         0 - 8        no penalty
         9 - 16       lower grade by one step (A+ => A, A => A-, A- => B+, etc.)
        17 - 20       lower grade by two steps
          >= 21       lower grade by three steps (a whole letter)
*)
Definition apply_late_policy (late_days : nat) (g : grade) : grade :=
  if late_days <? 9 then g
  else if late_days <? 17 then lower_grade g
  else if late_days <? 21 then lower_grade (lower_grade g)
  else lower_grade (lower_grade (lower_grade g)).

(** Sometimes it is useful to be able to "unfold" a definition to be
    able to make progress on a proof.  Soon, we will see how to do this
    in a much simpler way automatically, but for now, it is easy to prove
    that a use of any definition like [apply_late_policy] is equal to its
    right hand side just by using reflexivity.

    This result is useful because it allows us to use [rewrite] to
    expose the internals of the definition. *)
Theorem apply_late_policy_unfold :
  forall (late_days : nat) (g : grade),
    (apply_late_policy late_days g)
    =
    (if late_days <? 9 then g  else
       if late_days <? 17 then lower_grade g
       else if late_days <? 21 then lower_grade (lower_grade g)
            else lower_grade (lower_grade (lower_grade g))).
Proof.
  intros. reflexivity.
Qed.

(** Now let's prove some properties about this policy. *)

(** The next theorem states that if a student accrues no more than eight
    late days throughout the semester, their grade is unaffected. It
    is easy to prove: once you use the [apply_late_policy_unfold] you
    can rewrite using the hypothesis. *)

(** **** Exercise: 2 stars, standard (no_penalty_for_mostly_on_time) *)
Theorem no_penalty_for_mostly_on_time :
  forall (late_days : nat) (g : grade),
    (late_days <? 9 = true) ->
    apply_late_policy late_days g = g.
Proof.
  (* FILL IN HERE *) Admitted.

(** [] *)

(** The following theorem states that, if a student has between 9 and
    16 late days, their final grade is lowered by one step. *)

(** **** Exercise: 2 stars, standard (graded_lowered_once) *)
Theorem grade_lowered_once :
  forall (late_days : nat) (g : grade),
    (late_days <? 9 = false) ->
    (late_days <? 17 = true) ->
    (apply_late_policy late_days g) = (lower_grade g).
Proof.
  (* FILL IN HERE *) Admitted.

(** [] *)
End LateDays.

(* ================================================================= *)
(** ** Binary Numerals *)

(** **** Exercise: 3 stars, standard (binary)

    We can generalize our unary representation of natural numbers to
    the more efficient binary representation by treating a binary
    number as a sequence of constructors [B0] and [B1] (representing 0s
    and 1s), terminated by a [Z]. For comparison, in the unary
    representation, a number is a sequence of [S] constructors terminated
    by an [O].

    For example:

        decimal               binary                          unary
           0                       Z                              O
           1                    B1 Z                            S O
           2                B0 (B1 Z)                        S (S O)
           3                B1 (B1 Z)                     S (S (S O))
           4            B0 (B0 (B1 Z))                 S (S (S (S O)))
           5            B1 (B0 (B1 Z))              S (S (S (S (S O))))
           6            B0 (B1 (B1 Z))           S (S (S (S (S (S O)))))
           7            B1 (B1 (B1 Z))        S (S (S (S (S (S (S O))))))
           8        B0 (B0 (B0 (B1 Z)))    S (S (S (S (S (S (S (S O)))))))

    Note that the low-order bit is on the left and the high-order bit
    is on the right -- the opposite of the way binary numbers are
    usually written.  This choice makes them easier to manipulate.

    (Comprehension check: What unary numeral does [B0 Z] represent?) *)

Inductive bin : Type :=
  | Z
  | B0 (n : bin)
  | B1 (n : bin).

(** Complete the definitions below of an increment function [incr]
    for binary numbers, and a function [bin_to_nat] to convert
    binary numbers to unary numbers. *)

Fixpoint incr (m:bin) : bin
  (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.

Fixpoint bin_to_nat (m:bin) : nat
  (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.

(** The following "unit tests" of your increment and binary-to-unary
    functions should pass after you have defined those functions correctly.
    Of course, unit tests don't fully demonstrate the correctness of
    your functions!  We'll return to that thought at the end of the
    next chapter. *)

Example test_bin_incr1 : (incr (B1 Z)) = B0 (B1 Z).
(* FILL IN HERE *) Admitted.

Example test_bin_incr2 : (incr (B0 (B1 Z))) = B1 (B1 Z).
(* FILL IN HERE *) Admitted.

Example test_bin_incr3 : (incr (B1 (B1 Z))) = B0 (B0 (B1 Z)).
(* FILL IN HERE *) Admitted.

Example test_bin_incr4 : bin_to_nat (B0 (B1 Z)) = 2.
(* FILL IN HERE *) Admitted.

Example test_bin_incr5 :
        bin_to_nat (incr (B1 Z)) = 1 + bin_to_nat (B1 Z).
(* FILL IN HERE *) Admitted.

Example test_bin_incr6 :
        bin_to_nat (incr (incr (B1 Z))) = 2 + bin_to_nat (B1 Z).
(* FILL IN HERE *) Admitted.

(** [] *)

(* ################################################################# *)
(** * Optional: Testing Your Solutions *)

(** Each SF chapter comes with a test file containing scripts that
    check whether you have solved the required exercises. If you're
    using SF as part of a course, your instructor will likely be
    running these test files to autograde your solutions. You can also
    use these test files, if you like, to make sure you haven't missed
    anything.

    Important: This step is _optional_: if you've completed all the
    non-optional exercises and Coq accepts your answers, this already
    shows that you are in good shape.

    The test file for this chapter is [BasicsTest.v]. To run it, make
    sure you have saved [Basics.v] to disk.  Then first run
    [coqc -Q . LF Basics.v] and then run [coqc -Q . LF BasicsTest.v];
    or, if you have make installed, you can run [make BasicsTest.vo].
    (Make sure you do this in a directory that also contains a file
    named [_CoqProject] containing the single line [-Q . LF].)

    If you accidentally deleted an exercise or changed its name, then
    [make BasicsTest.vo] will fail with an error that tells you the
    name of the missing exercise.  Otherwise, you will get a lot of
    useful output:

    - First will be all the output produced by [Basics.v] itself.  At
      the end of that you will see [COQC BasicsTest.v].

    - Second, for each required exercise, there is a report that tells
      you its point value (the number of stars or some fraction
      thereof if there are multiple parts to the exercise), whether
      its type is ok, and what assumptions it relies upon.

      If the _type_ is not [ok], it means you proved the wrong thing:
      most likely, you accidentally modified the theorem statement
      while you were proving it.  The autograder won't give you any
      points in this case, so make sure to correct the theorem.

      The _assumptions_ are any unproved theorems which your solution
      relies upon.  "Closed under the global context" is a fancy way
      of saying "none": you have solved the exercise. (Hooray!)  On
      the other hand, a list of axioms means you haven't fully solved
      the exercise. (But see below regarding "Allowed Axioms.") If the
      exercise name itself is in the list, that means you haven't
      solved it; probably you have [Admitted] it.

    - Third, you will see the maximum number of points in standard and
      advanced versions of the assignment.  That number is based on
      the number of stars in the non-optional exercises.  (In the
      present file, there are no advanced exercises.)

    - Fourth, you will see a list of "Allowed Axioms".  These are
      unproven theorems that your solution is permitted to depend
      upon, aside from the fundamental axioms of Coq's logic.  You'll
      probably see something about [functional_extensionality] for
      this chapter; we'll cover what that means in a later chapter.

    - Finally, you will see a summary of whether you have solved each
      exercise.  Note that summary does not include the critical
      information of whether the type is ok (that is, whether you
      accidentally changed the theorem statement): you have to look
      above for that information.

    Exercises that are manually graded will also show up in the
    output.  But since they have to be graded by a human, the test
    script won't be able to tell you much about them.  *)

(** * Induction: Proof by Induction *)

(* ################################################################# *)
(** * Proof by Induction *)

(** We can prove that [0] is a neutral element for [+] on the _left_
    using just [reflexivity].  But the proof that it is also a neutral
    element on the _right_ ... *)

Theorem add_0_r_firsttry : forall n:nat,
  n + 0 = n.

(** ... can't be done in the same simple way.  Just applying
  [reflexivity] doesn't work, since the [n] in [n + 0] is an arbitrary
  unknown number, so the [match] in the definition of [+] can't be
  simplified.  *)

Proof.
  intros n.
  simpl. (* Does nothing! *)
Abort.

(** And reasoning by cases using [destruct n] doesn't get us much
    further: the branch of the case analysis where we assume [n = 0]
    goes through fine, but in the branch where [n = S n'] for some [n'] we
    get stuck in exactly the same way. *)

Theorem add_0_r_secondtry : forall n:nat,
  n + 0 = n.
Proof.
  intros n. destruct n as [| n'] eqn:E.
  - (* n = 0 *)
    reflexivity. (* so far so good... *)
  - (* n = S n' *)
    simpl.       (* ...but here we are stuck again *)
Abort.

(** We could use [destruct n'] to get one step further, but,
    since [n] can be arbitrarily large, we'll never get all the there
    if we just go on like this. *)

(** To prove interesting facts about numbers, lists, and other
    inductively defined sets, we often need a more powerful reasoning
    principle: _induction_.

    Recall (from a discrete math course, probably) the _principle of
    induction over natural numbers_: If [P(n)] is some proposition
    involving a natural number [n] and we want to show that [P] holds for
    all numbers [n], we can reason like this:
         - show that [P(O)] holds;
         - show that, for any [n'], if [P(n')] holds, then so does [P(S
           n')];
         - conclude that [P(n)] holds for all [n].

    In Coq, the steps are the same: we begin with the goal of proving
    [P(n)] for all [n] and break it down (by applying the [induction]
    tactic) into two separate subgoals: one where we must show [P(O)] and
    another where we must show [P(n') -> P(S n')].  Here's how this works
    for the theorem at hand: *)

Theorem add_0_r : forall n:nat, n + 0 = n.
Proof.
  intros n. induction n as [| n' IHn'].
  - (* n = 0 *)    reflexivity.
  - (* n = S n' *) simpl. rewrite -> IHn'. reflexivity.  Qed.

(** Like [destruct], the [induction] tactic takes an [as...]
    clause that specifies the names of the variables to be introduced
    in the subgoals.  Since there are two subgoals, the [as...] clause
    has two parts, separated by [|].  (Strictly speaking, we can omit
    the [as...] clause and Coq will choose names for us.  In practice,
    this is a bad idea, as Coq's automatic choices tend to be
    confusing.)

    In the first subgoal, [n] is replaced by [0].  No new variables
    are introduced (so the first part of the [as...] is empty), and
    the goal becomes [0 = 0 + 0], which follows by simplification.

    In the second subgoal, [n] is replaced by [S n'], and the
    assumption [n' + 0 = n'] is added to the context with the name
    [IHn'] (i.e., the Induction Hypothesis for [n']).  These two names
    are specified in the second part of the [as...] clause.  The goal
    in this case becomes [S n' = (S n') + 0], which simplifies to
    [S n' = S (n' + 0)], which in turn follows from [IHn']. *)

Theorem minus_n_n : forall n,
  minus n n = 0.
Proof.
  (* WORKED IN CLASS *)
  intros n. induction n as [| n' IHn'].
  - (* n = 0 *)
    simpl. reflexivity.
  - (* n = S n' *)
    simpl. rewrite -> IHn'. reflexivity.  Qed.

(** (The use of the [intros] tactic in these proofs is actually
    redundant.  When applied to a goal that contains quantified
    variables, the [induction] tactic will automatically move them
    into the context as needed.) *)

(** **** Exercise: 2 stars, standard, especially useful (basic_induction)

    Prove the following using induction. You might need previously
    proven results. *)

Theorem mul_0_r : forall n:nat,
  n * 0 = 0.
Proof.
  (* FILL IN HERE *) Admitted.

Theorem plus_n_Sm : forall n m : nat,
  S (n + m) = n + (S m).
Proof.
  (* FILL IN HERE *) Admitted.

Theorem add_comm : forall n m : nat,
  n + m = m + n.
Proof.
  (* FILL IN HERE *) Admitted.

Theorem add_assoc : forall n m p : nat,
  n + (m + p) = (n + m) + p.
Proof.
  (* FILL IN HERE *) Admitted.
(** [] *)

(** **** Exercise: 2 stars, standard (double_plus)

    Consider the following function, which doubles its argument: *)

Fixpoint double (n:nat) :=
  match n with
  | O => O
  | S n' => S (S (double n'))
  end.

(** Use induction to prove this simple fact about [double]: *)

Lemma double_plus : forall n, double n = n + n .
Proof.
  (* FILL IN HERE *) Admitted.
(** [] *)

(** **** Exercise: 2 stars, standard (eqb_refl)

    The following theorem relates the computational equality [=?] on
    [nat] with the definitional equality [=] on [bool]. *)
Theorem eqb_refl : forall n : nat,
  (n =? n) = true.
Proof.
  (* FILL IN HERE *) Admitted.
(** [] *)

(** **** Exercise: 2 stars, standard, optional (even_S)

    One inconvenient aspect of our definition of [even n] is the
    recursive call on [n - 2]. This makes proofs about [even n]
    harder when done by induction on [n], since we may need an
    induction hypothesis about [n - 2]. The following lemma gives an
    alternative characterization of [even (S n)] that works better
    with induction: *)

Theorem even_S : forall n : nat,
  even (S n) = negb (even n).
Proof.
  (* FILL IN HERE *) Admitted.
(** [] *)

(* ################################################################# *)
(** * Proofs Within Proofs *)

(** In Coq, as in informal mathematics, large proofs are often
    broken into a sequence of theorems, with later proofs referring to
    earlier theorems.  But sometimes a proof will involve some
    miscellaneous fact that is too trivial and of too little general
    interest to bother giving it its own top-level name.  In such
    cases, it is convenient to be able to simply state and prove the
    needed "sub-theorem" right at the point where it is used.  The
    [assert] tactic allows us to do this. *)

Theorem mult_0_plus' : forall n m : nat,
  (n + 0 + 0) * m = n * m.
Proof.
  intros n m.
  assert (H: n + 0 + 0 = n).
    { rewrite add_comm. simpl. rewrite add_comm. reflexivity. }
  rewrite -> H.
  reflexivity.  Qed.

(** The [assert] tactic introduces two sub-goals.  The first is
    the assertion itself; by prefixing it with [H:] we name the
    assertion [H].  (We can also name the assertion with [as] just as
    we did above with [destruct] and [induction], i.e., [assert (n + 0
    + 0 = n) as H].)  Note that we surround the proof of this
    assertion with curly braces [{ ... }], both for readability and so
    that, when using Coq interactively, we can see more easily when we
    have finished this sub-proof.  The second goal is the same as the
    one at the point where we invoke [assert] except that, in the
    context, we now have the assumption [H] that [n + 0 + 0 = n].
    That is, [assert] generates one subgoal where we must prove the
    asserted fact and a second subgoal where we can use the asserted
    fact to make progress on whatever we were trying to prove in the
    first place. *)

(** As another example, suppose we want to prove that [(n + m)
    + (p + q) = (m + n) + (p + q)]. The only difference between the
    two sides of the [=] is that the arguments [m] and [n] to the
    first inner [+] are swapped, so it seems we should be able to use
    the commutativity of addition ([add_comm]) to rewrite one into the
    other.  However, the [rewrite] tactic is not very smart about
    _where_ it applies the rewrite.  There are three uses of [+] here,
    and it turns out that doing [rewrite -> add_comm] will affect only
    the _outer_ one... *)

Theorem plus_rearrange_firsttry : forall n m p q : nat,
  (n + m) + (p + q) = (m + n) + (p + q).
Proof.
  intros n m p q.
  (* We just need to swap (n + m) for (m + n)... seems
     like add_comm should do the trick! *)
  rewrite add_comm.
  (* Doesn't work... Coq rewrites the wrong plus! :-( *)
Abort.

(** To use [add_comm] at the point where we need it, we can introduce
    a local lemma stating that [n + m = m + n] (for the _particular_ [m]
    and [n] that we are talking about here), prove this lemma using
    [add_comm], and then use it to do the desired rewrite. *)

Theorem plus_rearrange : forall n m p q : nat,
  (n + m) + (p + q) = (m + n) + (p + q).
Proof.
  intros n m p q.
  assert (H: n + m = m + n).
  { rewrite add_comm. reflexivity. }
  rewrite H. reflexivity.  Qed.

(* ################################################################# *)
(** * Formal vs. Informal Proof *)

(** "_Informal proofs are algorithms; formal proofs are code_." *)

(** What constitutes a successful proof of a mathematical claim?
    The question has challenged philosophers for millennia, but a
    rough and ready definition could be this: A proof of a
    mathematical proposition [P] is a written (or spoken) text that
    instills in the reader or hearer the certainty that [P] is true --
    an unassailable argument for the truth of [P].  That is, a proof
    is an act of communication.

    Acts of communication may involve different sorts of readers.  On
    one hand, the "reader" can be a program like Coq, in which case
    the "belief" that is instilled is that [P] can be mechanically
    derived from a certain set of formal logical rules, and the proof
    is a recipe that guides the program in checking this fact.  Such
    recipes are _formal_ proofs.

    Alternatively, the reader can be a human being, in which case the
    proof will be written in English or some other natural language,
    and will thus necessarily be _informal_.  Here, the criteria for
    success are less clearly specified.  A "valid" proof is one that
    makes the reader believe [P].  But the same proof may be read by
    many different readers, some of whom may be convinced by a
    particular way of phrasing the argument, while others may not be.
    Some readers may be particularly pedantic, inexperienced, or just
    plain thick-headed; the only way to convince them will be to make
    the argument in painstaking detail.  But other readers, more
    familiar in the area, may find all this detail so overwhelming
    that they lose the overall thread; all they want is to be told the
    main ideas, since it is easier for them to fill in the details for
    themselves than to wade through a written presentation of them.
    Ultimately, there is no universal standard, because there is no
    single way of writing an informal proof that is guaranteed to
    convince every conceivable reader.

    In practice, however, mathematicians have developed a rich set of
    conventions and idioms for writing about complex mathematical
    objects that -- at least within a certain community -- make
    communication fairly reliable.  The conventions of this stylized
    form of communication give a fairly clear standard for judging
    proofs good or bad.

    Because we are using Coq in this course, we will be working
    heavily with formal proofs.  But this doesn't mean we can
    completely forget about informal ones!  Formal proofs are useful
    in many ways, but they are _not_ very efficient ways of
    communicating ideas between human beings. *)

(** For example, here is a proof that addition is associative: *)

Theorem add_assoc' : forall n m p : nat,
  n + (m + p) = (n + m) + p.
Proof. intros n m p. induction n as [| n' IHn']. reflexivity.
  simpl. rewrite IHn'. reflexivity.  Qed.

(** Coq is perfectly happy with this.  For a human, however, it
    is difficult to make much sense of it.  We can use comments and
    bullets to show the structure a little more clearly... *)

Theorem add_assoc'' : forall n m p : nat,
  n + (m + p) = (n + m) + p.
Proof.
  intros n m p. induction n as [| n' IHn'].
  - (* n = 0 *)
    reflexivity.
  - (* n = S n' *)
    simpl. rewrite IHn'. reflexivity.   Qed.

(** ... and if you're used to Coq you might be able to step
    through the tactics one after the other in your mind and imagine
    the state of the context and goal stack at each point, but if the
    proof were even a little bit more complicated this would be next
    to impossible.

    A (pedantic) mathematician might write the proof something like
    this: *)

(** - _Theorem_: For any [n], [m] and [p],

      n + (m + p) = (n + m) + p.

    _Proof_: By induction on [n].

    - First, suppose [n = 0].  We must show that

        0 + (m + p) = (0 + m) + p.

      This follows directly from the definition of [+].

    - Next, suppose [n = S n'], where

        n' + (m + p) = (n' + m) + p.

      We must now show that

        (S n') + (m + p) = ((S n') + m) + p.

      By the definition of [+], this follows from

        S (n' + (m + p)) = S ((n' + m) + p),

      which is immediate from the induction hypothesis.  _Qed_. *)

(** The overall form of the proof is basically similar, and of
    course this is no accident: Coq has been designed so that its
    [induction] tactic generates the same sub-goals, in the same
    order, as the bullet points that a mathematician would write.  But
    there are significant differences of detail: the formal proof is
    much more explicit in some ways (e.g., the use of [reflexivity])
    but much less explicit in others (in particular, the "proof state"
    at any given point in the Coq proof is completely implicit,
    whereas the informal proof reminds the reader several times where
    things stand). *)

(** **** Exercise: 2 stars, advanced, especially useful (add_comm_informal)

    Translate your solution for [add_comm] into an informal proof:

    Theorem: Addition is commutative.

    Proof: (* FILL IN HERE *)
*)

(* Do not modify the following line: *)
Definition manual_grade_for_add_comm_informal : option (nat*string) := None.
(** [] *)

(** **** Exercise: 2 stars, standard, optional (eqb_refl_informal)

    Write an informal proof of the following theorem, using the
    informal proof of [add_assoc] as a model.  Don't just
    paraphrase the Coq tactics into English!

    Theorem: [(n =? n) = true] for any [n].

    Proof: (* FILL IN HERE *)
*)

(* Do not modify the following line: *)
Definition manual_grade_for_eqb_refl_informal : option (nat*string) := None.
(** [] *)

(* ################################################################# *)
(** * More Exercises *)

(** **** Exercise: 3 stars, standard, especially useful (mul_comm)

    Use [assert] to help prove [add_shuffle3].  You don't need to
    use induction yet. *)

Theorem add_shuffle3 : forall n m p : nat,
  n + (m + p) = m + (n + p).
Proof.
  (* FILL IN HERE *) Admitted.

(** Now prove commutativity of multiplication.  You will probably want
    to look for (or define and prove) a "helper" theorem to be used in
    the proof of this one. Hint: what is [n * (1 + k)]? *)

Theorem mul_comm : forall m n : nat,
  m * n = n * m.
Proof.
  (* FILL IN HERE *) Admitted.
(** [] *)

(** **** Exercise: 2 stars, standard, optional (plus_leb_compat_l)

    If a hypothesis has the form [H: P -> a = b], then [rewrite H] will
    rewrite [a] to [b] in the goal, and add [P] as a new subgoal. Use
    that in the inductive step of this exercise. *)

Check leb.

Theorem plus_leb_compat_l : forall n m p : nat,
  n <=? m = true -> (p + n) <=? (p + m) = true.
Proof.
  (* FILL IN HERE *) Admitted.

(** [] *)

(** **** Exercise: 3 stars, standard, optional (more_exercises)

    Take a piece of paper.  For each of the following theorems, first
    _think_ about whether (a) it can be proved using only
    simplification and rewriting, (b) it also requires case
    analysis ([destruct]), or (c) it also requires induction.  Write
    down your prediction.  Then fill in the proof.  (There is no need
    to turn in your piece of paper; this is just to encourage you to
    reflect before you hack!) *)

Theorem leb_refl : forall n:nat,
  (n <=? n) = true.
Proof.
  (* FILL IN HERE *) Admitted.

Theorem zero_neqb_S : forall n:nat,
  0 =? (S n) = false.
Proof.
  (* FILL IN HERE *) Admitted.

Theorem andb_false_r : forall b : bool,
  andb b false = false.
Proof.
  (* FILL IN HERE *) Admitted.

Theorem S_neqb_0 : forall n:nat,
  (S n) =? 0 = false.
Proof.
  (* FILL IN HERE *) Admitted.

Theorem mult_1_l : forall n:nat, 1 * n = n.
Proof.
  (* FILL IN HERE *) Admitted.

Theorem all3_spec : forall b c : bool,
  orb
    (andb b c)
    (orb (negb b)
         (negb c))
  = true.
Proof.
  (* FILL IN HERE *) Admitted.

Theorem mult_plus_distr_r : forall n m p : nat,
  (n + m) * p = (n * p) + (m * p).
Proof.
  (* FILL IN HERE *) Admitted.

Theorem mult_assoc : forall n m p : nat,
  n * (m * p) = (n * m) * p.
Proof.
  (* FILL IN HERE *) Admitted.
(** [] *)

(** **** Exercise: 2 stars, standard, optional (add_shuffle3')

    The [replace] tactic allows you to specify a particular subterm to
   rewrite and what you want it rewritten to: [replace (t) with (u)]
   replaces (all copies of) expression [t] in the goal by expression
   [u], and generates [t = u] as an additional subgoal. This is often
   useful when a plain [rewrite] acts on the wrong part of the goal.

   Use the [replace] tactic to do a proof of [add_shuffle3'], just like
   [add_shuffle3] but without needing [assert]. *)

Theorem add_shuffle3' : forall n m p : nat,
  n + (m + p) = m + (n + p).
Proof.
  (* FILL IN HERE *) Admitted.
(** [] *)

(* ################################################################# *)
(** * Nat to Bin and Back to Nat *)

(** Recall the [bin] type we defined in [Basics]: *)

Inductive bin : Type :=
  | Z
  | B0 (n : bin)
  | B1 (n : bin)
.
(** Before you start working on the next exercise, replace the stub
    definitions of [incr] and [bin_to_nat], below, with your solution
    from [Basics].  That will make it possible for this file to
    be graded on its own. *)

Fixpoint incr (m:bin) : bin
  (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.

Fixpoint bin_to_nat (m:bin) : nat
  (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.

(** In [Basics], we did some unit testing of [bin_to_nat], but we
    didn't prove its correctness. Now we'll do so. *)

(** **** Exercise: 3 stars, standard, especially useful (binary_commute)

    Prove that the following diagram commutes:

                            incr
              bin ----------------------> bin
               |                           |
    bin_to_nat |                           |  bin_to_nat
               |                           |
               v                           v
              nat ----------------------> nat
                             S

    That is, incrementing a binary number and then converting it to
    a (unary) natural number yields the same result as first converting
    it to a natural number and then incrementing.

    If you want to change your previous definitions of [incr] or [bin_to_nat]
    to make the property easier to prove, feel free to do so! *)

Theorem bin_to_nat_pres_incr : forall b : bin,
  bin_to_nat (incr b) = 1 + bin_to_nat b.
Proof.
  (* FILL IN HERE *) Admitted.

(** [] *)

(** **** Exercise: 3 stars, standard (nat_bin_nat) *)

(** Write a function to convert natural numbers to binary numbers. *)

Fixpoint nat_to_bin (n:nat) : bin
  (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.

(** Prove that, if we start with any [nat], convert it to [bin], and
    convert it back, we get the same [nat] which we started with.

    Hint: This proof should go through smoothly using the previous
    exercise about [incr] as a lemma. If not, revisit your definitions
    of the functions involved and consider whether they are more
    complicated than necessary: the shape of a proof by induction will
    match the recursive structure of the program being verified, so
    make the recursions as simple as possible. *)

Theorem nat_bin_nat : forall n, bin_to_nat (nat_to_bin n) = n.
Proof.
  (* FILL IN HERE *) Admitted.

(** [] *)

(* ################################################################# *)
(** * Bin to Nat and Back to Bin (Advanced) *)

(** The opposite direction -- starting with a [bin], converting to [nat],
    then converting back to [bin] -- turns out to be problematic. That
    is, the following theorem does not hold. *)

Theorem bin_nat_bin_fails : forall b, nat_to_bin (bin_to_nat b) = b.
Abort.

(** Let's explore why that theorem fails, and how to prove a modified
    version of it. We'll start with some lemmas that might seem
    unrelated, but will turn out to be relevant. *)

(** **** Exercise: 2 stars, advanced (double_bin) *)

(** Prove this lemma about [double], which we defined earlier in the
    chapter. *)

Lemma double_incr : forall n : nat, double (S n) = S (S (double n)).
Proof.
  (* FILL IN HERE *) Admitted.

(** Now define a similar doubling function for [bin]. *)

Definition double_bin (b:bin) : bin
  (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.

(** Check that your function correctly doubles zero. *)

Example double_bin_zero : double_bin Z = Z.
(* FILL IN HERE *) Admitted.

(** Prove this lemma, which corresponds to [double_incr]. *)

Lemma double_incr_bin : forall b,
    double_bin (incr b) = incr (incr (double_bin b)).
Proof.
  (* FILL IN HERE *) Admitted.

(** [] *)

(** Let's return to our desired theorem: *)

Theorem bin_nat_bin_fails : forall b, nat_to_bin (bin_to_nat b) = b.
Abort.

(** The theorem fails because there are some [bin] such that we won't
    necessarily get back to the _original_ [bin], but instead to an
    "equivalent" [bin].  (We deliberately leave that notion undefined
    here for you to think about.)

    Explain in a comment, below, why this failure occurs. Your
    explanation will not be graded, but it's important that you get it
    clear in your mind before going on to the next part. If you're
    stuck on this, think about alternative implementations of
    [double_bin] that might have failed to satisfy [double_bin_zero]
    yet otherwise seem correct. *)

(* FILL IN HERE *)

(** To solve that problem, we can introduce a _normalization_ function
    that selects the simplest [bin] out of all the equivalent
    [bin]. Then we can prove that the conversion from [bin] to [nat] and
    back again produces that normalized, simplest [bin]. *)

(** **** Exercise: 4 stars, advanced (bin_nat_bin) *)

(** Define [normalize]. You will need to keep its definition as simple
    as possible for later proofs to go smoothly. Do not use
    [bin_to_nat] or [nat_to_bin], but do use [double_bin].

    Hint: Structure the recursion such that it _always_ reaches the
    end of the [bin] and process each bit only once. Do not try to
    "look ahead" at future bits. *)

Fixpoint normalize (b:bin) : bin
  (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.

(** It would be wise to do some [Example] proofs to check that your definition of
    [normalize] works the way you intend before you proceed. They won't be graded,
    but fill them in below. *)

(* FILL IN HERE *)

(** Finally, prove the main theorem. The inductive cases could be a
    bit tricky.

    Hint: Start by trying to prove the main statement, see where you
    get stuck, and see if you can find a lemma -- perhaps requiring
    its own inductive proof -- that will allow the main proof to make
    progress. We have one lemma for the [B0] case (which also makes
    use of [double_incr_bin]) and another for the [B1] case. *)

Theorem bin_nat_bin : forall b, nat_to_bin (bin_to_nat b) = normalize b.
Proof.
  (* FILL IN HERE *) Admitted.

(** [] *)
