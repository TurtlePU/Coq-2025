(** * Списки и работа со структурами данных *)

(* ################################################################# *)
(** * Раздельная компиляция *)

(** Перед тем как начать эту лекцию, нам нужно импортировать
    все наши определения с прошлой лекции: *)

From Lectures Require Export Lecture1.
Module NatList.

(** Чтобы команда [Require] сработала, Coq-у нужно найти
    скомпилированную версию предыдущей лекции ([Lecture1.v]).
    Скомпилированная версия называется [Lecture1.vo] и выполняет ту же роль,
    что файлы [.class], полученные по исходникам на [.java], и файлы [.o],
    скомпилированные из файлов с расширением [.c].

    Чтобы скомпилировать [Lecture1.v] и получить [Lecture1.vo],
    в первую очередь убедитесь, что и [Lecture1.v], и [Lecture2.v], и
    [_CoqProject] находятся в текущей директории.

    Файл [_CoqProject] должен содержать единственную строчку:

      -Q . Lectures

    Эта настройка отображает текущий путь ("[.]", содержащий [Lecture1.v],
    [Lecture2.v], и т.д.) в префикс (aka "логическую директорию")
    "[Lectures]". Proof General, CoqIDE, и VSCoq читают [_CoqProject]
    автоматически, чтобы определить путь к скомпилированному файлу
    [Lecture1.vo], содержащему библиотеку [Lectures.Lecture1].

    При условии, что все файлы на месте, есть множество способов собрать
    [Lecture1.vo], как с помощью IDE, так и просто из командной строки.
    С помощью IDE:

     - Proof General можно заставить компилировать файл автоматически,
       в момент выполнения команды [Require] внутри PG, присвоив значение
       emacs-переменной [coq-compile-before-require], равное [t].
       Также эту опцию можно включить в меню: "Coq" > "Auto Compilation" >
       "Compile Before Require".

     - В CoqIDE: Открываем [Lecture1.v];
       затем в выпадающем списке "Compile" выбираем "Compile Buffer".

     - Пользователей VSCode приглашаем в терминал, инструкцию см. ниже.

    Чтобы скомпилировать [Lecture1.v] с помощью командной строки, нужно:

     - Запустить [make] с соответствующим файлом [.vo] в качестве таргета:

         make Lecture1.vo

       Таргет по умолчанию -- это все файлы в директории:

         make

     - Под капотом, [make] вызывает компилятор Coq, [coqc].  Если есть
       возможность, то используйте [make] вместо явного запуска [coqc]
       -- кроме запуска собственно калькулятора, [make] также вычисляет
       зависимости между исходными файлами, чтобы скомпилировать их в правильном
       порядке.  Но, конечно, в крайнем (но не слишком уж ужасном) случае,
       файлы можно компилировать вручную по ходу выполнения заданий.
       Например, перед началом работы над текущей лекцией, вам нужно будет
       запустить следующую команду:

        coqc -Q . Lectures Lecture1.v

       Далее, когда вы закончите работу над заданиями к этой лекции:

        coqc -Q . Lectures Lecture2.v

       (Чтобы подготовиться к следующей лекции).  Если по какой-либо причине
       файлы .vo пропадут или устареют, нужно будет вновь запустить обе команды,
       в том же порядке.

    Возможные неисправности:

     - Для большинства вариантов, описанных выше, нужно, чтобы путь к
       исполняемому файлу [coqc] находился в переменной среды [PATH].

     - Если [coqc] Вам сообщает, что не хватает каких-то идентификаторов,
       возможно, функциональность "load path" для Coq была установлена
       неправильно.  Команда [Print LoadPath.] может оказаться полезной,
       чтобы разобраться с проблемой.

     - При компиляции дальнейших лекций, если Вы видите сообщение навроде

        Compiled library Lecture2 makes inconsistent assumptions over
        library Lecture1

       скорее всего, дело в том, что библиотека [Lecture1] была изменена и
       перекомпилирована, в отличие от [Lecture2], которая от неё зависит.
       Просто перекомпилируйте [Lecture2]; либо всё вместе, если слишком много
       библиотек столкнулось с той же проблемой. Повторюсь, для этого достаточно
       запустить [make]; если даже это не поможет, попробуйте [make clean; make].

     - Если и это не помогло, возможно, на Вашем компьютере установлено сразу
       несколько несовместимых версий Coq.  Возможно, команды, которые Вы
       выполняете в терминале (вроде [coqc]) запускаются не с той версией Coq,
       с которой взаимодействуют Proof General или CoqIDE.  В CoqIDE для обхода
       этой проблемы можно компилировать только средствами CoqIDE (т.е. вызывать
       "make" из меню), избегая прямого использования [coqc]. *)

(* ################################################################# *)
(** * Пары натуральных чисел *)

(** В определении [Индуктивного] типа данных каждый конструктор может
    принимать любое количество аргументов -- ни одного (как [true] и [O]), один
    (как [S]) или больше одного (как [nybble] и как следующий конструктор): *)

Inductive natprod : Type :=
  | pair (n1 n2 : nat).

(** Это объявление можно прочитать так: "Единственный способ
    сконструировать пару чисел -- применить конструктор [pair]
    к двум аргументам типа [nat]." *)

Check (pair 3 5) : natprod.

(** Функции для извлечения первой и второй компонент пары
    можно определить через сопоставление с образцом. *)

Definition fst (p : natprod) : nat :=
  match p with
  | pair x y => x
  end.

Definition snd (p : natprod) : nat :=
  match p with
  | pair x y => y
  end.

Compute (fst (pair 3 5)).
(* ===> 3 *)

(** В дальнейшем мы будем активно использовать эти определения,
    так что нам было бы удобно записывать их в стандартной математической
    нотации как [(x,y)] вместо [pair x y].  Мы можем сообщить Coq об этом
    с помощью объявления новой [Нотации]. *)

Notation "( x , y )" := (pair x y).

(** Нотации можно использовать как в выражениях,
    так и в сравнении с образцом. *)

Compute (fst (3,5)).

Definition fst' (p : natprod) : nat :=
  match p with
  | (x,y) => x
  end.

Definition snd' (p : natprod) : nat :=
  match p with
  | (x,y) => y
  end.

Definition swap_pair (p : natprod) : natprod :=
  match p with
  | (x,y) => (y,x)
  end.

(** Обратите внимание, что сравнение пары с образцом (со скобками: [(x, y)])
    не нужно путать с синтаксисом "мультипаттерна" (без скобок: [x, y]),
    который мы видели ранее.  Примеры выше иллюстрируют сопоставление с образцом
    _единственной_ пары, состоящей из элементов [x] и [y], когда как, например,
    определение [minus] в [Lecture1] сопоставляет с образцом
    _два_ значения [n] и [m]:

       Fixpoint minus (n m : nat) : nat :=
         match n, m with
         | O   , _    => O
         | S _ , O    => n
         | S n', S m' => minus n' m'
         end.

    Различие не слишком большое, но важно понимать, что это не одно и то же.
    Например, следующие примеры составлены неправильно:

        (* Нельзя сопоставлять _одну_ пару с мультипаттерном: *)
        Definition bad_fst (p : natprod) : nat :=
          match p with
          | x, y => x
          end.

        (* Нельзя сопоставить _несколько_ значений
           с помощью _одного_ паттерна для пар: *)
        Definition bad_minus (n m : nat) : nat :=
          match n, m with
          | (O   , _   ) => O
          | (S _ , O   ) => n
          | (S n', S m') => bad_minus n' m'
          end.
*)

(** Если мы будем формулировать свойства пар несколько обходным путём, мы иногда
    сможем завершить их доказательства чисто с помощью [рефлексивности] и
    встроенных упрощений: *)

Theorem surjective_pairing' : forall (n m : nat),
  (n,m) = (fst (n,m), snd (n,m)).
Proof.
  reflexivity. Qed.

(** Однако просто [рефлексивности] недостаточно, если мы сформулируем
    утверждение леммы естественным образом: *)

Theorem surjective_pairing_stuck : forall (p : natprod),
  p = (fst p, snd p).
Proof.
  simpl. (* Ничего не упрощает! *)
Abort.

(** Вместо этого, нам нужно обнажить внутреннее устройство [p], чтобы
    [simpl] мог произвести сопоставление с образцом в [fst] и [snd].  Мы можем
    достичь этого с помощью [destruct]. *)

Theorem surjective_pairing : forall (p : natprod),
  p = (fst p, snd p).
Proof.
  intros p. destruct p as [n m]. simpl. reflexivity. Qed.

(** Обратите внимание, что, в отличие от поведения [destruct] на
    натуральных числах, где он генерирует две подцели, здесь [destruct]
    генерирует всего одну-единственную подцель.  Это происходит ровно потому,
    что [natprod] можно построить единственным способом --
    вызовом его единственного конструктора. *)

(** **** Exercise: 1 star, standard (snd_fst_is_swap) *)
Theorem snd_fst_is_swap : forall (p : natprod),
  (snd p, fst p) = swap_pair p.
Proof.
  (* FILL IN HERE *) Admitted.
(** [] *)

(** **** Exercise: 1 star, standard, optional (fst_swap_is_snd) *)
Theorem fst_swap_is_snd : forall (p : natprod),
  fst (swap_pair p) = snd p.
Proof.
  (* FILL IN HERE *) Admitted.
(** [] *)

(* ################################################################# *)
(** * Списки натуральных чисел *)

(** Обобщая определение пар, мы можем описать тип _списков_ чисел
    следующим образом: "Список либо пустой, либо является парой из первого
    элемента (в данном случае числа) и списка,
    состоящего из остальных элементов." *)

Inductive natlist : Type :=
  | nil
  | cons (n : nat) (l : natlist).

(** Вот, например, список из трёх элементов: *)

Definition mylist := cons 1 (cons 2 (cons 3 nil)).

(** Как и с парами, нам будет удобно записывать списки, используя
    знакомую нотацию.  Следующие объявления позволяют нам использовать [::] в
    качестве инфиксной версии оператора [cons], а квадратные скобки -- в
    качестве "аутфиксной" нотации для построения списков. *)

Notation "x :: l" := (cons x l)
                     (at level 60, right associativity).
Notation "[ ]" := nil.
Notation "[ x ; .. ; y ]" := (cons x .. (cons y nil) ..).

(** Разбираться во внутреннем устройстве этих объявлений не обязательно,
    но, в случае, если Вам интересно, вот что примерно происходит.
    Аннотация "[right associativity]" сообщает Coq, как расставлять скобки в
    выражениях, содержащих несколько использований [::], так, чтобы, например,
    следующие три объявления значили в точности одно и то же: *)

Definition mylist1 := 1 :: (2 :: (3 :: nil)).
Definition mylist2 := 1 :: 2 :: 3 :: nil.
Definition mylist3 := [1;2;3].

(** Часть с "[at level 60]" сообщает Coq, как расставлять скобки в
    выражениях, содержащих и [::], и ещё какой-то другой инфиксный оператор.
    Например, раз мы определили [+] в качестве инфиксной нотации для функции
    [plus] с приоритетом 50,

  Notation "x + y" := (plus x y) (at level 50, left associativity).

    оператор [+] будет _связывать сильнее, чем_ [::], так что [1 + 2 :: [3]]
    будет пониматься как [(1 + 2) :: [3]] (что и ожидалось),
    а не как [1 + (2 :: [3])].

    (Выражения вида "[1 + 2 :: [3]]" могут выглядеть слегка запутанно,
    особенно читать их в файле [.v].  Внутренние скобки, вокруг 3,
    маркируют список, а вот внешние скобки, невидимые при просмотре HTML-версии,
    направляют инструмент "coqdoc" так, чтобы часть в этих скобках отображалась
    как код на Coq, а не как обычный текст.)

    Второе и третье объявления [Notation] выше вводят стандартную нотацию
    для списков через квадратные скобки; часть справа от [:=] в третьем правиле
    иллюстрирует синтаксис Coq для объявления нотаций переменной длины и
    их перевода во вложенные последовательности бинарных конструкторов.

    Опять же, не переживайте, если Вас озадачили какие-то детали
    синтаксического разбора: все используемые в нашем курсе нотации
    уже будут определены в лекционных файлах.
*)

(* ----------------------------------------------------------------- *)
(** *** Повтор элемента *)

(** Далее, давайте рассмотрим несколько функций для работы со списками.
    Вот, во-первых, функция [repeat], по значению [n] и счётчику [count]
    возвращающая список длины [count], в котором каждый элемент равен [n]. *)

Fixpoint repeat (n count : nat) : natlist :=
  match count with
  | O => nil
  | S count' => n :: (repeat n count')
  end.

(* ----------------------------------------------------------------- *)
(** *** Длина списка *)

(** Функция [length] вычисляет длину списка. *)

Fixpoint length (l:natlist) : nat :=
  match l with
  | nil => O
  | h :: t => S (length t)
  end.

(* ----------------------------------------------------------------- *)
(** *** Конкатенация *)

(** Функция [app] конкатенирует (соединяет) два списка. *)

Fixpoint app (l1 l2 : natlist) : natlist :=
  match l1 with
  | nil    => l2
  | h :: t => h :: (app t l2)
  end.

(** Т.к. [app] мы будем использовать очень часто, будет полезно
    определить для её использования инфиксный оператор. *)

Notation "x ++ y" := (app x y)
                     (right associativity, at level 60).

Example test_app1:             [1;2;3] ++ [4;5] = [1;2;3;4;5].
Proof. reflexivity. Qed.
Example test_app2:             nil ++ [4;5] = [4;5].
Proof. reflexivity. Qed.
Example test_app3:             [1;2;3] ++ nil = [1;2;3].
Proof. reflexivity. Qed.

(* ----------------------------------------------------------------- *)
(** *** Голова и хвост *)

(** Здесь мы покажем два примера попроще. Функция [hd] возвращает
    первый элемент ("голову") списка, в то время как [tl] возвращает
    все элементы, кроме первого ("хвост").  Т.к. у пустого списка нет первого
    элемента, мы также передаём в [hd] значение по умолчанию, которое нужно
    вернуть в таком случае.  *)

Definition hd (default : nat) (l : natlist) : nat :=
  match l with
  | nil => default
  | h :: t => h
  end.

Definition tl (l : natlist) : natlist :=
  match l with
  | nil => nil
  | h :: t => t
  end.

Example test_hd1:             hd 0 [1;2;3] = 1.
Proof. reflexivity. Qed.
Example test_hd2:             hd 0 [] = 0.
Proof. reflexivity. Qed.
Example test_tl:              tl [1;2;3] = [2;3].
Proof. reflexivity. Qed.

(* ----------------------------------------------------------------- *)
(** *** Упражнения *)

(** **** Exercise: 2 stars, standard, especially useful (list_funs)

    Завершите определения [nonzeros], [oddmembers] и [countoddmembers] ниже.
    Ознакомьтесь с тестами, чтобы понять, что должны делать эти функции. *)

Fixpoint nonzeros (l:natlist) : natlist
  (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.

Example test_nonzeros:
  nonzeros [0;1;0;2;3;0;0] = [1;2;3].
  (* FILL IN HERE *) Admitted.

Fixpoint oddmembers (l:natlist) : natlist
  (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.

Example test_oddmembers:
  oddmembers [0;1;0;2;3;0;0] = [1;3].
  (* FILL IN HERE *) Admitted.

(** Для следующей задачки, [countoddmembers], мы даём Вам заголовок,
    использующий ключевое слово [Definition] вместо [Fixpoint].
    Смысл постановки вопроса таким образом в том, чтобы замотивировать
    Вас реализовать функцию с помощью уже существующих определений
    вместо того чтобы вновь выписывать рекурсивное определение. *)

Definition countoddmembers (l:natlist) : nat
  (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.

Example test_countoddmembers1:
  countoddmembers [1;0;3;1;4;5] = 4.
  (* FILL IN HERE *) Admitted.

Example test_countoddmembers2:
  countoddmembers [0;2;4] = 0.
  (* FILL IN HERE *) Admitted.

Example test_countoddmembers3:
  countoddmembers nil = 0.
  (* FILL IN HERE *) Admitted.
(** [] *)

(** **** Exercise: 3 stars, advanced (alternate)

    Завершите определение [alternate], которая перемежает элементы двух списков:
    [[элемент первого; элемент второго; ...]].
    См. тесты в качестве примеров работы.

    Подсказка: есть множество естественных способов выписать [alternate],
    которые, однако, не удовлетворяют требованию Coq-а, чтобы все определения
    через [Fixpoint] были _структурно рекурсивными_, как упоминалось в
    [Lecture1]. Если Вас это затрудняет, попробуйте сопоставлять с образцом
    сразу оба списка с помощью мультипаттерна. *)

Fixpoint alternate (l1 l2 : natlist) : natlist
  (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.

Example test_alternate1:
  alternate [1;2;3] [4;5;6] = [1;4;2;5;3;6].
  (* FILL IN HERE *) Admitted.

Example test_alternate2:
  alternate [1] [4;5;6] = [1;4;5;6].
  (* FILL IN HERE *) Admitted.

Example test_alternate3:
  alternate [1;2;3] [4] = [1;4;2;3].
  (* FILL IN HERE *) Admitted.

Example test_alternate4:
  alternate [] [20;30] = [20;30].
  (* FILL IN HERE *) Admitted.
(** [] *)

(* ----------------------------------------------------------------- *)
(** *** Мультимножества на списках *)

(** Мультимножества ([bag]) очень похожи на _множества_ за исключением того, что
    каждый элемент в мультимножестве может встречаться несколько раз.
    Один из многих способов представления мультимножества --
    с помощью списка. *)

Definition bag := natlist.

(** **** Exercise: 3 stars, standard, especially useful (bag_functions)

    Завершите определения функций [count],
    [sum], [add], и [member] для мультимножеств. *)

Fixpoint count (v : nat) (s : bag) : nat
  (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.

(** Все утверждения ниже можно доказать с помощью [рефлексивности]. *)

Example test_count1:              count 1 [1;2;3;1;4;1] = 3.
 (* FILL IN HERE *) Admitted.
Example test_count2:              count 6 [1;2;3;1;4;1] = 0.
 (* FILL IN HERE *) Admitted.

(** [сумма] мультимножеств похожа на объединение множеств: [sum a b]
    содержит все элементы [a] и [b].  (Математики обычно определяют
    объединение мультимножеств слегка по-другому -- через взятие максимума,
    а не через сумму -- так что мы не называем нашу операцию [union] во
    избежание коллизий.)

    Мы намеренно даём Вам заголовок функции, который не именует аргументы.
    Реализуйте [sum] с помощью уже определённой функции, не меняя заголовок. *)

Definition sum : bag -> bag -> bag
  (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.

Example test_sum1:              count 1 (sum [1;2;3] [1;4;1]) = 3.
 (* FILL IN HERE *) Admitted.

Definition add (v : nat) (s : bag) : bag
  (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.

Example test_add1:                count 1 (add 1 [1;4;1]) = 3.
 (* FILL IN HERE *) Admitted.
Example test_add2:                count 5 (add 1 [1;4;1]) = 0.
 (* FILL IN HERE *) Admitted.

Fixpoint member (v : nat) (s : bag) : bool
  (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.

Example test_member1:             member 1 [1;4;1] = true.
 (* FILL IN HERE *) Admitted.

Example test_member2:             member 2 [1;4;1] = false.
(* FILL IN HERE *) Admitted.
(** [] *)

(** **** Exercise: 3 stars, standard, optional (bag_more_functions)

    Вот ещё немного функций на мультимножествах, чтобы вы попрактиковались. *)

(** Когда [remove_one] применяется к мультимножеству, не содержащему удаляемого
    значения, она должна вернуть старое мультимножество без изменений.
    (Это упражнение опциональное; тем не менее, определение [remove_one]
    понадобится для решения более поздних дополнительных задачек.) *)

Fixpoint remove_one (v : nat) (s : bag) : bag
  (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.

Example test_remove_one1:
  count 5 (remove_one 5 [2;1;5;4;1]) = 0.
  (* FILL IN HERE *) Admitted.

Example test_remove_one2:
  count 5 (remove_one 5 [2;1;4;1]) = 0.
  (* FILL IN HERE *) Admitted.

Example test_remove_one3:
  count 4 (remove_one 5 [2;1;4;5;1;4]) = 2.
  (* FILL IN HERE *) Admitted.

Example test_remove_one4:
  count 5 (remove_one 5 [2;1;5;4;5;1;4]) = 1.
  (* FILL IN HERE *) Admitted.

Fixpoint remove_all (v:nat) (s:bag) : bag
  (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.

Example test_remove_all1:  count 5 (remove_all 5 [2;1;5;4;1]) = 0.
 (* FILL IN HERE *) Admitted.
Example test_remove_all2:  count 5 (remove_all 5 [2;1;4;1]) = 0.
 (* FILL IN HERE *) Admitted.
Example test_remove_all3:  count 4 (remove_all 5 [2;1;4;5;1;4]) = 2.
 (* FILL IN HERE *) Admitted.
Example test_remove_all4:  count 5 (remove_all 5 [2;1;5;4;5;1;4;5;1;4]) = 0.
 (* FILL IN HERE *) Admitted.

Fixpoint included (s1 : bag) (s2 : bag) : bool
  (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.

Example test_included1:              included [1;2] [2;1;4;1] = true.
 (* FILL IN HERE *) Admitted.
Example test_included2:              included [1;2;2] [2;1;4;1] = false.
 (* FILL IN HERE *) Admitted.
(** [] *)

(** **** Exercise: 2 stars, standard, especially useful (add_inc_count)

    Добавление значения в мультимножество должно инкрементировать значение
    [count] для этого значения. Сформулируйте это утверждение в виде теоремы
    и докажите её в Coq. *)
(*
Theorem add_inc_count : ...
Proof.
  ...
Qed.
*)

(* Do not modify the following line: *)
Definition manual_grade_for_add_inc_count : option (nat*string) := None.
(** [] *)

(* ################################################################# *)
(** * Суждения о списках *)

(** Как и в случае с числами, простые свойства функций,
    обрабатывающих списки, можно доказать просто с помощью упрощений.
    Например, упрощений, выполняемых [reflexivity], достаточно
    для доказательства следующей теоремы... *)

Theorem nil_app : forall l : natlist,
  [] ++ l = l.
Proof. reflexivity. Qed.

(** ...потому что [[]] подставляется в качестве "рассматриваемого"
    (выражения, которое мы "рассматриваем" в сопоставлении с образцом)
    в определении [app], в результате чего всё выражение упрощается. *)

(** Также, как было с числами, иногда полезно произвести разбор возможных
    случаев внутреннего устройства (пустой или непустой?)
    неизвестного списка. *)

Theorem tl_length_pred : forall l:natlist,
  pred (length l) = length (tl l).
Proof.
  intros l. destruct l as [| n l'].
  - (* l = nil *)
    reflexivity.
  - (* l = cons n l' *)
    reflexivity.  Qed.

(** Случай [nil] срабатывает по определению функции ([tl nil = nil]).
    Обратите внимание на аннотацию [as] в тактике [destruct]: она вводит два
    имени, [n] и [l'], ссылающихся на два аргумента конструктора [cons]
    (голову и хвост конструируемого таким образом списка). *)

(** Правда, чаще всего, доказательство интересных теорем о списках требует
    использования _индукции по спискам_.  Сейчас мы увидим, как это делать. *)

(** (Микро-наставление: с более глубоким погружением в материал, просто
    _чтение_ скриптов доказательств Вам не очень поможет.  Скорее, важно
    именно рассмотреть выполнение доказательств по шагам, используя
    интерактивный режим Coq и стараясь понять, чего достигает каждый шаг
    в доказательстве.  В противном случае я гарантирую, что формулировка и
    решение упражнений, когда Вы за них приметесь,
    будут Вам совершенно непостижимы.) *)

(* ================================================================= *)
(** ** Индукция на списках *)

(** Доказательства по индукции на типах данных вроде [natlist],
    скорее всего, будет Вам слегка менее знакома, чем обычная (математическая)
    индукция на натуральных числах, но идея столь же проста.  Каждое
    [Индуктивное] объявление определяет множество значений, которые можно
    построить, используя объявленные конструкторы.  Например, логическое
    значение может быть либо [true], либо [false]; натуральное число может быть
    либо [O], либо [S], применённое к другому числу; наконец, список может быть
    либо [nil], либо [cons], применённый к числу и списку.  Более того,
    применения объявленных конструкторов -- это _единственные_ возможные
    способы получить элементы множества, объявленного индуктивным образом.

    Этот последний факт напрямую предоставляет способ рассуждать об индуктивно
    определяемых множествах: число -- это либо [O], либо [S], применённый к
    _меньшему_ числу; список -- это либо [nil], либо [cons], применённый к
    некоторому произвольному числу и некоторому _меньшему_ списку; и т.д..
    Таким образом, если у нас на уме некоторое утверждение [P] о списке [l], и
    мы хотим доказать, что [P] выполнено для _всех_ возможных списков [l], мы
    можем рассуждать следующим образом:

      - Во-первых, покажем, что
        [P] истинно для [l]
        в случае, когда [l] это [nil].

      - Далее, покажем, что
        [P] истинно для [l] даже в том случае, когда
        [l] это [cons n l'] для некоторого числа [n] и меньшего списка [l'],
        в предположении, что [P] истинно для [l'].

    Раз бОльшие списки всегда можно постепенным отщеплением головы уменьшить до
    [nil], два этих факта вместе позволяют установить истинность [P]
    для произвольных списков [l].

    Вот конкретный пример: *)

Theorem app_assoc : forall l1 l2 l3 : natlist,
  (l1 ++ l2) ++ l3 = l1 ++ (l2 ++ l3).
Proof.
  intros l1 l2 l3. induction l1 as [| n l1' IHl1'].
  - (* l1 = nil *)
    reflexivity.
  - (* l1 = cons n l1' *)
    simpl. rewrite -> IHl1'. reflexivity.  Qed.

(** Обратите внимание, что, как было и с индукцией на натуральных числах,
    клоза [as...] в тактике [induction] позволяет именовать также и
    предположение индукции, соответствующее меньшему списку [l1']
    в случае [cons].

    Опять же, это доказательство на Coq не особенно просветляет в виде
    статичного документа -- проще увидеть, что происходит, если Вы читаете
    доказательство в интерактивной сессии Coq и можете увидеть текущую цель и
    контекст на каждом шаге доказательства, которые нельзя увидеть чисто в
    статичном, записанном варианте доказательства.  Точно также и доказательство
    на естественном языке -- написанное для чтения человеком -- должно включать
    более читаемые и явные опознавательные знаки и остановки; в особенности, мы
    очень поможем читателю ориентироваться в доказательстве, если мы будем
    напоминать ему, как в точности выглядит доказываемое утверждение в
    индуктивном переходе. *)

(** Для сравнения, вот неформальное (но строгое) доказательство
    той же самой теоремы. *)

(** _Теорема_: Для всяких списков [l1], [l2] и [l3] верно, что
               [(l1 ++ l2) ++ l3 = l1 ++ (l2 ++ l3)].

   _Доказательство_: Индукцией по [l1].

   - База: [l1 = []].  Необходимо показать, что

       ([] ++ l2) ++ l3 = [] ++ (l2 ++ l3),

     что напрямую следует из определения [++].

   - Переход: [l1 = n::l1'], причём

       (l1' ++ l2) ++ l3 = l1' ++ (l2 ++ l3)

     (по предположению индукции).  Необходимо показать, что

       ((n :: l1') ++ l2) ++ l3 = (n :: l1') ++ (l2 ++ l3).

     По определению [++], это следует из

       n :: ((l1' ++ l2) ++ l3) = n :: (l1' ++ (l2 ++ l3)),

     что также верно благодаря предположению индукции.  [] *)

(* ----------------------------------------------------------------- *)
(** *** Усиление предположения индукции *)

(** В некоторых случаях, может быть необходимо усилить утверждение,
    чтобы его можно было доказать по индукции.  Интуитивно, причина состоит в
    том, что более сильное (более общее) утверждение также позволяет получить
    более сильное (более общее) предположение индукции.  Если Вы по каким-то
    причинам завязли в доказательстве, попробуйте отступиться, осмотреться и
    выяснить -- может, внезапно получится доказать более сильное утверждение. *)

Theorem repeat_double_firsttry : forall c n: nat,
  repeat n c ++ repeat n c = repeat n (c + c).
Proof.
  intros c. induction c as [| c' IHc'].
  - (* c = 0 *)
    intros n. simpl. reflexivity.
  - (* c = S c' *)
    intros n. simpl.
    (*  Здесь-то мы, кажется, и застряли.  Мы не можем использовать IH,
        чтобы переписать [repeat n (c' + S c')]: гипотеза работает только для
        [repeat n (c' + c')]. Если бы IH была более гибкой
        (например, если бы она работала для произвольного второго слагаемого),
        доказательство бы прошло. *)
Abort.

(** Чтобы получить более сильное предположение, мы можем усилить
    утверждение следующим образом: *)

Theorem repeat_plus: forall c1 c2 n: nat,
    repeat n c1 ++ repeat n c2 = repeat n (c1 + c2).
Proof.
  intros c1 c2 n.
  induction c1 as [| c1' IHc1'].
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHc1'.
    reflexivity.
  Qed.

(* ----------------------------------------------------------------- *)
(** *** Разворот списка *)

(** В качестве более запутанного примера доказательств по индукции на
    списках, предположим, что мы используем [app] для определения функции
    разворота списка [rev]: *)

Fixpoint rev (l:natlist) : natlist :=
  match l with
  | nil    => nil
  | h :: t => rev t ++ [h]
  end.

Example test_rev1:            rev [1;2;3] = [3;2;1].
Proof. reflexivity.  Qed.
Example test_rev2:            rev nil = nil.
Proof. reflexivity.  Qed.

(** В качестве чего-то более мудрёного, давайте докажем, что
    разворот списка не меняет его длину.  Наша первая попытка застревает
    на индуктивном переходе... *)

Theorem rev_length_firsttry : forall l : natlist,
  length (rev l) = length l.
Proof.
  intros l. induction l as [| n l' IHl'].
  - (* l = nil *)
    reflexivity.
  - (* l = n :: l' *)
    (* Вот это сложный случай.  Давайте, как обычно, попробуем упростить. *)
    simpl.
    (* Кажется, мы застряли: цель -- это равенство, содержащее [++], но у нас
       пока нет никаких полезных фактов ни в локальном контексте, ни в
       глобальной среде!  Можем попробовать немного продвинуться и переписать
       цель с помощью предположения индукции... *)
    rewrite <- IHl'.
    (* ... но дальше нам никуда не продвинуться. *)
Abort.

(** Можно попробовать доказать в точности то утверждение, которого нам не
    хватает на данный момент.  Но эта попытка обречена на провал, поскольку
    предположение индукции недостаточно мощное. *)
Theorem app_rev_length_S_firsttry: forall l n,
  length (rev l ++ [n]) = S (length (rev l)).
Proof.
  intros l. induction l as [| m l' IHl'].
  - (* l = [] *)
    intros n. simpl. reflexivity.
  - (* l = m:: l' *)
    intros n. simpl.
    (* IHl' не применима. *)
Abort.

(** Оказывается, лемма выше гораздо слабее, чем нужно. Мы можем усилить
    лемму и работать не только с развёрнутыми списками, но с произвольными
    списками вообще. *)
Theorem app_length_S: forall l n,
  length (l ++ [n]) = S (length l).
Proof.
  intros l n. induction l as [| m l' IHl'].
  - (* l = [] *)
    simpl. reflexivity.
  - (* l = m:: l' *)
    simpl.
    rewrite IHl'.
    reflexivity.
Qed.

(** Теперь мы можем закончить исходное доказательство. *)

Theorem rev_length : forall l : natlist,
  length (rev l) = length l.
Proof.
  intros l. induction l as [| n l' IHl'].
  - (* l = nil *)
    reflexivity.
  - (* l = cons *)
    simpl.
    rewrite -> app_length_S.
    rewrite -> IHl'.
    reflexivity.
Qed.

(** Обратите внимание, что лемма app_length_S, которую мы доказали выше,
    достаточно слабая, т.к. она требует, чтобы второй список состоял из
    единственного элемента. Мы можем доказать более сильное утверждение для
    двух произвольных списков. *)
Theorem app_length : forall l1 l2 : natlist,
  length (l1 ++ l2) = (length l1) + (length l2).
Proof.
  (* WORKED IN CLASS *)
  intros l1 l2. induction l1 as [| n l1' IHl1'].
  - (* l1 = nil *)
    reflexivity.
  - (* l1 = cons *)
    simpl. rewrite -> IHl1'. reflexivity.  Qed.

(** Для сравнения, ниже приведены неформальные доказательства этих двух теорем:

    _Теорема_: Для всяких списков [l1] и [l2] верно, что
       [length (l1 ++ l2) = length l1 + length l2].

    _Доказательство_: Индукцией по [l1].

   - База: [l1 = []].  Нам нужно показать, что

        length ([] ++ l2) = length [] + length l2,

      что следует напрямую из определений [length], [++] и [plus].

    - Переход: [l1 = n::l1']; при этом

        length (l1' ++ l2) = length l1' + length l2.

      Нам нужно показать, что

        length ((n::l1') ++ l2) = length (n::l1') + length l2.

      Это следует напрямую из определений [length] и [++], а также из
      предположения индукции. [] *)

(** _Theorem_: Для всякого списка [l] верно, что [length (rev l) = length l].

    _Доказательство_: Индукцией по [l].

      - База: [l = []].  Нам нужно доказать, что

          length (rev []) = length [],

        что следует напрямую из определений [length] и [rev].

      - Шаг: [l = n::l']; при этом

          length (rev l') = length l'.

        Нам нужно показать, что

          length (rev (n :: l')) = length (n :: l').

        По определению [rev], это должно следовать из того, что

          length ((rev l') ++ [n]) = S (length l')

        что, по предыдущей лемме, эквивалентно

          length (rev l') + length [n] = S (length l').

        А это уже напрямую следует из предположения индукции
        и определения [length]. [] *)

(** Эти доказательства достаточно многословны и педантичны.
    После прочтения парочки таких доказательств, проще будет следить за
    доказательствами, разжёвывающими меньше деталей (которые мы можем легко
    восстановить в уме, либо на бумажке, если необходимо) и демонстрирующими
    только неочевидные переходы.  В таком, более кратком, стиле, доказательство
    выше могло выглядеть следующим образом: *)

(** _Теорема_: Для любого списка [l] верно, что [length (rev l) = length l].

    _Доказательство_: Несложной индукцией по [l] легко убедиться, что
     [length (l ++ [n]) = S (length l)] для любого [l].  Требуемое свойство же,
     в свою очередь, доказывается ещё одной индукцией по [l], где наше
     наблюдение используется в шаге индукции вместе с предположением индукции.
     [] *)

(** То, какой стиль предпочтителен в Вашей конкретной ситуации, зависит от
    предпологаемого уровня знаний Вашей аудитории и того, насколько Ваше
    доказательство похоже на те, с которыми они уже знакомы. Более педантичный
    подход для нас подходит лучше, потому что мы пытаемся
    излагать всё суперподробно. *)

(* ================================================================= *)
(** ** Команда [Search] *)

(** Мы уже убедили, что доказательства могут переиспользовать другие теоремы,
    которые мы уже доказали, например, с помощью [rewrite].  Но для того, чтобы
    сослаться на теорему, нам нужно знать её название!  Действительно, зачастую
    сложно даже вспомнить какие теоремы были доказаны, не говоря уже об их
    названиях.

    Команда [Search] с этим очень помогает.

    Допустим, Вы забыли название теоремы про [rev].  Команда [Search rev]
    запросит у Coq список всех теорем, содержащих [rev] в формулировке. *)

Search rev.

(** Или, например, Вы забыли имя теоремы о коммутативности сложения.
    Вы можете использовать паттерн (_образец_), чтобы поискать все теоремы,
    включающие в себя равенство двух сложений. *)

Search (_ + _ = _ + _).

(** Здесь Вы увидите кучу результатов; практически каждый из них будет из
    стандартной библиотеки.  Чтобы сузить область поиска, можно искать внутри
    конкретного модуля: *)

Search (_ + _ = _ + _) inside Lecture1.

(** Также можно уточнить запрос, используя в паттерне переменные
    вместо вайлдкардов: *)

Search (?x + ?y = ?y + ?x).

(** (Знак вопроса перед переменной нужен, чтобы отличать переменную, объявленную
    внутри паттерна, от идентификатора из текущей области видимости.) *)

(** Не забывайте про [Search], пока выполняете упражнения курса; эта команда
    поможет вам сэкономить много-много времени! *)

(* ================================================================= *)
(** ** Упражнения на списки, часть 1 *)

(** **** Exercise: 3 stars, standard (list_exercises)

    Больше практики со списками: *)

Theorem app_nil_r : forall l : natlist,
  l ++ [] = l.
Proof.
  (* FILL IN HERE *) Admitted.

Theorem rev_app_distr: forall l1 l2 : natlist,
  rev (l1 ++ l2) = rev l2 ++ rev l1.
Proof.
  (* FILL IN HERE *) Admitted.

(** _Инволюция_ это функция, которая обратна сама себе. То есть,
    применение функции дважды не меняет исходное значение. *)
Theorem rev_involutive : forall l : natlist,
  rev (rev l) = l.
Proof.
  (* FILL IN HERE *) Admitted.

(** Для следующей теоремы есть краткое решение.  Если чувствуете,
    что запутались, отступитесь и попробуйте найти решение попроще. *)

Theorem app_assoc4 : forall l1 l2 l3 l4 : natlist,
  l1 ++ (l2 ++ (l3 ++ l4)) = ((l1 ++ l2) ++ l3) ++ l4.
Proof.
  (* FILL IN HERE *) Admitted.

(** Упражнение про Вашу реализацию [nonzeros]: *)

Lemma nonzeros_app : forall l1 l2 : natlist,
  nonzeros (l1 ++ l2) = (nonzeros l1) ++ (nonzeros l2).
Proof.
  (* FILL IN HERE *) Admitted.
(** [] *)

(** **** Exercise: 2 stars, standard (eqblist)

    Завершите определение [eqblist], функции, проверяющей списки на равенство.
    Докажите, что [eqblist l l] возвращает [true] для любого [l]. *)

Fixpoint eqblist (l1 l2 : natlist) : bool
  (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.

Example test_eqblist1 :
  (eqblist nil nil = true).
 (* FILL IN HERE *) Admitted.

Example test_eqblist2 :
  eqblist [1;2;3] [1;2;3] = true.
(* FILL IN HERE *) Admitted.

Example test_eqblist3 :
  eqblist [1;2;3] [1;2;4] = false.
 (* FILL IN HERE *) Admitted.

Theorem eqblist_refl : forall l:natlist,
  true = eqblist l l.
Proof.
  (* FILL IN HERE *) Admitted.
(** [] *)

(* ================================================================= *)
(** ** Упражнения на списки, часть 2 *)

(** Вот ещё несколько небольших теорем про мультимножества. *)

(** **** Exercise: 1 star, standard (count_member_nonzero) *)
Theorem count_member_nonzero : forall (s : bag),
  1 <=? (count 1 (1 :: s)) = true.
Proof.
  (* FILL IN HERE *) Admitted.
(** [] *)

(** Следующая лемма о [leb] может помочь Вам в следующем упражнении
    (да и в будущем пригодится). *)

Theorem leb_n_Sn : forall n,
  n <=? (S n) = true.
Proof.
  intros n. induction n as [| n' IHn'].
  - (* 0 *)
    simpl.  reflexivity.
  - (* S n' *)
    simpl.  rewrite IHn'.  reflexivity.  Qed.

(** Перед тем, как приступить к следующему упражнению, убедитесь, что Вы
   завершили определение [remove_one] выше. *)
(** **** Exercise: 3 stars, advanced (remove_does_not_increase_count) *)
Theorem remove_does_not_increase_count: forall (s : bag),
  (count 0 (remove_one 0 s)) <=? (count 0 s) = true.
Proof.
  (* FILL IN HERE *) Admitted.
(** [] *)

(** **** Exercise: 3 stars, standard, optional (bag_count_sum)

    Сформулируйте ниже интересную теорему [bag_count_sum] о мультимножествах,
    связывающую функции [count] и [sum], и докажите её с помощью Coq.
    (Может так оказаться, что сложность доказательсва зависит от того,
    как Вы определили [count]!  Подсказка: если Вы определили [count], используя
    [=?], Вам может быть полезно узнать, что [destruct] работает не только для
    переменных, но и для вообще произвольных утверждений.)
*)
(* FILL IN HERE

    [] *)

(** **** Exercise: 3 stars, advanced (involution_injective) *)

(** Докажите, что всякая инволюция инъективна.

    Инволюции были определены выше, в [rev_involutive]. _Инъективная_
    функция же, в свою очередь, та, которая для разных аргументов возвращает
    разные значения, без коллизий. *)

Theorem involution_injective : forall (f : nat -> nat),
    (forall n : nat, n = f (f n)) -> (forall n1 n2 : nat, f n1 = f n2 -> n1 = n2).
Proof.
  (* FILL IN HERE *) Admitted.

(** [] *)

(** **** Exercise: 2 stars, advanced (rev_injective)

    Докажите, что [rev] инъективна. Не советую доказывать по индукции --
    это будет сложно. Вместо этого переиспользуйте ту же технику, что Вы
    использовали для доказательства [involution_injective]. (Но: Не пытайтесь
    использовать то упражнение: типы не сойдутся!) *)

Theorem rev_injective : forall (l1 l2 : natlist),
  rev l1 = rev l2 -> l1 = l2.
Proof.
  (* FILL IN HERE *) Admitted.
(** [] *)

(* ################################################################# *)
(** * Частичные значения *)

(** Пусть мы хотим написать функцию, возвращающую [n]-й элемент некоторого
    списка.  Если мы выпишем её тип как [nat -> natlist -> nat], нам придётся
    выбрать какое-то число, чтобы возвращать его в том случае,
    если список слишком короткий... *)

Fixpoint nth_bad (l:natlist) (n:nat) : nat :=
  match l with
  | nil => 42
  | a :: l' => match n with
               | 0 => a
               | S n' => nth_bad l' n'
               end
  end.

(** Это решение не очень хорошее: если [nth_bad] возвращает [42], мы
    не сможем установить, есть ли это значение в списке, без дополнительного
    разбирательства. Альтернативой получше будет изменить тип возвращаемого
    значения в [nth_bad] таким образом, чтобы учесть значение-ошибку как
    вероятный исход запуска функции. Мы назовём этот тип [natoption]. *)

Inductive natoption : Type :=
  | Some (n : nat)
  | None.

(* Заметим, что мы написали [None] и [Some] с большой буквы, аналогично их
   названию в стандартной библиотеке Coq.  В общем-то имена конструкторов (да и
   переменных) могут начинаться как с большой, так и с маленькой буквы. *)

(** Теперь мы можем изменить определение [nth_bad] выше так, чтобы она
    возвращала [None], когда список слишком короткий, и [Some a] в противном
    случае (и, конечно, на [n]-й позиции в списке стоит [a]). Мы назовём эту
    новую функцию [nth_error], чтобы сигнализировать о возможной ошибке. *)

Fixpoint nth_error (l:natlist) (n:nat) : natoption :=
  match l with
  | nil => None
  | a :: l' => match n with
               | O => Some a
               | S n' => nth_error l' n'
               end
  end.

Example test_nth_error1 : nth_error [4;5;6;7] 0 = Some 4.
Proof. reflexivity. Qed.
Example test_nth_error2 : nth_error [4;5;6;7] 3 = Some 7.
Proof. reflexivity. Qed.
Example test_nth_error3 : nth_error [4;5;6;7] 9 = None.
Proof. reflexivity. Qed.

(** Функция ниже вытаскивает значение типа [nat] из [natoption], возвращая
    значение по умолчанию в случае [None]. *)

Definition option_elim (d : nat) (o : natoption) : nat :=
  match o with
  | Some n' => n'
  | None => d
  end.

(** **** Exercise: 2 stars, standard (hd_error)

    Используя ту же идею, исправьте функцию [hd], определённую ранее, так, чтобы
    нам не пришлось передавать значение по умолчанию для случая [nil].  *)

Definition hd_error (l : natlist) : natoption
  (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.

Example test_hd_error1 : hd_error [] = None.
 (* FILL IN HERE *) Admitted.

Example test_hd_error2 : hd_error [1] = Some 1.
 (* FILL IN HERE *) Admitted.

Example test_hd_error3 : hd_error [5;6] = Some 5.
 (* FILL IN HERE *) Admitted.

(** [] *)

(** **** Exercise: 1 star, standard, optional (option_elim_hd)

    Это упражнение связывает вашу [hd_error] с более ранней [hd]. *)

Theorem option_elim_hd : forall (l:natlist) (default:nat),
  hd default l = option_elim default (hd_error l).
Proof.
  (* FILL IN HERE *) Admitted.
(** [] *)

End NatList.

(* ################################################################# *)
(** * Частичные функции *)

(** В качестве последней иллюстрации того, как можно определять типы данных в
    Coq, ниже мы введём тип данных _частичных функций_, аналогичный
    ассоциативным массивам (aka словарям), которые легко найти в любом другом
    языке программирования. *)

(** Во-первых, определим новый индуктивный тип данных [id], который будет
    выступать в качестве "ключей" в наших словарях. *)

Inductive id : Type :=
  | Id (n : nat).

(** Внутри [id] лежит просто число.  Введение отдельного типа данных,
    оборачивающего каждое число тэгом [Id], делает определения более читаемыми
    и дарит нам гибкость в позднейшем изменении внутреннего представления [Id],
    если впоследствии нам это потребуется. *)

(** Также мы захотим проверять [id] на равенство: *)

Definition eqb_id (x1 x2 : id) :=
  match x1, x2 with
  | Id n1, Id n2 => n1 =? n2
  end.

(** **** Exercise: 1 star, standard (eqb_id_refl) *)
Theorem eqb_id_refl : forall x, eqb_id x x = true.
Proof.
  (* FILL IN HERE *) Admitted.
(** [] *)

(** Далее, определим тип частичных функций: *)

Module PartialMap.
Export NatList.  (* сделаем доступными определения из NatList *)

Inductive partial_map : Type :=
  | empty
  | record (i : id) (v : nat) (m : partial_map).

(** Это объявление можно прочитать так: "Есть два способа построить
    [partial_map]: либо используя конструктор [empty], чтобы представить
    пустой словарь, либо применив конструктор [record] к ключу, значению и
    существующей [partial_map], чтобы построить новую [partial_map] с
    дополнительным отображением из ключа в значение." *)

(** Функция [update] перегружает запись для данного ключа в словаре с помощью
    перекрытия старого определения новым (либо просто добавляет новую запись,
    если такого ключа ещё нет). *)

Definition update (d : partial_map)
                  (x : id) (value : nat)
                  : partial_map :=
  record x value d.

(** Наконец, функция [find] ищет в [partial_map] заданный ключ.  Она возвращает
    [None], если ключ не был найден, и [Some val], если ключ был проассоциирован
    со значением [val]. Если один и тот же ключ проассоциирован с несколькими
    значениями, [find] вернёт самое первое, которое он встретит. *)

Fixpoint find (x : id) (d : partial_map) : natoption :=
  match d with
  | empty         => None
  | record y v d' => if eqb_id x y
                     then Some v
                     else find x d'
  end.

(** **** Exercise: 1 star, standard (update_eq) *)
Theorem update_eq :
  forall (d : partial_map) (x : id) (v: nat),
    find x (update d x v) = Some v.
Proof.
 (* FILL IN HERE *) Admitted.
(** [] *)

(** **** Exercise: 1 star, standard (update_neq) *)
Theorem update_neq :
  forall (d : partial_map) (x y : id) (o: nat),
    eqb_id x y = false -> find x (update d y o) = find x d.
Proof.
 (* FILL IN HERE *) Admitted.
(** [] *)
End PartialMap.

(* ################################################################# *)
(** * Poly: полиморфизм и функции высшего порядка *)

(* В последний раз напомню: пожалуйста, не публикуйте решения упражнений
   в легко доступных местах.  Спасибо!! *)

(* Спрячем некоторые неприятные предупреждения от Coq: *)
Set Warnings "-notation-overridden,-parsing,-deprecated-hint-without-locality".

(* ################################################################# *)
(** * Полиморфизм *)

(** В этой части лекции мы продолжаем наше изучение базовых концепций
    функционального программирования.  Главные идеи на сегодня --
    _полиморфизм_ (абстрагирование функций от конкретных типов данных,
    с которыми они работают) и _функции высшего порядка_ (работа с функциями
    как с данными).  Начнём с полиморфизма. *)

(* ================================================================= *)
(** ** Полиморфные списки *)

(** В первой части лекции, мы работали только со списками, содержащими
    числа.  Очевидно, интересным программам также нужно уметь работать со
    списками, элементы которых могут браться из других типов -- списки
    логических значений, списки списков и т.д..  Мы _могли бы_ просто определять
    по индуктивному типу данных на каждый из случаев, как-то вот так... *)

Inductive boollist : Type :=
  | bool_nil
  | bool_cons (b : bool) (l : boollist).

(** ... на это Вас очень быстро утомит, во-первых потому что Вам придётся
    придумывать новые имена для конструкторов каждого типа данных, но ещё и
    потому, что Вам придётся заново определять все функции для работы со
    списками ([length], [rev] и т.д.), и, более того, заново доказывать все их
    свойства ([rev_length], [app_assoc] и т.д.) для каждого нового определения
    типа данных. *)

(** Чтобы избежать таких самоповторов, Coq поддерживает _полиморфные_
    определения индуктивных типов.  Например, вот тип данных _полиморфных
    списков_. *)

Inductive list (X:Type) : Type :=
  | nil
  | cons (x : X) (l : list X).

(** Это определение в точности такое же, как определение [natlist] из
    первой части лекции, разве что тип [nat] аргумента в конструкторе [cons]
    был заменён на [X], где имя [X] вводится как имя аргумента в заголовке
    определения; наконец, вхождения [natlist] в типы конструкторов были заменены
    на [list X].

    Какого рода штукой является сам [list]?  Хороший способ думать о ней такой:
    определение [list] -- это _функция_ из [Типов] в [Индуктивные] определения;
    или, короче говоря, [list] это функция из [Типов] в [Типы].  Для любого
    конкретного типа [X], тип [list X] это [Индуктивно] определённое множество
    списков, чьи элементы имеют тип [X]. *)

Check list : Type -> Type.

(** [X] из определения [list] автоматически становится параметром
    конструкторов [nil] и [cons] -- то есть, [nil] и [cons] теперь являются
    полиморфными конструкторами; когда мы их используем, мы теперь должны
    предоставлять первый аргумент -- собственно, тип элементов списка, который
    мы строим. Например, [nil nat] конструирует пустой список
    с элементами типа [nat]. *)

Check (nil nat) : list nat.

(** Похожим образом, [cons nat] добавляет элемент типа [nat] к списку типа
    [list nat]. Вот пример формирования списка, содержащего единственное
    натуральное число 3. *)

Check (cons nat 3 (nil nat)) : list nat.

(** Какой же может быть тип у [nil]? Можно попробовать прочитать его из
    определения [list X], но оно опускает ввод [X], являющегося параметром для
    [list]. [Type -> list X], в свою очередь, не объясняет, откуда берётся [X].
    [(X : Type) -> list X] -- уже ближе. Нотация в Coq следующая:
    [forall X : Type, list X]. *)

Check nil : forall X : Type, list X.

(** Аналогично, тип [cons] из определения выглядит похоже на
    [X -> list X -> list X], но, используя тот же принцип, требующий
    объяснить происхождение [X], приводит к типу
    [forall X, X -> list X -> list X]. *)

Check cons : forall X : Type, X -> list X -> list X.

(** (Заметка о нотации: в файлах .v, квантор "forall" пишется явно,
    буквами.  В соответствующих файлах HTML (а также в том, как некоторые IDE
    показывают файлы .v -- зависит от их настроек отображения), [forall] обычно
    отображается как стандартное математическое "перевёрнутое A," однако вы всё
    равно увидите явное "forall" в паре мест.  Это просто причуды генерации
    текста -- разницы в значении нет.) *)

(** То, что нам приходится указывать аргумент-тип при каждом использовании
    конструктора списка достаточно утруждающе; далее мы увидим, как можно
    облегчить нотацию. *)

Check (cons nat 2 (cons nat 1 (nil nat)))
      : list nat.

(** Теперь мы можем оглядеться, вернуться и выписать полиморфные версии
    всех функций, работающих со списками, которые мы определили ранее.  Вот,
    например, [repeat]: *)

Fixpoint repeat (X : Type) (x : X) (count : nat) : list X :=
  match count with
  | 0 => nil X
  | S count' => cons X x (repeat X x count')
  end.

(** Как было с [nil] и [cons], мы можем использовать [repeat], применяя
    его сначала к типу, а затем к элементу этого типа (и числу): *)

Example test_repeat1 :
  repeat nat 4 2 = cons nat 4 (cons nat 4 (nil nat)).
Proof. reflexivity. Qed.

(** Чтобы использовать [repeat] для построения списков других типов, мы
    просто _инстанциируем_ его с подходящим типовым параметром: *)

Example test_repeat2 :
  repeat bool false 1 = cons bool false (nil bool).
Proof. reflexivity. Qed.

(** **** Exercise: 2 stars, standard, optional (mumble_grumble)

    Рассмотрим следующие два индуктивных типа данных. *)

Module MumbleGrumble.

Inductive mumble : Type :=
  | a
  | b (x : mumble) (y : nat)
  | c.

Inductive grumble (X:Type) : Type :=
  | d (m : mumble)
  | e (x : X).

(** Какие из следующих значений имеют тип [grumble X] для некоторого [X]?
    (Допишите ДА или НЕТ к каждой строчке.)
      - [d (b a 5)]
      - [d mumble (b a 5)]
      - [d bool (b a 5)]
      - [e bool true]
      - [e mumble (b c 0)]
      - [e bool (b c 0)]
      - [c]  *)
(* FILL IN HERE *)
End MumbleGrumble.
(** [] *)

(* ----------------------------------------------------------------- *)
(** *** Вывод аннотаций типов *)

(** Давайте вновь выпишем определение [repeat], но в этот раз мы не будем
    указывать типы аргументов.  Примет ли Coq такое определение? *)

Fixpoint repeat' X x count : list X :=
  match count with
  | 0        => nil X
  | S count' => cons X x (repeat' X x count')
  end.

(** Ну конечно.  Посмотрим, какой же тип он выдал [repeat']... *)

Check repeat'
  : forall X : Type, X -> nat -> list X.
Check repeat
  : forall X : Type, X -> nat -> list X.

(** У него в точности такой же тип, как и у [repeat].  Coq оказался
    способен использовать _вывод типов_, чтобы выяснить, какие типы должны быть
    у [X], [x] и [count] на основе того, как они используются.  Например, раз
    [X] используется как аргумент [cons], он должен быть [Типом], ведь
    [cons] своим первым аргументом ожидает [Type]; сопоставление [count]
    с [0] и [S] значит, что он должен быть [nat]; и так далее.

    Это мощное свойство системы значит, что нам не придётся всегда и везде
    выписывать все аннотации типов; однако, явные аннотации типов всё ещё могут
    быть полезны для документации и проверок на осмысленность, так что мы всё же
    продолжим их использовать бОльшую часть времени. *)

(* ----------------------------------------------------------------- *)
(** *** Синтез типового аргумента *)

(** Чтобы использовать полиморфную функцию, нам нужно передать ей
    какое-то количество типов помимо её остальных аргументов. Например,
    рекурсивный вызов в теле функции [repeat] должен передать тип [X].
    Но раз второй аргумент функции [repeat] обязан быть элементом [X],
    выглядит совершенно очевидным, что первый аргумент может быть равен
    только [X] -- зачем же нам тогда выписывать его явно?

    К счастью, Coq позволяет нам избежать такого рода повторов. Вместо любого
    типового аргумента мы можем написать "дырку" [_], которую можно прочитать
    как "Пожалуйста, постарайся выяснить сам, что сюда нужно подставить".
    Точнее говоря, когда Coq встречает [_], он будет пытаться _унифицировать_
    всю локально доступную информацию -- тип применяемой функции, типы других
    аргументов, а также тип, ожидаемый контекстом, в котором появляется
    применение -- чтобы выяснить, какой конкретный тип должен стоять
    на месте [_].

    Это может звучать знакомо к выводу типовых аннотаций -- и, действительно,
    обе процедуры полагаются на одни и те же базовые механизмы. Вместо того,
    чтобы просто опустить типы некоторых аргументов функции, вроде

      repeat' X x count : list X :=

    мы точно так же можем заменить типы дырками

      repeat' (X : _) (x : _) (count : _) : list X :=

    чтобы попросить Coq попытаться вывести недостающую информацию.

    Используя дырки, функцию [repeat] можно записать вот так: *)

Fixpoint repeat'' X x count : list X :=
  match count with
  | 0        => nil _
  | S count' => cons _ x (repeat'' _ x count')
  end.

(** В данном случае мы особо не сэкономили, записав [_] вместо [X].
    Однако во многих случаях разница в объёме кода и читаемости нетривиальная.
    Например, пусть мы хотим выписать список, содержащий числа [1], [2], [3].
    Вместо такого... *)

Definition list123 :=
  cons nat 1 (cons nat 2 (cons nat 3 (nil nat))).

(** ...мы можем использовать дырки, чтобы записать тот же список вот так: *)

Definition list123' :=
  cons _ 1 (cons _ 2 (cons _ 3 (nil _))).

(* ----------------------------------------------------------------- *)
(** *** Неявные аргументы *)

(** На самом деле, мы можем пойти ещё дальше и вообще не писать [_] в
    большинстве случаев, попросив Coq _всегда_ выводить типовые аргументы
    некоторой функции.

    Директива [Arguments] сообщает имя функции (либо конструктора) и далее
    перечисляет имена аргументов (начиная с первых), которые нужно считать
    неявными; каждое такое имя окружено фигурными скобками. *)

Arguments nil {X}.
Arguments cons {X}.
Arguments repeat {X}.

(** Теперь в данном примере нам вообще не нужно указывать типовые аргументы: *)

Definition list123'' := cons 1 (cons 2 (cons 3 nil)).

(** В качестве альтернативы, мы можем объявить аргумент неявным ещё на
    этапе объявдения функции, окружив его в фигурные скобки вместо круглых.
    Например: *)

Fixpoint repeat''' {X : Type} (x : X) (count : nat) : list X :=
  match count with
  | 0        => nil
  | S count' => cons x (repeat''' x count')
  end.

(** (Обратите внимание, что нам даже не нужно было предоставлять типовой
    аргумент в рекурсивном вызове [repeat'''].  Действительно, было бы
    некорректно его предоставлять, поскольку Coq его и не ожидает.)

    Мы будем использовать такой стиль везде, где это возможно, но мы продолжим
    использовать явные объявления [Argument] для конструкторов [Индуктивных]
    типов данных.  Причина заключается в том, что, объявив параметр индуктивного
    типа неявным, мы сделаем параметр неявным не только для конструкторов, но и
    для самого объявления типа.  Например, рассмотрим следующее альтернативное
    определение [list]: *)

Inductive list' {X:Type} : Type :=
  | nil'
  | cons' (x : X) (l : list').

(** Поскольку [X] объявлен неявным для _всего_ определения индуктивного типа,
    включая сам [list'], мы теперь вынуждены писать просто [list'] вне
    зависимости от того, о каких списках мы говорим, вместо того чтобы
    писать [list' nat], [list' bool] или что-то ещё; это шаг слишком далеко. *)

(** Давайте завершим, переопределив некоторые стандартные функции на
    полимфорных списках... *)

Fixpoint app {X : Type} (l1 l2 : list X) : list X :=
  match l1 with
  | nil      => l2
  | cons h t => cons h (app t l2)
  end.

Fixpoint rev {X:Type} (l:list X) : list X :=
  match l with
  | nil      => nil
  | cons h t => app (rev t) (cons h nil)
  end.

Fixpoint length {X : Type} (l : list X) : nat :=
  match l with
  | nil => 0
  | cons _ l' => S (length l')
  end.

Example test_rev1 :
  rev (cons 1 (cons 2 nil)) = (cons 2 (cons 1 nil)).
Proof. reflexivity. Qed.

Example test_rev2:
  rev (cons true nil) = cons true nil.
Proof. reflexivity. Qed.

Example test_length1: length (cons 1 (cons 2 (cons 3 nil))) = 3.
Proof. reflexivity. Qed.

(* ----------------------------------------------------------------- *)
(** *** Явная передача типовых аргументов *)

(** Всё же есть одна небольшая проблема с объявлением аргументов неявными;
    она состоит в том, что иногда у Coq всё же нет достаточной локальной
    информации, чтобы определить типовой аргумент; в таких случаях нужно
    сообщить Coq, что прям вот в это случае мы хотем передать аргумент явно.
    Для этого, предположим, мы напишем следующее: *)

Fail Definition mynil := nil.

(** (The [Fail] qualifier that appears before [Definition] can be
    used with _any_ command, and is used to ensure that that command
    indeed fails when executed. If the command does fail, Coq prints
    the corresponding error message, but continues processing the rest
    of the file.)

    Here, Coq gives us an error because it doesn't know what type
    argument to supply to [nil].  We can help it by providing an
    explicit type declaration (so that Coq has more information
    available when it gets to the "application" of [nil]): *)

Definition mynil : list nat := nil.

(** Также можно сделать все аргументы явными,
    добавив [@] перед именем функции. *)

Check @nil : forall X : Type, list X.

Definition mynil' := @nil nat.

(** Using argument synthesis and implicit arguments, we can
    define convenient notation for lists, as before.  Since we have
    made the constructor type arguments implicit, Coq will know to
    automatically infer these when we use the notations. *)

Notation "x :: y" := (cons x y)
                     (at level 60, right associativity).
Notation "[ ]" := nil.
Notation "[ x ; .. ; y ]" := (cons x .. (cons y []) ..).
Notation "x ++ y" := (app x y)
                     (at level 60, right associativity).

(** Now lists can be written just the way we'd hope: *)

Definition list123''' := [1; 2; 3].

(* ----------------------------------------------------------------- *)
(** *** Exercises *)

(** **** Exercise: 2 stars, standard (poly_exercises)

    Here are a few simple exercises, just like ones in the first part
    of the lecture, for practice with polymorphism.  Complete the proofs
    below. *)

Theorem app_nil_r : forall (X:Type), forall l:list X,
  l ++ [] = l.
Proof.
  (* FILL IN HERE *) Admitted.

Theorem app_assoc : forall A (l m n:list A),
  l ++ m ++ n = (l ++ m) ++ n.
Proof.
  (* FILL IN HERE *) Admitted.

Lemma app_length : forall (X:Type) (l1 l2 : list X),
  length (l1 ++ l2) = length l1 + length l2.
Proof.
  (* FILL IN HERE *) Admitted.
(** [] *)

(** **** Exercise: 2 stars, standard (more_poly_exercises)

    Here are some slightly more interesting ones... *)

Theorem rev_app_distr: forall X (l1 l2 : list X),
  rev (l1 ++ l2) = rev l2 ++ rev l1.
Proof.
  (* FILL IN HERE *) Admitted.

Theorem rev_involutive : forall X : Type, forall l : list X,
  rev (rev l) = l.
Proof.
  (* FILL IN HERE *) Admitted.
(** [] *)

(* ================================================================= *)
(** ** Полиморфные пары *)

(** Following the same pattern, the definition for pairs of
    numbers that we gave in the first part of the lecture can be generalized to
    _polymorphic pairs_, often called _products_: *)

Inductive prod (X Y : Type) : Type :=
| pair (x : X) (y : Y).

Arguments pair {X} {Y}.

(** As with lists, we make the type arguments implicit and define the
    familiar concrete notation. *)

Notation "( x , y )" := (pair x y).

(** Мы вновь можем воспользоваться механизмом [Нотаций], чтобы определить
    стандартную нотацию для _типов-произведений_ (т.е. типов пар): *)

Notation "X * Y" := (prod X Y) : type_scope.

(** (Аннотация [: type_scope] сообщает Coq-у, что это сокращение
    можно использовать только при синтаксическом разборе типов, но не при
    разборе выражений.  Это позволяет избежать коллизий
    с символом умножения.) *)

(** It is easy at first to get [(x,y)] and [X*Y] confused.
    Remember that [(x,y)] is a _value_ built from two other values,
    while [X*Y] is a _type_ built from two other types.  If [x] has
    type [X] and [y] has type [Y], then [(x,y)] has type [X*Y]. *)

(** The first and second projection functions now look pretty
    much as they would in any functional programming language. *)

Definition fst {X Y : Type} (p : X * Y) : X :=
  match p with
  | (x, y) => x
  end.

Definition snd {X Y : Type} (p : X * Y) : Y :=
  match p with
  | (x, y) => y
  end.

(** The following function takes two lists and combines them
    into a list of pairs.  In other functional languages, it is often
    called [zip]; we call it [combine] for consistency with Coq's
    standard library. *)

Fixpoint combine {X Y : Type} (lx : list X) (ly : list Y)
           : list (X*Y) :=
  match lx, ly with
  | [], _ => []
  | _, [] => []
  | x :: tx, y :: ty => (x, y) :: (combine tx ty)
  end.

(** **** Exercise: 1 star, standard, optional (combine_checks)

    Try answering the following questions on paper and
    checking your answers in Coq:
    - What is the type of [combine] (i.e., what does [Check
      @combine] print?)
    - What does

        Compute (combine [1;2] [false;false;true;true]).

      print?

    [] *)

(** **** Exercise: 2 stars, standard, especially useful (split)

    The function [split] is the right inverse of [combine]: it takes a
    list of pairs and returns a pair of lists.  In many functional
    languages, it is called [unzip].

    Fill in the definition of [split] below.  Make sure it passes the
    given unit test. *)

Fixpoint split {X Y : Type} (l : list (X*Y)) : (list X) * (list Y)
  (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.

Example test_split:
  split [(1,false);(2,false)] = ([1;2],[false;false]).
Proof.
(* FILL IN HERE *) Admitted.
(** [] *)

(* ================================================================= *)
(** ** Полиморфные частичные значения *)

(** Our last polymorphic type for now is _polymorphic options_,
    which generalize [natoption] from the first part of the lecture.  (We put
    the definition inside a module because the standard library
    already defines [option] and it's this one that we want to use
    below.) *)

Module OptionPlayground.

Inductive option (X:Type) : Type :=
  | Some (x : X)
  | None.

Arguments Some {X}.
Arguments None {X}.

End OptionPlayground.

(** We can now rewrite the [nth_error] function so that it works
    with any type of lists. *)

Fixpoint nth_error {X : Type} (l : list X) (n : nat)
                   : option X :=
  match l with
  | nil => None
  | a :: l' => match n with
               | O => Some a
               | S n' => nth_error l' n'
               end
  end.

Example test_nth_error1 : nth_error [4;5;6;7] 0 = Some 4.
Proof. reflexivity. Qed.
Example test_nth_error2 : nth_error [[1];[2]] 1 = Some [2].
Proof. reflexivity. Qed.
Example test_nth_error3 : nth_error [true] 2 = None.
Proof. reflexivity. Qed.

(** **** Exercise: 1 star, standard, optional (hd_error_poly)

    Complete the definition of a polymorphic version of the
    [hd_error] function from the first part of the lecture. Be sure that it
    passes the unit tests below. *)

Definition hd_error {X : Type} (l : list X) : option X
  (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.

(** Once again, to force the implicit arguments to be explicit,
    we can use [@] before the name of the function. *)

Check @hd_error : forall X : Type, list X -> option X.

Example test_hd_error1 : hd_error [1;2] = Some 1.
 (* FILL IN HERE *) Admitted.
Example test_hd_error2 : hd_error  [[1];[2]]  = Some [1].
 (* FILL IN HERE *) Admitted.
(** [] *)

(* ################################################################# *)
(** * Функции в качестве данных *)

(** Like most modern programming languages -- especially other
    "functional" languages, including OCaml, Haskell, Racket, Scala,
    Clojure, etc. -- Coq treats functions as first-class citizens,
    allowing them to be passed as arguments to other functions,
    returned as results, stored in data structures, etc. *)

(* ================================================================= *)
(** ** Функции высшего порядка *)

(** Functions that manipulate other functions are often called
    _higher-order_ functions.  Here's a simple one: *)

Definition doit3times {X : Type} (f : X->X) (n : X) : X :=
  f (f (f n)).

(** The argument [f] here is itself a function (from [X] to
    [X]); the body of [doit3times] applies [f] three times to some
    value [n]. *)

Check @doit3times : forall X : Type, (X -> X) -> X -> X.

Example test_doit3times: doit3times minustwo 9 = 3.
Proof. reflexivity. Qed.

Example test_doit3times': doit3times negb true = false.
Proof. reflexivity. Qed.

(* ================================================================= *)
(** ** Фильтрация списка *)

(** Here is a more useful higher-order function, taking a list
    of [X]s and a _predicate_ on [X] (a function from [X] to [bool])
    and "filtering" the list, returning a new list containing just
    those elements for which the predicate returns [true]. *)

Fixpoint filter {X:Type} (test: X->bool) (l:list X) : list X :=
  match l with
  | [] => []
  | h :: t =>
    if test h then h :: (filter test t)
    else filter test t
  end.

(** For example, if we apply [filter] to the predicate [even]
    and a list of numbers [l], it returns a list containing just the
    even members of [l]. *)

Example test_filter1: filter even [1;2;3;4] = [2;4].
Proof. reflexivity. Qed.

Definition length_is_1 {X : Type} (l : list X) : bool :=
  (length l) =? 1.

Example test_filter2:
    filter length_is_1
           [ [1; 2]; [3]; [4]; [5;6;7]; []; [8] ]
  = [ [3]; [4]; [8] ].
Proof. reflexivity. Qed.

(** We can use [filter] to give a concise version of the
    [countoddmembers] function defined earlier. *)

Definition countoddmembers' (l:list nat) : nat :=
  length (filter odd l).

Example test_countoddmembers'1:   countoddmembers' [1;0;3;1;4;5] = 4.
Proof. reflexivity. Qed.
Example test_countoddmembers'2:   countoddmembers' [0;2;4] = 0.
Proof. reflexivity. Qed.
Example test_countoddmembers'3:   countoddmembers' nil = 0.
Proof. reflexivity. Qed.

(* ================================================================= *)
(** ** Анонимные функции *)

(** It is arguably a little sad, in the example just above, to
    be forced to define the function [length_is_1] and give it a name
    just to be able to pass it as an argument to [filter], since we
    will probably never use it again.  Moreover, this is not an
    isolated example: when using higher-order functions, we often want
    to pass as arguments "one-off" functions that we will never use
    again; having to give each of these functions a name would be
    tedious.

    Fortunately, there is a better way.  We can construct a function
    "on the fly" without declaring it at the top level or giving it a
    name. *)

Example test_anon_fun':
  doit3times (fun n => n * n) 2 = 256.
Proof. reflexivity. Qed.

(** Выражение [(fun n => n * n)] можно прочитать как "функция, которая, получив
    число [n], возвращает [n * n]." *)

(** Here is the [filter] example, rewritten to use an anonymous
    function. *)

Example test_filter2':
    filter (fun l => (length l) =? 1)
           [ [1; 2]; [3]; [4]; [5;6;7]; []; [8] ]
  = [ [3]; [4]; [8] ].
Proof. reflexivity. Qed.

(** **** Exercise: 2 stars, standard (filter_even_gt7)

    Use [filter] (instead of [Fixpoint]) to write a Coq function
    [filter_even_gt7] that takes a list of natural numbers as input
    and returns a list of just those that are even and greater than
    7. *)

Definition filter_even_gt7 (l : list nat) : list nat
  (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.

Example test_filter_even_gt7_1 :
  filter_even_gt7 [1;2;6;9;10;3;12;8] = [10;12;8].
 (* FILL IN HERE *) Admitted.

Example test_filter_even_gt7_2 :
  filter_even_gt7 [5;2;6;19;129] = [].
 (* FILL IN HERE *) Admitted.
(** [] *)

(** **** Exercise: 3 stars, standard (partition)

    Use [filter] to write a Coq function [partition]:

      partition : forall X : Type,
                  (X -> bool) -> list X -> list X * list X

   Given a set [X], a predicate of type [X -> bool] and a [list X],
   [partition] should return a pair of lists.  The first member of the
   pair is the sublist of the original list containing the elements
   that satisfy the test, and the second is the sublist containing
   those that fail the test.  The order of elements in the two
   sublists should be the same as their order in the original list. *)

Definition partition {X : Type}
                     (test : X -> bool)
                     (l : list X)
                   : list X * list X
  (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.

Example test_partition1: partition odd [1;2;3;4;5] = ([1;3;5], [2;4]).
(* FILL IN HERE *) Admitted.
Example test_partition2: partition (fun x => false) [5;9;0] = ([], [5;9;0]).
(* FILL IN HERE *) Admitted.
(** [] *)

(* ================================================================= *)
(** ** Поэлементное отображение *)

(** Следующая полезная функция высшего порядка называется [map]. *)

Fixpoint map {X Y : Type} (f : X->Y) (l : list X) : list Y :=
  match l with
  | []     => []
  | h :: t => (f h) :: (map f t)
  end.

(** It takes a function [f] and a list [ l = [n1, n2, n3, ...] ]
    and returns the list [ [f n1, f n2, f n3,...] ], where [f] has
    been applied to each element of [l] in turn.  For example: *)

Example test_map1: map (fun x => plus 3 x) [2;0;2] = [5;3;5].
Proof. reflexivity. Qed.

(** The element types of the input and output lists need not be
    the same, since [map] takes _two_ type arguments, [X] and [Y]; it
    can thus be applied to a list of numbers and a function from
    numbers to booleans to yield a list of booleans: *)

Example test_map2:
  map odd [2;1;2;5] = [false;true;false;true].
Proof. reflexivity. Qed.

(** It can even be applied to a list of numbers and
    a function from numbers to _lists_ of booleans to
    yield a _list of lists_ of booleans: *)

Example test_map3:
    map (fun n => [even n;odd n]) [2;1;2;5]
  = [[true;false];[false;true];[true;false];[false;true]].
Proof. reflexivity. Qed.

(* ----------------------------------------------------------------- *)
(** *** Exercises *)

(** **** Exercise: 3 stars, standard (map_rev)

    Show that [map] and [rev] commute.  You may need to define an
    auxiliary lemma. *)

Theorem map_rev : forall (X Y : Type) (f : X -> Y) (l : list X),
  map f (rev l) = rev (map f l).
Proof.
  (* FILL IN HERE *) Admitted.
(** [] *)

(** **** Exercise: 2 stars, standard, especially useful (flat_map)

    The function [map] maps a [list X] to a [list Y] using a function
    of type [X -> Y].  We can define a similar function, [flat_map],
    which maps a [list X] to a [list Y] using a function [f] of type
    [X -> list Y].  Your definition should work by 'flattening' the
    results of [f], like so:

        flat_map (fun n => [n;n+1;n+2]) [1;5;10]
      = [1; 2; 3; 5; 6; 7; 10; 11; 12].
*)

Fixpoint flat_map {X Y: Type} (f: X -> list Y) (l: list X)
                   : list Y
  (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.

Example test_flat_map1:
  flat_map (fun n => [n;n;n]) [1;5;4]
  = [1; 1; 1; 5; 5; 5; 4; 4; 4].
 (* FILL IN HERE *) Admitted.
(** [] *)

(** Списки -- не единственный индуктивный тип, для которого можно осмысленно
    определить [map]. Вот определение [map] для типа [option]: *)

Definition option_map {X Y : Type} (f : X -> Y) (xo : option X)
                      : option Y :=
  match xo with
  | None => None
  | Some x => Some (f x)
  end.

(** **** Exercise: 2 stars, standard, optional (implicit_args)

    The definitions and uses of [filter] and [map] use implicit
    arguments in many places.  Replace the curly braces around the
    implicit arguments with parentheses, and then fill in explicit
    type parameters where necessary and use Coq to check that you've
    done so correctly.  (This exercise is not to be turned in; it is
    probably easiest to do it on a _copy_ of this file that you can
    throw away afterwards.)
*)
(** [] *)

(* ================================================================= *)
(** ** Свёртка *)

(** An even more powerful higher-order function is called
    [fold].  This function is the inspiration for the "[reduce]"
    operation that lies at the heart of Google's map/reduce
    distributed programming framework. *)

Fixpoint fold {X Y: Type} (f : X->Y->Y) (l : list X) (b : Y)
                         : Y :=
  match l with
  | nil => b
  | h :: t => f h (fold f t b)
  end.

(** Intuitively, the behavior of the [fold] operation is to
    insert a given binary operator [f] between every pair of elements
    in a given list.  For example, [ fold plus [1;2;3;4] ] intuitively
    means [1+2+3+4].  To make this precise, we also need a "starting
    element" that serves as the initial second input to [f].  So, for
    example,

       fold plus [1;2;3;4] 0

    yields

       1 + (2 + (3 + (4 + 0))).

    Some more examples: *)

Check (fold andb) : list bool -> bool -> bool.

Example fold_example1 :
  fold andb [true;true;false;true] true = false.
Proof. reflexivity. Qed.

Example fold_example2 :
  fold mult [1;2;3;4] 1 = 24.
Proof. reflexivity. Qed.

Example fold_example3 :
  fold app  [[1];[];[2;3];[4]] [] = [1;2;3;4].
Proof. reflexivity. Qed.

Example foldexample4 :
  fold (fun l n => length l + n) [[1];[];[2;3;2];[4]] 0 = 5.
Proof. reflexivity. Qed.


(** **** Exercise: 1 star, standard, optional (fold_types_different)

    Observe that the type of [fold] is parameterized by _two_ type
    variables, [X] and [Y], and the parameter [f] is a binary operator
    that takes an [X] and a [Y] and returns a [Y].  Can you think of a
    situation where it would be useful for [X] and [Y] to be
    different? *)

(* FILL IN HERE

    [] *)

(* ================================================================= *)
(** ** Функции, конструирующие функции *)

(** Most of the higher-order functions we have talked about so
    far take functions as arguments.  Let's look at some examples that
    involve _returning_ functions as the results of other functions.
    To begin, here is a function that takes a value [x] (drawn from
    some type [X]) and returns a function from [nat] to [X] that
    yields [x] whenever it is called, ignoring its [nat] argument. *)

Definition constfun {X: Type} (x: X) : nat -> X :=
  fun (k:nat) => x.

Definition ftrue := constfun true.

Example constfun_example1 : ftrue 0 = true.
Proof. reflexivity. Qed.

Example constfun_example2 : (constfun 5) 99 = 5.
Proof. reflexivity. Qed.

(** In fact, the multiple-argument functions we have already
    seen are also examples of passing functions as data.  To see why,
    recall the type of [plus]. *)

Check plus : nat -> nat -> nat.

(** Each [->] in this expression is actually a _binary_ operator
    on types.  This operator is _right-associative_, so the type of
    [plus] is really a shorthand for [nat -> (nat -> nat)] -- i.e., it
    can be read as saying that "[plus] is a one-argument function that
    takes a [nat] and returns a one-argument function that takes
    another [nat] and returns a [nat]."  In the examples above, we
    have always applied [plus] to both of its arguments at once, but
    if we like we can supply just the first.  This is called _partial
    application_. *)

Definition plus3 := plus 3.
Check plus3 : nat -> nat.

Example test_plus3 :    plus3 4 = 7.
Proof. reflexivity. Qed.
Example test_plus3' :   doit3times plus3 0 = 9.
Proof. reflexivity. Qed.
Example test_plus3'' :  doit3times (plus 3) 0 = 9.
Proof. reflexivity. Qed.

(* ################################################################# *)
(** * Additional Exercises *)

Module Exercises.

(** **** Exercise: 2 stars, standard (fold_length)

    Many common functions on lists can be implemented in terms of
    [fold].  For example, here is an alternative definition of [length]: *)

Definition fold_length {X : Type} (l : list X) : nat :=
  fold (fun _ n => S n) l 0.

Example test_fold_length1 : fold_length [4;7;0] = 3.
Proof. reflexivity. Qed.

(** Prove the correctness of [fold_length].  (Hint: It may help to
    know that [reflexivity] simplifies expressions a bit more
    aggressively than [simpl] does -- i.e., you may find yourself in a
    situation where [simpl] does nothing but [reflexivity] solves the
    goal.) *)

Theorem fold_length_correct : forall X (l : list X),
  fold_length l = length l.
Proof.
(* FILL IN HERE *) Admitted.
(** [] *)

(** **** Exercise: 3 stars, standard (fold_map)

    We can also define [map] in terms of [fold].  Finish [fold_map]
    below. *)

Definition fold_map {X Y: Type} (f: X -> Y) (l: list X) : list Y
  (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.

(** Write down a theorem [fold_map_correct] stating that [fold_map] is
    correct, and prove it in Coq.  (Hint: again, remember that
    [reflexivity] simplifies expressions a bit more aggressively than
    [simpl].) *)

(* FILL IN HERE *)

(* Do not modify the following line: *)
Definition manual_grade_for_fold_map : option (nat*string) := None.
(** [] *)

(** **** Exercise: 2 stars, advanced (currying)

    The type [X -> Y -> Z] can be read as describing functions that
    take two arguments, one of type [X] and another of type [Y], and
    return an output of type [Z]. Strictly speaking, this type is
    written [X -> (Y -> Z)] when fully parenthesized.  That is, if we
    have [f : X -> Y -> Z], and we give [f] an input of type [X], it
    will give us as output a function of type [Y -> Z].  If we then
    give that function an input of type [Y], it will return an output
    of type [Z]. That is, every function in Coq takes only one input,
    but some functions return a function as output. This is precisely
    what enables partial application, as we saw above with [plus3].

    By contrast, functions of type [X * Y -> Z] -- which when fully
    parenthesized is written [(X * Y) -> Z] -- require their single
    input to be a pair.  Both arguments must be given at once; there
    is no possibility of partial application.

    It is possible to convert a function between these two types.
    Converting from [X * Y -> Z] to [X -> Y -> Z] is called
    _currying_, in honor of the logician Haskell Curry.  Converting
    from [X -> Y -> Z] to [X * Y -> Z] is called _uncurrying_.  *)

(** We can define currying as follows: *)

Definition prod_curry {X Y Z : Type}
  (f : X * Y -> Z) (x : X) (y : Y) : Z := f (x, y).

(** As an exercise, define its inverse, [prod_uncurry].  Then prove
    the theorems below to show that the two are inverses. *)

Definition prod_uncurry {X Y Z : Type}
  (f : X -> Y -> Z) (p : X * Y) : Z
  (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.

(** As a (trivial) example of the usefulness of currying, we can use it
    to shorten one of the examples that we saw above: *)

Example test_map1': map (plus 3) [2;0;2] = [5;3;5].
Proof. reflexivity. Qed.

(** Thought exercise: before running the following commands, can you
    calculate the types of [prod_curry] and [prod_uncurry]? *)

Check @prod_curry.
Check @prod_uncurry.

Theorem uncurry_curry : forall (X Y Z : Type)
                        (f : X -> Y -> Z)
                        x y,
  prod_curry (prod_uncurry f) x y = f x y.
Proof.
  (* FILL IN HERE *) Admitted.

Theorem curry_uncurry : forall (X Y Z : Type)
                        (f : (X * Y) -> Z) (p : X * Y),
  prod_uncurry (prod_curry f) p = f p.
Proof.
  (* FILL IN HERE *) Admitted.
(** [] *)

(** **** Exercise: 2 stars, advanced (nth_error_informal)

    Recall the definition of the [nth_error] function:

   Fixpoint nth_error {X : Type} (l : list X) (n : nat) : option X :=
     match l with
     | [] => None
     | a :: l' => if n =? O then Some a else nth_error l' (pred n)
     end.

   Write a careful informal proof of the following theorem:

   forall X l n, length l = n -> @nth_error X l n = None

   Make sure to state the induction hypothesis _explicitly_.
*)
(* FILL IN HERE *)

(* Do not modify the following line: *)
Definition manual_grade_for_informal_proof : option (nat*string) := None.
(** [] *)

(* ================================================================= *)
(** ** Church Numerals (Advanced) *)

(** The following exercises explore an alternative way of defining
    natural numbers using the _Church numerals_, which are named after
    their inventor, the mathematician Alonzo Church.  We can represent
    a natural number [n] as a function that takes a function [f] as a
    parameter and returns [f] iterated [n] times. *)

Module Church.
Definition cnat := forall X : Type, (X -> X) -> X -> X.

(** Let's see how to write some numbers with this notation. Iterating
    a function once should be the same as just applying it.  Thus: *)

Definition one : cnat :=
  fun (X : Type) (f : X -> X) (x : X) => f x.

(** Similarly, [two] should apply [f] twice to its argument: *)

Definition two : cnat :=
  fun (X : Type) (f : X -> X) (x : X) => f (f x).

(** Defining [zero] is somewhat trickier: how can we "apply a function
    zero times"?  The answer is actually simple: just return the
    argument untouched. *)

Definition zero : cnat :=
  fun (X : Type) (f : X -> X) (x : X) => x.

(** More generally, a number [n] can be written as [fun X f x => f (f
    ... (f x) ...)], with [n] occurrences of [f].  Let's informally
    notate that as [fun X f x => f^n x], with the convention that [f^0 x]
    is just [x]. Note how the [doit3times] function we've defined
    previously is actually just the Church representation of [3]. *)

Definition three : cnat := @doit3times.

(** So [n X f x] represents "do it [n] times", where [n] is a Church
    numerals and "it" means applying [f] starting with [x].

    Another way to think about the Church representation is that
    function [f] represents the successor operation on [X], and value
    [x] represents the zero element of [X].  We could even rewrite
    with those names to make it clearer: *)

Definition zero' : cnat :=
  fun (X : Type) (succ : X -> X) (zero : X) => zero.
Definition one' : cnat :=
  fun (X : Type) (succ : X -> X) (zero : X) => succ zero.
Definition two' : cnat :=
  fun (X : Type) (succ : X -> X) (zero : X) => succ (succ zero).

(** If we passed in [S] as [succ] and [O] as [zero], we'd even get the Peano
    naturals as a result: *)

Example zero_church_peano : zero nat S O = 0.
Proof. reflexivity. Qed.

Example one_church_peano : one nat S O = 1.
Proof. reflexivity. Qed.

Example two_church_peano : two nat S O = 2.
Proof. reflexivity. Qed.

(** But the intellectually exciting implication of the Church numerals
    is that we don't strictly need the natural numbers to be built-in
    to a functional programming language, or even to be definable with
    an inductive data type. It's possible to represent them purely (if
    not efficiently) with functions.

    Of course, it's not enough to represent numerals; we need to be
    able to do arithmetic with them. Show that we can by completing
    the definitions of the following functions. Make sure that the
    corresponding unit tests pass by proving them with
    [reflexivity]. *)

(** **** Exercise: 2 stars, advanced (church_scc) *)

(** Define a function that computes the successor of a Church numeral.
    Given a Church numeral [n], its successor [scc n] should iterate
    its function argument once more than [n]. That is, given [fun X f x
    => f^n x] as input, [scc] should produce [fun X f x => f^(n+1) x] as
    output. In other words, do it [n] times, then do it once more. *)

Definition scc (n : cnat) : cnat
  (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.

Example scc_1 : scc zero = one.
Proof. (* FILL IN HERE *) Admitted.

Example scc_2 : scc one = two.
Proof. (* FILL IN HERE *) Admitted.

Example scc_3 : scc two = three.
Proof. (* FILL IN HERE *) Admitted.

(** [] *)

(** **** Exercise: 3 stars, advanced (church_plus) *)

(** Define a function that computes the addition of two Church
    numerals.  Given [fun X f x => f^n x] and [fun X f x => f^m x] as
    input, [plus] should produce [fun X f x => f^(n + m) x] as output.
    In other words, do it [n] times, then do it [m] more times.

    Hint: the "zero" argument to a Church numeral need not be just
    [x]. *)

Definition plus (n m : cnat) : cnat
  (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.

Example plus_1 : plus zero one = one.
Proof. (* FILL IN HERE *) Admitted.

Example plus_2 : plus two three = plus three two.
Proof. (* FILL IN HERE *) Admitted.

Example plus_3 :
  plus (plus two two) three = plus one (plus three three).
Proof. (* FILL IN HERE *) Admitted.

(** [] *)

(** **** Exercise: 3 stars, advanced (church_mult) *)

(** Define a function that computes the multiplication of two Church
    numerals.

    Hint: the "successor" argument to a Church numeral need not be
    just [f].

    Warning: Coq will not let you pass [cnat] itself as the type [X]
    argument to a Church numeral; you will get a "Universe
    inconsistency" error. That is Coq's way of preventing a paradox in
    which a type contains itself. So leave the type argument
    unchanged. *)

Definition mult (n m : cnat) : cnat
  (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.

Example mult_1 : mult one one = one.
Proof. (* FILL IN HERE *) Admitted.

Example mult_2 : mult zero (plus three three) = zero.
Proof. (* FILL IN HERE *) Admitted.

Example mult_3 : mult two three = plus three three.
Proof. (* FILL IN HERE *) Admitted.

(** [] *)

(** **** Exercise: 3 stars, advanced (church_exp) *)

(** Exponentiation: *)

(** Define a function that computes the exponentiation of two Church
    numerals.

    Hint: the type argument to a Church numeral need not just be [X].
    But again, you cannot pass [cnat] itself as the type argument.
    Finding the right type can be tricky. *)

Definition exp (n m : cnat) : cnat
  (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.

Example exp_1 : exp two two = plus two two.
Proof. (* FILL IN HERE *) Admitted.

Example exp_2 : exp three zero = one.
Proof. (* FILL IN HERE *) Admitted.

Example exp_3 : exp three two = plus (mult two (mult two two)) one.
Proof. (* FILL IN HERE *) Admitted.

(** [] *)

End Church.
End Exercises.

(* 2025-03-19 13:21 *)
