(** * Списки и работа со структурами данных *)

(* ################################################################# *)
(** * Раздельная компиляция *)

(** Перед тем как начать эту лекцию, нам нужно импортировать
    все наши определения с прошлой лекции: *)

From Lectures Require Export Lecture1.
Module NatList.

(** Чтобы команда [Require] сработала, Coq-у нужно найти
    скомпилированную версию предыдущей лекции ([Lecture1.v]).
    Скомпилированная версия называется [Lecture1.vo] и выполняет ту же роль,
    что файлы [.class], полученные по исходникам на [.java], и файлы [.o],
    скомпилированные из файлов с расширением [.c].

    Чтобы скомпилировать [Lecture1.v] и получить [Lecture1.vo],
    в первую очередь убедитесь, что и [Lecture1.v], и [Lecture2.v], и
    [_CoqProject] находятся в текущей директории.

    Файл [_CoqProject] должен содержать единственную строчку:

      -Q . Lectures

    Эта настройка отображает текущий путь ("[.]", содержащий [Lecture1.v],
    [Lecture2.v], и т.д.) в префикс (aka "логическую директорию")
    "[Lectures]". Proof General, CoqIDE, и VSCoq читают [_CoqProject]
    автоматически, чтобы определить путь к скомпилированному файлу
    [Lecture1.vo], содержащему библиотеку [Lectures.Lecture1].

    При условии, что все файлы на месте, есть множество способов собрать
    [Lecture1.vo], как с помощью IDE, так и просто из командной строки.
    С помощью IDE:

     - Proof General можно заставить компилировать файл автоматически,
       в момент выполнения команды [Require] внутри PG, присвоив значение
       emacs-переменной [coq-compile-before-require], равное [t].
       Также эту опцию можно включить в меню: "Coq" > "Auto Compilation" >
       "Compile Before Require".

     - В CoqIDE: Открываем [Lecture1.v];
       затем в выпадающем списке "Compile" выбираем "Compile Buffer".

     - Пользователей VSCode приглашаем в терминал, инструкцию см. ниже.

    Чтобы скомпилировать [Lecture1.v] с помощью командной строки, нужно:

     - Запустить [make] с соответствующим файлом [.vo] в качестве таргета:

         make Lecture1.vo

       Таргет по умолчанию -- это все файлы в директории:

         make

     - Под капотом, [make] вызывает компилятор Coq, [coqc].  Если есть
       возможность, то используйте [make] вместо явного запуска [coqc]
       -- кроме запуска собственно калькулятора, [make] также вычисляет
       зависимости между исходными файлами, чтобы скомпилировать их в правильном
       порядке.  Но, конечно, в крайнем (но не слишком уж ужасном) случае,
       файлы можно компилировать вручную по ходу выполнения заданий.
       Например, перед началом работы над текущей лекцией, вам нужно будет
       запустить следующую команду:

        coqc -Q . Lectures Lecture1.v

       Далее, когда вы закончите работу над заданиями к этой лекции:

        coqc -Q . Lectures Lecture2.v

       (Чтобы подготовиться к следующей лекции).  Если по какой-либо причине
       файлы .vo пропадут или устареют, нужно будет вновь запустить обе команды,
       в том же порядке.

    Возможные неисправности:

     - Для большинства вариантов, описанных выше, нужно, чтобы путь к
       исполняемому файлу [coqc] находился в переменной среды [PATH].

     - Если [coqc] Вам сообщает, что не хватает каких-то идентификаторов,
       возможно, функциональность "load path" для Coq была установлена
       неправильно.  Команда [Print LoadPath.] может оказаться полезной,
       чтобы разобраться с проблемой.

     - При компиляции дальнейших лекций, если Вы видите сообщение навроде

        Compiled library Lecture2 makes inconsistent assumptions over
        library Lecture1

       скорее всего, дело в том, что библиотека [Lecture1] была изменена и
       перекомпилирована, в отличие от [Lecture2], которая от неё зависит.
       Просто перекомпилируйте [Lecture2]; либо всё вместе, если слишком много
       библиотек столкнулось с той же проблемой. Повторюсь, для этого достаточно
       запустить [make]; если даже это не поможет, попробуйте [make clean; make].

     - Если и это не помогло, возможно, на Вашем компьютере установлено сразу
       несколько несовместимых версий Coq.  Возможно, команды, которые Вы
       выполняете в терминале (вроде [coqc]) запускаются не с той версией Coq,
       с которой взаимодействуют Proof General или CoqIDE.  В CoqIDE для обхода
       этой проблемы можно компилировать только средствами CoqIDE (т.е. вызывать
       "make" из меню), избегая прямого использования [coqc]. *)

(* ################################################################# *)
(** * Пары натуральных чисел *)

(** В определении [Индуктивного] типа данных каждый конструктор может
    принимать любое количество аргументов -- ни одного (как [true] и [O]), один
    (как [S]) или больше одного (как [nybble] и как следующий конструктор): *)

Inductive natprod : Type :=
  | pair (n1 n2 : nat).

(** Это объявление можно прочитать так: "Единственный способ
    сконструировать пару чисел -- применить конструктор [pair]
    к двум аргументам типа [nat]." *)

Check (pair 3 5) : natprod.

(** Функции для извлечения первой и второй компонент пары
    можно определить через сопоставление с образцом. *)

Definition fst (p : natprod) : nat :=
  match p with
  | pair x y => x
  end.

Definition snd (p : natprod) : nat :=
  match p with
  | pair x y => y
  end.

Compute (fst (pair 3 5)).
(* ===> 3 *)

(** В дальнейшем мы будем активно использовать эти определения,
    так что нам было бы удобно записывать их в стандартной математической
    нотации как [(x,y)] вместо [pair x y].  Мы можем сообщить Coq об этом
    с помощью объявления новой [Нотации]. *)

Notation "( x , y )" := (pair x y).

(** Нотации можно использовать как в выражениях,
    так и в сравнении с образцом. *)

Compute (fst (3,5)).

Definition fst' (p : natprod) : nat :=
  match p with
  | (x,y) => x
  end.

Definition snd' (p : natprod) : nat :=
  match p with
  | (x,y) => y
  end.

Definition swap_pair (p : natprod) : natprod :=
  match p with
  | (x,y) => (y,x)
  end.

(** Обратите внимание, что сравнение пары с образцом (со скобками: [(x, y)])
    не нужно путать с синтаксисом "мультипаттерна" (без скобок: [x, y]),
    который мы видели ранее.  Примеры выше иллюстрируют сопоставление с образцом
    _единственной_ пары, состоящей из элементов [x] и [y], когда как, например,
    определение [minus] в [Lecture1] сопоставляет с образцом
    _два_ значения [n] и [m]:

       Fixpoint minus (n m : nat) : nat :=
         match n, m with
         | O   , _    => O
         | S _ , O    => n
         | S n', S m' => minus n' m'
         end.

    Различие не слишком большое, но важно понимать, что это не одно и то же.
    Например, следующие примеры составлены неправильно:

        (* Нельзя сопоставлять _одну_ пару с мультипаттерном: *)
        Definition bad_fst (p : natprod) : nat :=
          match p with
          | x, y => x
          end.

        (* Нельзя сопоставить _несколько_ значений
           с помощью _одного_ паттерна для пар: *)
        Definition bad_minus (n m : nat) : nat :=
          match n, m with
          | (O   , _   ) => O
          | (S _ , O   ) => n
          | (S n', S m') => bad_minus n' m'
          end.
*)

(** Если мы будем формулировать свойства пар несколько обходным путём, мы иногда
    сможем завершить их доказательства чисто с помощью [рефлексивности] и
    встроенных упрощений: *)

Theorem surjective_pairing' : forall (n m : nat),
  (n,m) = (fst (n,m), snd (n,m)).
Proof.
  reflexivity. Qed.

(** Однако просто [рефлексивности] недостаточно, если мы сформулируем
    утверждение леммы естественным образом: *)

Theorem surjective_pairing_stuck : forall (p : natprod),
  p = (fst p, snd p).
Proof.
  simpl. (* Ничего не упрощает! *)
Abort.

(** Вместо этого, нам нужно обнажить внутреннее устройство [p], чтобы
    [simpl] мог произвести сопоставление с образцом в [fst] и [snd].  Мы можем
    достичь этого с помощью [destruct]. *)

Theorem surjective_pairing : forall (p : natprod),
  p = (fst p, snd p).
Proof.
  intros p. destruct p as [n m]. simpl. reflexivity. Qed.

(** Обратите внимание, что, в отличие от поведения [destruct] на
    натуральных числах, где он генерирует две подцели, здесь [destruct]
    генерирует всего одну-единственную подцель.  Это происходит ровно потому,
    что [natprod] можно построить единственным способом --
    вызовом его единственного конструктора. *)

(** **** Упражнение: 1 звезда, стандартное (snd_fst_is_swap) *)
Theorem snd_fst_is_swap : forall (p : natprod),
  (snd p, fst p) = swap_pair p.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** **** Упражнение: 1 звезда, стандартное, необязательное (fst_swap_is_snd) *)
Theorem fst_swap_is_snd : forall (p : natprod),
  fst (swap_pair p) = snd p.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(* ################################################################# *)
(** * Списки натуральных чисел *)

(** Обобщая определение пар, мы можем описать тип _списков_ чисел
    следующим образом: "Список либо пустой, либо является парой из первого
    элемента (в данном случае числа) и списка,
    состоящего из остальных элементов." *)

Inductive natlist : Type :=
  | nil
  | cons (n : nat) (l : natlist).

(** Вот, например, список из трёх элементов: *)

Definition mylist := cons 1 (cons 2 (cons 3 nil)).

(** Как и с парами, нам будет удобно записывать списки, используя
    знакомую нотацию.  Следующие объявления позволяют нам использовать [::] в
    качестве инфиксной версии оператора [cons], а квадратные скобки -- в
    качестве "аутфиксной" нотации для построения списков. *)

Notation "x :: l" := (cons x l)
                     (at level 60, right associativity).
Notation "[ ]" := nil.
Notation "[ x ; .. ; y ]" := (cons x .. (cons y nil) ..).

(** Разбираться во внутреннем устройстве этих объявлений не обязательно,
    но, в случае, если Вам интересно, вот что примерно происходит.
    Аннотация "[right associativity]" сообщает Coq, как расставлять скобки в
    выражениях, содержащих несколько использований [::], так, чтобы, например,
    следующие три объявления значили в точности одно и то же: *)

Definition mylist1 := 1 :: (2 :: (3 :: nil)).
Definition mylist2 := 1 :: 2 :: 3 :: nil.
Definition mylist3 := [1;2;3].

(** Часть с "[at level 60]" сообщает Coq, как расставлять скобки в
    выражениях, содержащих и [::], и ещё какой-то другой инфиксный оператор.
    Например, раз мы определили [+] в качестве инфиксной нотации для функции
    [plus] с приоритетом 50,

  Notation "x + y" := (plus x y) (at level 50, left associativity).

    оператор [+] будет _связывать сильнее, чем_ [::], так что [1 + 2 :: [3]]
    будет пониматься как [(1 + 2) :: [3]] (что и ожидалось),
    а не как [1 + (2 :: [3])].

    (Выражения вида "[1 + 2 :: [3]]" могут выглядеть слегка запутанно,
    особенно читать их в файле [.v].  Внутренние скобки, вокруг 3,
    маркируют список, а вот внешние скобки, невидимые при просмотре HTML-версии,
    направляют инструмент "coqdoc" так, чтобы часть в этих скобках отображалась
    как код на Coq, а не как обычный текст.)

    Второе и третье объявления [Notation] выше вводят стандартную нотацию
    для списков через квадратные скобки; часть справа от [:=] в третьем правиле
    иллюстрирует синтаксис Coq для объявления нотаций переменной длины и
    их перевода во вложенные последовательности бинарных конструкторов.

    Опять же, не переживайте, если Вас озадачили какие-то детали
    синтаксического разбора: все используемые в нашем курсе нотации
    уже будут определены в лекционных файлах.
*)

(* ----------------------------------------------------------------- *)
(** *** Повтор элемента *)

(** Далее, давайте рассмотрим несколько функций для работы со списками.
    Вот, во-первых, функция [repeat], по значению [n] и счётчику [count]
    возвращающая список длины [count], в котором каждый элемент равен [n]. *)

Fixpoint repeat (n count : nat) : natlist :=
  match count with
  | O => nil
  | S count' => n :: (repeat n count')
  end.

(* ----------------------------------------------------------------- *)
(** *** Длина списка *)

(** Функция [length] вычисляет длину списка. *)

Fixpoint length (l:natlist) : nat :=
  match l with
  | nil => O
  | h :: t => S (length t)
  end.

(* ----------------------------------------------------------------- *)
(** *** Конкатенация *)

(** Функция [app] конкатенирует (соединяет) два списка. *)

Fixpoint app (l1 l2 : natlist) : natlist :=
  match l1 with
  | nil    => l2
  | h :: t => h :: (app t l2)
  end.

(** Т.к. [app] мы будем использовать очень часто, будет полезно
    определить для её использования инфиксный оператор. *)

Notation "x ++ y" := (app x y)
                     (right associativity, at level 60).

Example test_app1:             [1;2;3] ++ [4;5] = [1;2;3;4;5].
Proof. reflexivity. Qed.
Example test_app2:             nil ++ [4;5] = [4;5].
Proof. reflexivity. Qed.
Example test_app3:             [1;2;3] ++ nil = [1;2;3].
Proof. reflexivity. Qed.

(* ----------------------------------------------------------------- *)
(** *** Голова и хвост *)

(** Здесь мы покажем два примера попроще. Функция [hd] возвращает
    первый элемент ("голову") списка, в то время как [tl] возвращает
    все элементы, кроме первого ("хвост").  Т.к. у пустого списка нет первого
    элемента, мы также передаём в [hd] значение по умолчанию, которое нужно
    вернуть в таком случае.  *)

Definition hd (default : nat) (l : natlist) : nat :=
  match l with
  | nil => default
  | h :: t => h
  end.

Definition tl (l : natlist) : natlist :=
  match l with
  | nil => nil
  | h :: t => t
  end.

Example test_hd1:             hd 0 [1;2;3] = 1.
Proof. reflexivity. Qed.
Example test_hd2:             hd 0 [] = 0.
Proof. reflexivity. Qed.
Example test_tl:              tl [1;2;3] = [2;3].
Proof. reflexivity. Qed.

(* ----------------------------------------------------------------- *)
(** *** Упражнения *)

(** **** Упражнение: 2 звезды, стандартное, особенно полезное (list_funs)

    Завершите определения [nonzeros], [oddmembers] и [countoddmembers] ниже.
    Ознакомьтесь с тестами, чтобы понять, что должны делать эти функции. *)

Fixpoint nonzeros (l:natlist) : natlist
  (* ЗАМЕНИТЕ ЭТУ СТРОЧКУ ":= _вашим_определением_ ." *). Admitted.

Example test_nonzeros:
  nonzeros [0;1;0;2;3;0;0] = [1;2;3].
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Fixpoint oddmembers (l:natlist) : natlist
  (* ЗАМЕНИТЕ ЭТУ СТРОЧКУ ":= _вашим_определением_ ." *). Admitted.

Example test_oddmembers:
  oddmembers [0;1;0;2;3;0;0] = [1;3].
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

(** Для следующей задачки, [countoddmembers], мы даём Вам заголовок,
    использующий ключевое слово [Definition] вместо [Fixpoint].
    Смысл постановки вопроса таким образом в том, чтобы замотивировать
    Вас реализовать функцию с помощью уже существующих определений
    вместо того чтобы вновь выписывать рекурсивное определение. *)

Definition countoddmembers (l:natlist) : nat
  (* ЗАМЕНИТЕ ЭТУ СТРОЧКУ ":= _вашим_определением_ ." *). Admitted.

Example test_countoddmembers1:
  countoddmembers [1;0;3;1;4;5] = 4.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Example test_countoddmembers2:
  countoddmembers [0;2;4] = 0.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Example test_countoddmembers3:
  countoddmembers nil = 0.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** **** Упражнение: 3 звезды, продвинутое (alternate)

    Завершите определение [alternate], которая перемежает элементы двух списков:
    [[элемент первого; элемент второго; ...]].
    См. тесты в качестве примеров работы.

    Подсказка: есть множество естественных способов выписать [alternate],
    которые, однако, не удовлетворяют требованию Coq-а, чтобы все определения
    через [Fixpoint] были _структурно рекурсивными_, как упоминалось в
    [Lecture1]. Если Вас это затрудняет, попробуйте сопоставлять с образцом
    сразу оба списка с помощью мультипаттерна. *)

Fixpoint alternate (l1 l2 : natlist) : natlist
  (* ЗАМЕНИТЕ ЭТУ СТРОЧКУ ":= _вашим_определением_ ." *). Admitted.

Example test_alternate1:
  alternate [1;2;3] [4;5;6] = [1;4;2;5;3;6].
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Example test_alternate2:
  alternate [1] [4;5;6] = [1;4;5;6].
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Example test_alternate3:
  alternate [1;2;3] [4] = [1;4;2;3].
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Example test_alternate4:
  alternate [] [20;30] = [20;30].
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(* ----------------------------------------------------------------- *)
(** *** Мультимножества на списках *)

(** Мультимножества ([bag]) очень похожи на _множества_ за исключением того, что
    каждый элемент в мультимножестве может встречаться несколько раз.
    Один из многих способов представления мультимножества --
    с помощью списка. *)

Definition bag := natlist.

(** **** Упражнение: 3 звезды, стандартное, особенно полезное (bag_functions)

    Завершите определения функций [count],
    [sum], [add], и [member] для мультимножеств. *)

Fixpoint count (v : nat) (s : bag) : nat
  (* ЗАМЕНИТЕ ЭТУ СТРОЧКУ ":= _вашим_определением_ ." *). Admitted.

(** Все утверждения ниже можно доказать с помощью [рефлексивности]. *)

Example test_count1:              count 1 [1;2;3;1;4;1] = 3.
 (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
Example test_count2:              count 6 [1;2;3;1;4;1] = 0.
 (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

(** [сумма] мультимножеств похожа на объединение множеств: [sum a b]
    содержит все элементы [a] и [b].  (Математики обычно определяют
    объединение мультимножеств слегка по-другому -- через взятие максимума,
    а не через сумму -- так что мы не называем нашу операцию [union] во
    избежание коллизий.)

    Мы намеренно даём Вам заголовок функции, который не именует аргументы.
    Реализуйте [sum] с помощью уже определённой функции, не меняя заголовок. *)

Definition sum : bag -> bag -> bag
  (* ЗАМЕНИТЕ ЭТУ СТРОЧКУ ":= _вашим_определением_ ." *). Admitted.

Example test_sum1:              count 1 (sum [1;2;3] [1;4;1]) = 3.
 (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Definition add (v : nat) (s : bag) : bag
  (* ЗАМЕНИТЕ ЭТУ СТРОЧКУ ":= _вашим_определением_ ." *). Admitted.

Example test_add1:                count 1 (add 1 [1;4;1]) = 3.
 (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
Example test_add2:                count 5 (add 1 [1;4;1]) = 0.
 (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Fixpoint member (v : nat) (s : bag) : bool
  (* ЗАМЕНИТЕ ЭТУ СТРОЧКУ ":= _вашим_определением_ ." *). Admitted.

Example test_member1:             member 1 [1;4;1] = true.
 (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Example test_member2:             member 2 [1;4;1] = false.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** **** Упражнение: 3 звезды, стандартное, необязательное (bag_more_functions)

    Вот ещё немного функций на мультимножествах, чтобы вы попрактиковались. *)

(** Когда [remove_one] применяется к мультимножеству, не содержащему удаляемого
    значения, она должна вернуть старое мультимножество без изменений.
    (Это упражнение опциональное; тем не менее, определение [remove_one]
    понадобится для решения более поздних дополнительных задачек.) *)

Fixpoint remove_one (v : nat) (s : bag) : bag
  (* ЗАМЕНИТЕ ЭТУ СТРОЧКУ ":= _вашим_определением_ ." *). Admitted.

Example test_remove_one1:
  count 5 (remove_one 5 [2;1;5;4;1]) = 0.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Example test_remove_one2:
  count 5 (remove_one 5 [2;1;4;1]) = 0.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Example test_remove_one3:
  count 4 (remove_one 5 [2;1;4;5;1;4]) = 2.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Example test_remove_one4:
  count 5 (remove_one 5 [2;1;5;4;5;1;4]) = 1.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Fixpoint remove_all (v:nat) (s:bag) : bag
  (* ЗАМЕНИТЕ ЭТУ СТРОЧКУ ":= _вашим_определением_ ." *). Admitted.

Example test_remove_all1:  count 5 (remove_all 5 [2;1;5;4;1]) = 0.
 (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
Example test_remove_all2:  count 5 (remove_all 5 [2;1;4;1]) = 0.
 (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
Example test_remove_all3:  count 4 (remove_all 5 [2;1;4;5;1;4]) = 2.
 (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
Example test_remove_all4:  count 5 (remove_all 5 [2;1;5;4;5;1;4;5;1;4]) = 0.
 (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Fixpoint included (s1 : bag) (s2 : bag) : bool
  (* ЗАМЕНИТЕ ЭТУ СТРОЧКУ ":= _вашим_определением_ ." *). Admitted.

Example test_included1:              included [1;2] [2;1;4;1] = true.
 (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
Example test_included2:              included [1;2;2] [2;1;4;1] = false.
 (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** **** Упражнение: 2 звезды, стандартное, особенно полезное (add_inc_count)

    Добавление значения в мультимножество должно инкрементировать значение
    [count] для этого значения. Сформулируйте это утверждение в виде теоремы
    и докажите её в Coq. *)
(*
Theorem add_inc_count : ...
Proof.
  ...
Qed.
*)

(* Do not modify the following line: *)
Definition manual_grade_for_add_inc_count : option (nat*string) := None.
(** [] *)

(* ################################################################# *)
(** * Суждения о списках *)

(** Как и в случае с числами, простые свойства функций,
    обрабатывающих списки, можно доказать просто с помощью упрощений.
    Например, упрощений, выполняемых [reflexivity], достаточно
    для доказательства следующей теоремы... *)

Theorem nil_app : forall l : natlist,
  [] ++ l = l.
Proof. reflexivity. Qed.

(** ...потому что [[]] подставляется в качестве "рассматриваемого"
    (выражения, которое мы "рассматриваем" в сопоставлении с образцом)
    в определении [app], в результате чего всё выражение упрощается. *)

(** Также, как было с числами, иногда полезно произвести разбор возможных
    случаев внутреннего устройства (пустой или непустой?)
    неизвестного списка. *)

Theorem tl_length_pred : forall l:natlist,
  pred (length l) = length (tl l).
Proof.
  intros l. destruct l as [| n l'].
  - (* l = nil *)
    reflexivity.
  - (* l = cons n l' *)
    reflexivity.  Qed.

(** Случай [nil] срабатывает по определению функции ([tl nil = nil]).
    Обратите внимание на аннотацию [as] в тактике [destruct]: она вводит два
    имени, [n] и [l'], ссылающихся на два аргумента конструктора [cons]
    (голову и хвост конструируемого таким образом списка). *)

(** Правда, чаще всего, доказательство интересных теорем о списках требует
    использования _индукции по спискам_.  Сейчас мы увидим, как это делать. *)

(** (Микро-наставление: с более глубоким погружением в материал, просто
    _чтение_ скриптов доказательств Вам не очень поможет.  Скорее, важно
    именно рассмотреть выполнение доказательств по шагам, используя
    интерактивный режим Coq и стараясь понять, чего достигает каждый шаг
    в доказательстве.  В противном случае я гарантирую, что формулировка и
    решение упражнений, когда Вы за них приметесь,
    будут Вам совершенно непостижимы.) *)

(* ================================================================= *)
(** ** Индукция на списках *)

(** Доказательства по индукции на типах данных вроде [natlist],
    скорее всего, будет Вам слегка менее знакома, чем обычная (математическая)
    индукция на натуральных числах, но идея столь же проста.  Каждое
    [Индуктивное] объявление определяет множество значений, которые можно
    построить, используя объявленные конструкторы.  Например, логическое
    значение может быть либо [true], либо [false]; натуральное число может быть
    либо [O], либо [S], применённое к другому числу; наконец, список может быть
    либо [nil], либо [cons], применённый к числу и списку.  Более того,
    применения объявленных конструкторов -- это _единственные_ возможные
    способы получить элементы множества, объявленного индуктивным образом.

    Этот последний факт напрямую предоставляет способ рассуждать об индуктивно
    определяемых множествах: число -- это либо [O], либо [S], применённый к
    _меньшему_ числу; список -- это либо [nil], либо [cons], применённый к
    некоторому произвольному числу и некоторому _меньшему_ списку; и т.д..
    Таким образом, если у нас на уме некоторое утверждение [P] о списке [l], и
    мы хотим доказать, что [P] выполнено для _всех_ возможных списков [l], мы
    можем рассуждать следующим образом:

      - Во-первых, покажем, что
        [P] истинно для [l]
        в случае, когда [l] это [nil].

      - Далее, покажем, что
        [P] истинно для [l] даже в том случае, когда
        [l] это [cons n l'] для некоторого числа [n] и меньшего списка [l'],
        в предположении, что [P] истинно для [l'].

    Раз бОльшие списки всегда можно постепенным отщеплением головы уменьшить до
    [nil], два этих факта вместе позволяют установить истинность [P]
    для произвольных списков [l].

    Вот конкретный пример: *)

Theorem app_assoc : forall l1 l2 l3 : natlist,
  (l1 ++ l2) ++ l3 = l1 ++ (l2 ++ l3).
Proof.
  intros l1 l2 l3. induction l1 as [| n l1' IHl1'].
  - (* l1 = nil *)
    reflexivity.
  - (* l1 = cons n l1' *)
    simpl. rewrite -> IHl1'. reflexivity.  Qed.

(** Обратите внимание, что, как было и с индукцией на натуральных числах,
    клоза [as...] в тактике [induction] позволяет именовать также и
    предположение индукции, соответствующее меньшему списку [l1']
    в случае [cons].

    Опять же, это доказательство на Coq не особенно просветляет в виде
    статичного документа -- проще увидеть, что происходит, если Вы читаете
    доказательство в интерактивной сессии Coq и можете увидеть текущую цель и
    контекст на каждом шаге доказательства, которые нельзя увидеть чисто в
    статичном, записанном варианте доказательства.  Точно также и доказательство
    на естественном языке -- написанное для чтения человеком -- должно включать
    более читаемые и явные опознавательные знаки и остановки; в особенности, мы
    очень поможем читателю ориентироваться в доказательстве, если мы будем
    напоминать ему, как в точности выглядит доказываемое утверждение в
    индуктивном переходе. *)

(** Для сравнения, вот неформальное (но строгое) доказательство
    той же самой теоремы. *)

(** _Теорема_: Для всяких списков [l1], [l2] и [l3] верно, что
               [(l1 ++ l2) ++ l3 = l1 ++ (l2 ++ l3)].

   _Доказательство_: Индукцией по [l1].

   - База: [l1 = []].  Необходимо показать, что

       ([] ++ l2) ++ l3 = [] ++ (l2 ++ l3),

     что напрямую следует из определения [++].

   - Переход: [l1 = n::l1'], причём

       (l1' ++ l2) ++ l3 = l1' ++ (l2 ++ l3)

     (по предположению индукции).  Необходимо показать, что

       ((n :: l1') ++ l2) ++ l3 = (n :: l1') ++ (l2 ++ l3).

     По определению [++], это следует из

       n :: ((l1' ++ l2) ++ l3) = n :: (l1' ++ (l2 ++ l3)),

     что также верно благодаря предположению индукции.  [] *)

(* ----------------------------------------------------------------- *)
(** *** Усиление предположения индукции *)

(** В некоторых случаях, может быть необходимо усилить утверждение,
    чтобы его можно было доказать по индукции.  Интуитивно, причина состоит в
    том, что более сильное (более общее) утверждение также позволяет получить
    более сильное (более общее) предположение индукции.  Если Вы по каким-то
    причинам завязли в доказательстве, попробуйте отступиться, осмотреться и
    выяснить -- может, внезапно получится доказать более сильное утверждение. *)

Theorem repeat_double_firsttry : forall c n: nat,
  repeat n c ++ repeat n c = repeat n (c + c).
Proof.
  intros c. induction c as [| c' IHc'].
  - (* c = 0 *)
    intros n. simpl. reflexivity.
  - (* c = S c' *)
    intros n. simpl.
    (*  Здесь-то мы, кажется, и застряли.  Мы не можем использовать IH,
        чтобы переписать [repeat n (c' + S c')]: гипотеза работает только для
        [repeat n (c' + c')]. Если бы IH была более гибкой
        (например, если бы она работала для произвольного второго слагаемого),
        доказательство бы прошло. *)
Abort.

(** Чтобы получить более сильное предположение, мы можем усилить
    утверждение следующим образом: *)

Theorem repeat_plus: forall c1 c2 n: nat,
    repeat n c1 ++ repeat n c2 = repeat n (c1 + c2).
Proof.
  intros c1 c2 n.
  induction c1 as [| c1' IHc1'].
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHc1'.
    reflexivity.
  Qed.

(* ----------------------------------------------------------------- *)
(** *** Разворот списка *)

(** В качестве более запутанного примера доказательств по индукции на
    списках, предположим, что мы используем [app] для определения функции
    разворота списка [rev]: *)

Fixpoint rev (l:natlist) : natlist :=
  match l with
  | nil    => nil
  | h :: t => rev t ++ [h]
  end.

Example test_rev1:            rev [1;2;3] = [3;2;1].
Proof. reflexivity.  Qed.
Example test_rev2:            rev nil = nil.
Proof. reflexivity.  Qed.

(** В качестве чего-то более мудрёного, давайте докажем, что
    разворот списка не меняет его длину.  Наша первая попытка застревает
    на индуктивном переходе... *)

Theorem rev_length_firsttry : forall l : natlist,
  length (rev l) = length l.
Proof.
  intros l. induction l as [| n l' IHl'].
  - (* l = nil *)
    reflexivity.
  - (* l = n :: l' *)
    (* Вот это сложный случай.  Давайте, как обычно, попробуем упростить. *)
    simpl.
    (* Кажется, мы застряли: цель -- это равенство, содержащее [++], но у нас
       пока нет никаких полезных фактов ни в локальном контексте, ни в
       глобальной среде!  Можем попробовать немного продвинуться и переписать
       цель с помощью предположения индукции... *)
    rewrite <- IHl'.
    (* ... но дальше нам никуда не продвинуться. *)
Abort.

(** Можно попробовать доказать в точности то утверждение, которого нам не
    хватает на данный момент.  Но эта попытка обречена на провал, поскольку
    предположение индукции недостаточно мощное. *)
Theorem app_rev_length_S_firsttry: forall l n,
  length (rev l ++ [n]) = S (length (rev l)).
Proof.
  intros l. induction l as [| m l' IHl'].
  - (* l = [] *)
    intros n. simpl. reflexivity.
  - (* l = m:: l' *)
    intros n. simpl.
    (* IHl' не применима. *)
Abort.

(** Оказывается, лемма выше гораздо слабее, чем нужно. Мы можем усилить
    лемму и работать не только с развёрнутыми списками, но с произвольными
    списками вообще. *)
Theorem app_length_S: forall l n,
  length (l ++ [n]) = S (length l).
Proof.
  intros l n. induction l as [| m l' IHl'].
  - (* l = [] *)
    simpl. reflexivity.
  - (* l = m:: l' *)
    simpl.
    rewrite IHl'.
    reflexivity.
Qed.

(** Теперь мы можем закончить исходное доказательство. *)

Theorem rev_length : forall l : natlist,
  length (rev l) = length l.
Proof.
  intros l. induction l as [| n l' IHl'].
  - (* l = nil *)
    reflexivity.
  - (* l = cons *)
    simpl.
    rewrite -> app_length_S.
    rewrite -> IHl'.
    reflexivity.
Qed.

(** Обратите внимание, что лемма app_length_S, которую мы доказали выше,
    достаточно слабая, т.к. она требует, чтобы второй список состоял из
    единственного элемента. Мы можем доказать более сильное утверждение для
    двух произвольных списков. *)
Theorem app_length : forall l1 l2 : natlist,
  length (l1 ++ l2) = (length l1) + (length l2).
Proof.
  (* WORKED IN CLASS *)
  intros l1 l2. induction l1 as [| n l1' IHl1'].
  - (* l1 = nil *)
    reflexivity.
  - (* l1 = cons *)
    simpl. rewrite -> IHl1'. reflexivity.  Qed.

(** Для сравнения, ниже приведены неформальные доказательства этих двух теорем:

    _Теорема_: Для всяких списков [l1] и [l2] верно, что
       [length (l1 ++ l2) = length l1 + length l2].

    _Доказательство_: Индукцией по [l1].

   - База: [l1 = []].  Нам нужно показать, что

        length ([] ++ l2) = length [] + length l2,

      что следует напрямую из определений [length], [++] и [plus].

    - Переход: [l1 = n::l1']; при этом

        length (l1' ++ l2) = length l1' + length l2.

      Нам нужно показать, что

        length ((n::l1') ++ l2) = length (n::l1') + length l2.

      Это следует напрямую из определений [length] и [++], а также из
      предположения индукции. [] *)

(** _Theorem_: Для всякого списка [l] верно, что [length (rev l) = length l].

    _Доказательство_: Индукцией по [l].

      - База: [l = []].  Нам нужно доказать, что

          length (rev []) = length [],

        что следует напрямую из определений [length] и [rev].

      - Шаг: [l = n::l']; при этом

          length (rev l') = length l'.

        Нам нужно показать, что

          length (rev (n :: l')) = length (n :: l').

        По определению [rev], это должно следовать из того, что

          length ((rev l') ++ [n]) = S (length l')

        что, по предыдущей лемме, эквивалентно

          length (rev l') + length [n] = S (length l').

        А это уже напрямую следует из предположения индукции
        и определения [length]. [] *)

(** Эти доказательства достаточно многословны и педантичны.
    После прочтения парочки таких доказательств, проще будет следить за
    доказательствами, разжёвывающими меньше деталей (которые мы можем легко
    восстановить в уме, либо на бумажке, если необходимо) и демонстрирующими
    только неочевидные переходы.  В таком, более кратком, стиле, доказательство
    выше могло выглядеть следующим образом: *)

(** _Теорема_: Для любого списка [l] верно, что [length (rev l) = length l].

    _Доказательство_: Несложной индукцией по [l] легко убедиться, что
     [length (l ++ [n]) = S (length l)] для любого [l].  Требуемое свойство же,
     в свою очередь, доказывается ещё одной индукцией по [l], где наше
     наблюдение используется в шаге индукции вместе с предположением индукции.
     [] *)

(** То, какой стиль предпочтителен в Вашей конкретной ситуации, зависит от
    предпологаемого уровня знаний Вашей аудитории и того, насколько Ваше
    доказательство похоже на те, с которыми они уже знакомы. Более педантичный
    подход для нас подходит лучше, потому что мы пытаемся
    излагать всё суперподробно. *)

(* ================================================================= *)
(** ** Команда [Search] *)

(** Мы уже убедили, что доказательства могут переиспользовать другие теоремы,
    которые мы уже доказали, например, с помощью [rewrite].  Но для того, чтобы
    сослаться на теорему, нам нужно знать её название!  Действительно, зачастую
    сложно даже вспомнить какие теоремы были доказаны, не говоря уже об их
    названиях.

    Команда [Search] с этим очень помогает.

    Допустим, Вы забыли название теоремы про [rev].  Команда [Search rev]
    запросит у Coq список всех теорем, содержащих [rev] в формулировке. *)

Search rev.

(** Или, например, Вы забыли имя теоремы о коммутативности сложения.
    Вы можете использовать паттерн (_образец_), чтобы поискать все теоремы,
    включающие в себя равенство двух сложений. *)

Search (_ + _ = _ + _).

(** Здесь Вы увидите кучу результатов; практически каждый из них будет из
    стандартной библиотеки.  Чтобы сузить область поиска, можно искать внутри
    конкретного модуля: *)

Search (_ + _ = _ + _) inside Lecture1.

(** Также можно уточнить запрос, используя в паттерне переменные
    вместо вайлдкардов: *)

Search (?x + ?y = ?y + ?x).

(** (Знак вопроса перед переменной нужен, чтобы отличать переменную, объявленную
    внутри паттерна, от идентификатора из текущей области видимости.) *)

(** Не забывайте про [Search], пока выполняете упражнения курса; эта команда
    поможет вам сэкономить много-много времени! *)

(* ================================================================= *)
(** ** Упражнения на списки, часть 1 *)

(** **** Упражнение: 3 звезды, стандартное (list_exercises)

    Больше практики со списками: *)

Theorem app_nil_r : forall l : natlist,
  l ++ [] = l.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Theorem rev_app_distr: forall l1 l2 : natlist,
  rev (l1 ++ l2) = rev l2 ++ rev l1.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

(** _Инволюция_ это функция, которая обратна сама себе. То есть,
    применение функции дважды не меняет исходное значение. *)
Theorem rev_involutive : forall l : natlist,
  rev (rev l) = l.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

(** Для следующей теоремы есть краткое решение.  Если чувствуете,
    что запутались, отступитесь и попробуйте найти решение попроще. *)

Theorem app_assoc4 : forall l1 l2 l3 l4 : natlist,
  l1 ++ (l2 ++ (l3 ++ l4)) = ((l1 ++ l2) ++ l3) ++ l4.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

(** Упражнение про Вашу реализацию [nonzeros]: *)

Lemma nonzeros_app : forall l1 l2 : natlist,
  nonzeros (l1 ++ l2) = (nonzeros l1) ++ (nonzeros l2).
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** **** Упражнение: 2 звезды, стандартное (eqblist)

    Завершите определение [eqblist], функции, проверяющей списки на равенство.
    Докажите, что [eqblist l l] возвращает [true] для любого [l]. *)

Fixpoint eqblist (l1 l2 : natlist) : bool
  (* ЗАМЕНИТЕ ЭТУ СТРОЧКУ ":= _вашим_определением_ ." *). Admitted.

Example test_eqblist1 :
  (eqblist nil nil = true).
 (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Example test_eqblist2 :
  eqblist [1;2;3] [1;2;3] = true.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Example test_eqblist3 :
  eqblist [1;2;3] [1;2;4] = false.
 (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Theorem eqblist_refl : forall l:natlist,
  true = eqblist l l.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(* ================================================================= *)
(** ** Упражнения на списки, часть 2 *)

(** Вот ещё несколько небольших теорем про мультимножества. *)

(** **** Упражнение: 1 звезда, стандартное (count_member_nonzero) *)
Theorem count_member_nonzero : forall (s : bag),
  1 <=? (count 1 (1 :: s)) = true.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** Следующая лемма о [leb] может помочь Вам в следующем упражнении
    (да и в будущем пригодится). *)

Theorem leb_n_Sn : forall n,
  n <=? (S n) = true.
Proof.
  intros n. induction n as [| n' IHn'].
  - (* 0 *)
    simpl.  reflexivity.
  - (* S n' *)
    simpl.  rewrite IHn'.  reflexivity.  Qed.

(** Перед тем, как приступить к следующему упражнению, убедитесь, что Вы
   завершили определение [remove_one] выше. *)
(** **** Упражнение: 3 звезды, продвинутое (remove_does_not_increase_count) *)
Theorem remove_does_not_increase_count: forall (s : bag),
  (count 0 (remove_one 0 s)) <=? (count 0 s) = true.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** **** Упражнение: 3 звезды, стандартное, необязательное (bag_count_sum)

    Сформулируйте ниже интересную теорему [bag_count_sum] о мультимножествах,
    связывающую функции [count] и [sum], и докажите её с помощью Coq.
    (Может так оказаться, что сложность доказательсва зависит от того,
    как Вы определили [count]!  Подсказка: если Вы определили [count], используя
    [=?], Вам может быть полезно узнать, что [destruct] работает не только для
    переменных, но и для вообще произвольных утверждений.)
*)
(* ЗАПОЛНИТЕ ЗДЕСЬ

    [] *)

(** **** Упражнение: 3 звезды, продвинутое (involution_injective) *)

(** Докажите, что всякая инволюция инъективна.

    Инволюции были определены выше, в [rev_involutive]. _Инъективная_
    функция же, в свою очередь, та, которая для разных аргументов возвращает
    разные значения, без коллизий. *)

Theorem involution_injective : forall (f : nat -> nat),
    (forall n : nat, n = f (f n)) -> (forall n1 n2 : nat, f n1 = f n2 -> n1 = n2).
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

(** [] *)

(** **** Упражнение: 2 звезды, продвинутое (rev_injective)

    Докажите, что [rev] инъективна. Не советую доказывать по индукции --
    это будет сложно. Вместо этого переиспользуйте ту же технику, что Вы
    использовали для доказательства [involution_injective]. (Но: Не пытайтесь
    использовать то упражнение: типы не сойдутся!) *)

Theorem rev_injective : forall (l1 l2 : natlist),
  rev l1 = rev l2 -> l1 = l2.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(* ################################################################# *)
(** * Частичные значения *)

(** Пусть мы хотим написать функцию, возвращающую [n]-й элемент некоторого
    списка.  Если мы выпишем её тип как [nat -> natlist -> nat], нам придётся
    выбрать какое-то число, чтобы возвращать его в том случае,
    если список слишком короткий... *)

Fixpoint nth_bad (l:natlist) (n:nat) : nat :=
  match l with
  | nil => 42
  | a :: l' => match n with
               | 0 => a
               | S n' => nth_bad l' n'
               end
  end.

(** Это решение не очень хорошее: если [nth_bad] возвращает [42], мы
    не сможем установить, есть ли это значение в списке, без дополнительного
    разбирательства. Альтернативой получше будет изменить тип возвращаемого
    значения в [nth_bad] таким образом, чтобы учесть значение-ошибку как
    вероятный исход запуска функции. Мы назовём этот тип [natoption]. *)

Inductive natoption : Type :=
  | Some (n : nat)
  | None.

(* Заметим, что мы написали [None] и [Some] с большой буквы, аналогично их
   названию в стандартной библиотеке Coq.  В общем-то имена конструкторов (да и
   переменных) могут начинаться как с большой, так и с маленькой буквы. *)

(** Теперь мы можем изменить определение [nth_bad] выше так, чтобы она
    возвращала [None], когда список слишком короткий, и [Some a] в противном
    случае (и, конечно, на [n]-й позиции в списке стоит [a]). Мы назовём эту
    новую функцию [nth_error], чтобы сигнализировать о возможной ошибке. *)

Fixpoint nth_error (l:natlist) (n:nat) : natoption :=
  match l with
  | nil => None
  | a :: l' => match n with
               | O => Some a
               | S n' => nth_error l' n'
               end
  end.

Example test_nth_error1 : nth_error [4;5;6;7] 0 = Some 4.
Proof. reflexivity. Qed.
Example test_nth_error2 : nth_error [4;5;6;7] 3 = Some 7.
Proof. reflexivity. Qed.
Example test_nth_error3 : nth_error [4;5;6;7] 9 = None.
Proof. reflexivity. Qed.

(** Функция ниже вытаскивает значение типа [nat] из [natoption], возвращая
    значение по умолчанию в случае [None]. *)

Definition option_elim (d : nat) (o : natoption) : nat :=
  match o with
  | Some n' => n'
  | None => d
  end.

(** **** Упражнение: 2 звезды, стандартное (hd_error)

    Используя ту же идею, исправьте функцию [hd], определённую ранее, так, чтобы
    нам не пришлось передавать значение по умолчанию для случая [nil].  *)

Definition hd_error (l : natlist) : natoption
  (* ЗАМЕНИТЕ ЭТУ СТРОЧКУ ":= _вашим_определением_ ." *). Admitted.

Example test_hd_error1 : hd_error [] = None.
 (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Example test_hd_error2 : hd_error [1] = Some 1.
 (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Example test_hd_error3 : hd_error [5;6] = Some 5.
 (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

(** [] *)

(** **** Упражнение: 1 звезда, стандартное, необязательное (option_elim_hd)

    Это упражнение связывает вашу [hd_error] с более ранней [hd]. *)

Theorem option_elim_hd : forall (l:natlist) (default:nat),
  hd default l = option_elim default (hd_error l).
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

End NatList.

(* ################################################################# *)
(** * Частичные функции *)

(** В качестве последней иллюстрации того, как можно определять типы данных в
    Coq, ниже мы введём тип данных _частичных функций_, аналогичный
    ассоциативным массивам (aka словарям), которые легко найти в любом другом
    языке программирования. *)

(** Во-первых, определим новый индуктивный тип данных [id], который будет
    выступать в качестве "ключей" в наших словарях. *)

Inductive id : Type :=
  | Id (n : nat).

(** Внутри [id] лежит просто число.  Введение отдельного типа данных,
    оборачивающего каждое число тэгом [Id], делает определения более читаемыми
    и дарит нам гибкость в позднейшем изменении внутреннего представления [Id],
    если впоследствии нам это потребуется. *)

(** Также мы захотим проверять [id] на равенство: *)

Definition eqb_id (x1 x2 : id) :=
  match x1, x2 with
  | Id n1, Id n2 => n1 =? n2
  end.

(** **** Упражнение: 1 звезда, стандартное (eqb_id_refl) *)
Theorem eqb_id_refl : forall x, eqb_id x x = true.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** Далее, определим тип частичных функций: *)

Module PartialMap.
Export NatList.  (* сделаем доступными определения из NatList *)

Inductive partial_map : Type :=
  | empty
  | record (i : id) (v : nat) (m : partial_map).

(** Это объявление можно прочитать так: "Есть два способа построить
    [partial_map]: либо используя конструктор [empty], чтобы представить
    пустой словарь, либо применив конструктор [record] к ключу, значению и
    существующей [partial_map], чтобы построить новую [partial_map] с
    дополнительным отображением из ключа в значение." *)

(** Функция [update] перегружает запись для данного ключа в словаре с помощью
    перекрытия старого определения новым (либо просто добавляет новую запись,
    если такого ключа ещё нет). *)

Definition update (d : partial_map)
                  (x : id) (value : nat)
                  : partial_map :=
  record x value d.

(** Наконец, функция [find] ищет в [partial_map] заданный ключ.  Она возвращает
    [None], если ключ не был найден, и [Some val], если ключ был проассоциирован
    со значением [val]. Если один и тот же ключ проассоциирован с несколькими
    значениями, [find] вернёт самое первое, которое он встретит. *)

Fixpoint find (x : id) (d : partial_map) : natoption :=
  match d with
  | empty         => None
  | record y v d' => if eqb_id x y
                     then Some v
                     else find x d'
  end.

(** **** Упражнение: 1 звезда, стандартное (update_eq) *)
Theorem update_eq :
  forall (d : partial_map) (x : id) (v: nat),
    find x (update d x v) = Some v.
Proof.
 (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** **** Упражнение: 1 звезда, стандартное (update_neq) *)
Theorem update_neq :
  forall (d : partial_map) (x y : id) (o: nat),
    eqb_id x y = false -> find x (update d y o) = find x d.
Proof.
 (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)
End PartialMap.

(* ################################################################# *)
(** * Poly: полиморфизм и функции высшего порядка *)

(* В последний раз напомню: пожалуйста, не публикуйте решения упражнений
   в легко доступных местах.  Спасибо!! *)

(* Спрячем некоторые неприятные предупреждения от Coq: *)
Set Warnings "-notation-overridden,-parsing,-deprecated-hint-without-locality".

(* ################################################################# *)
(** * Полиморфизм *)

(** В этой части лекции мы продолжаем наше изучение базовых концепций
    функционального программирования.  Главные идеи на сегодня --
    _полиморфизм_ (абстрагирование функций от конкретных типов данных,
    с которыми они работают) и _функции высшего порядка_ (работа с функциями
    как с данными).  Начнём с полиморфизма. *)

(* ================================================================= *)
(** ** Полиморфные списки *)

(** В первой части лекции, мы работали только со списками, содержащими
    числа.  Очевидно, интересным программам также нужно уметь работать со
    списками, элементы которых могут браться из других типов -- списки
    логических значений, списки списков и т.д..  Мы _могли бы_ просто определять
    по индуктивному типу данных на каждый из случаев, как-то вот так... *)

Inductive boollist : Type :=
  | bool_nil
  | bool_cons (b : bool) (l : boollist).

(** ... на это Вас очень быстро утомит, во-первых потому что Вам придётся
    придумывать новые имена для конструкторов каждого типа данных, но ещё и
    потому, что Вам придётся заново определять все функции для работы со
    списками ([length], [rev] и т.д.), и, более того, заново доказывать все их
    свойства ([rev_length], [app_assoc] и т.д.) для каждого нового определения
    типа данных. *)

(** Чтобы избежать таких самоповторов, Coq поддерживает _полиморфные_
    определения индуктивных типов.  Например, вот тип данных _полиморфных
    списков_. *)

Inductive list (X:Type) : Type :=
  | nil
  | cons (x : X) (l : list X).

(** Это определение в точности такое же, как определение [natlist] из
    первой части лекции, разве что тип [nat] аргумента в конструкторе [cons]
    был заменён на [X], где имя [X] вводится как имя аргумента в заголовке
    определения; наконец, вхождения [natlist] в типы конструкторов были заменены
    на [list X].

    Какого рода штукой является сам [list]?  Хороший способ думать о ней такой:
    определение [list] -- это _функция_ из [Типов] в [Индуктивные] определения;
    или, короче говоря, [list] это функция из [Типов] в [Типы].  Для любого
    конкретного типа [X], тип [list X] это [Индуктивно] определённое множество
    списков, чьи элементы имеют тип [X]. *)

Check list : Type -> Type.

(** [X] из определения [list] автоматически становится параметром
    конструкторов [nil] и [cons] -- то есть, [nil] и [cons] теперь являются
    полиморфными конструкторами; когда мы их используем, мы теперь должны
    предоставлять первый аргумент -- собственно, тип элементов списка, который
    мы строим. Например, [nil nat] конструирует пустой список
    с элементами типа [nat]. *)

Check (nil nat) : list nat.

(** Похожим образом, [cons nat] добавляет элемент типа [nat] к списку типа
    [list nat]. Вот пример формирования списка, содержащего единственное
    натуральное число 3. *)

Check (cons nat 3 (nil nat)) : list nat.

(** Какой же может быть тип у [nil]? Можно попробовать прочитать его из
    определения [list X], но оно опускает ввод [X], являющегося параметром для
    [list]. [Type -> list X], в свою очередь, не объясняет, откуда берётся [X].
    [(X : Type) -> list X] -- уже ближе. Нотация в Coq следующая:
    [forall X : Type, list X]. *)

Check nil : forall X : Type, list X.

(** Аналогично, тип [cons] из определения выглядит похоже на
    [X -> list X -> list X], но, используя тот же принцип, требующий
    объяснить происхождение [X], приводит к типу
    [forall X, X -> list X -> list X]. *)

Check cons : forall X : Type, X -> list X -> list X.

(** (Заметка о нотации: в файлах .v, квантор "forall" пишется явно,
    буквами.  В соответствующих файлах HTML (а также в том, как некоторые IDE
    показывают файлы .v -- зависит от их настроек отображения), [forall] обычно
    отображается как стандартное математическое "перевёрнутое A," однако вы всё
    равно увидите явное "forall" в паре мест.  Это просто причуды генерации
    текста -- разницы в значении нет.) *)

(** То, что нам приходится указывать аргумент-тип при каждом использовании
    конструктора списка достаточно утруждающе; далее мы увидим, как можно
    облегчить нотацию. *)

Check (cons nat 2 (cons nat 1 (nil nat)))
      : list nat.

(** Теперь мы можем оглядеться, вернуться и выписать полиморфные версии
    всех функций, работающих со списками, которые мы определили ранее.  Вот,
    например, [repeat]: *)

Fixpoint repeat (X : Type) (x : X) (count : nat) : list X :=
  match count with
  | 0 => nil X
  | S count' => cons X x (repeat X x count')
  end.

(** Как было с [nil] и [cons], мы можем использовать [repeat], применяя
    его сначала к типу, а затем к элементу этого типа (и числу): *)

Example test_repeat1 :
  repeat nat 4 2 = cons nat 4 (cons nat 4 (nil nat)).
Proof. reflexivity. Qed.

(** Чтобы использовать [repeat] для построения списков других типов, мы
    просто _инстанциируем_ его с подходящим типовым параметром: *)

Example test_repeat2 :
  repeat bool false 1 = cons bool false (nil bool).
Proof. reflexivity. Qed.

(** **** Упражнение: 2 звезды, стандартное, необязательное (mumble_grumble)

    Рассмотрим следующие два индуктивных типа данных. *)

Module MumbleGrumble.

Inductive mumble : Type :=
  | a
  | b (x : mumble) (y : nat)
  | c.

Inductive grumble (X:Type) : Type :=
  | d (m : mumble)
  | e (x : X).

(** Какие из следующих значений имеют тип [grumble X] для некоторого [X]?
    (Допишите ДА или НЕТ к каждой строчке.)
      - [d (b a 5)]
      - [d mumble (b a 5)]
      - [d bool (b a 5)]
      - [e bool true]
      - [e mumble (b c 0)]
      - [e bool (b c 0)]
      - [c]  *)
(* ЗАПОЛНИТЕ ЗДЕСЬ *)
End MumbleGrumble.
(** [] *)

(* ----------------------------------------------------------------- *)
(** *** Вывод аннотаций типов *)

(** Давайте вновь выпишем определение [repeat], но в этот раз мы не будем
    указывать типы аргументов.  Примет ли Coq такое определение? *)

Fixpoint repeat' X x count : list X :=
  match count with
  | 0        => nil X
  | S count' => cons X x (repeat' X x count')
  end.

(** Ну конечно.  Посмотрим, какой же тип он выдал [repeat']... *)

Check repeat'
  : forall X : Type, X -> nat -> list X.
Check repeat
  : forall X : Type, X -> nat -> list X.

(** У него в точности такой же тип, как и у [repeat].  Coq оказался
    способен использовать _вывод типов_, чтобы выяснить, какие типы должны быть
    у [X], [x] и [count] на основе того, как они используются.  Например, раз
    [X] используется как аргумент [cons], он должен быть [Типом], ведь
    [cons] своим первым аргументом ожидает [Type]; сопоставление [count]
    с [0] и [S] значит, что он должен быть [nat]; и так далее.

    Это мощное свойство системы значит, что нам не придётся всегда и везде
    выписывать все аннотации типов; однако, явные аннотации типов всё ещё могут
    быть полезны для документации и проверок на осмысленность, так что мы всё же
    продолжим их использовать бОльшую часть времени. *)

(* ----------------------------------------------------------------- *)
(** *** Синтез типового аргумента *)

(** Чтобы использовать полиморфную функцию, нам нужно передать ей
    какое-то количество типов помимо её остальных аргументов. Например,
    рекурсивный вызов в теле функции [repeat] должен передать тип [X].
    Но раз второй аргумент функции [repeat] обязан быть элементом [X],
    выглядит совершенно очевидным, что первый аргумент может быть равен
    только [X] -- зачем же нам тогда выписывать его явно?

    К счастью, Coq позволяет нам избежать такого рода повторов. Вместо любого
    типового аргумента мы можем написать "дырку" [_], которую можно прочитать
    как "Пожалуйста, постарайся выяснить сам, что сюда нужно подставить".
    Точнее говоря, когда Coq встречает [_], он будет пытаться _унифицировать_
    всю локально доступную информацию -- тип применяемой функции, типы других
    аргументов, а также тип, ожидаемый контекстом, в котором появляется
    применение -- чтобы выяснить, какой конкретный тип должен стоять
    на месте [_].

    Это может звучать знакомо к выводу типовых аннотаций -- и, действительно,
    обе процедуры полагаются на одни и те же базовые механизмы. Вместо того,
    чтобы просто опустить типы некоторых аргументов функции, вроде

      repeat' X x count : list X :=

    мы точно так же можем заменить типы дырками

      repeat' (X : _) (x : _) (count : _) : list X :=

    чтобы попросить Coq попытаться вывести недостающую информацию.

    Используя дырки, функцию [repeat] можно записать вот так: *)

Fixpoint repeat'' X x count : list X :=
  match count with
  | 0        => nil _
  | S count' => cons _ x (repeat'' _ x count')
  end.

(** В данном случае мы особо не сэкономили, записав [_] вместо [X].
    Однако во многих случаях разница в объёме кода и читаемости нетривиальная.
    Например, пусть мы хотим выписать список, содержащий числа [1], [2], [3].
    Вместо такого... *)

Definition list123 :=
  cons nat 1 (cons nat 2 (cons nat 3 (nil nat))).

(** ...мы можем использовать дырки, чтобы записать тот же список вот так: *)

Definition list123' :=
  cons _ 1 (cons _ 2 (cons _ 3 (nil _))).

(* ----------------------------------------------------------------- *)
(** *** Неявные аргументы *)

(** На самом деле, мы можем пойти ещё дальше и вообще не писать [_] в
    большинстве случаев, попросив Coq _всегда_ выводить типовые аргументы
    некоторой функции.

    Директива [Arguments] сообщает имя функции (либо конструктора) и далее
    перечисляет имена аргументов (начиная с первых), которые нужно считать
    неявными; каждое такое имя окружено фигурными скобками. *)

Arguments nil {X}.
Arguments cons {X}.
Arguments repeat {X}.

(** Теперь в данном примере нам вообще не нужно указывать типовые аргументы: *)

Definition list123'' := cons 1 (cons 2 (cons 3 nil)).

(** В качестве альтернативы, мы можем объявить аргумент неявным ещё на
    этапе объявдения функции, окружив его в фигурные скобки вместо круглых.
    Например: *)

Fixpoint repeat''' {X : Type} (x : X) (count : nat) : list X :=
  match count with
  | 0        => nil
  | S count' => cons x (repeat''' x count')
  end.

(** (Обратите внимание, что нам даже не нужно было предоставлять типовой
    аргумент в рекурсивном вызове [repeat'''].  Действительно, было бы
    некорректно его предоставлять, поскольку Coq его и не ожидает.)

    Мы будем использовать такой стиль везде, где это возможно, но мы продолжим
    использовать явные объявления [Argument] для конструкторов [Индуктивных]
    типов данных.  Причина заключается в том, что, объявив параметр индуктивного
    типа неявным, мы сделаем параметр неявным не только для конструкторов, но и
    для самого объявления типа.  Например, рассмотрим следующее альтернативное
    определение [list]: *)

Inductive list' {X:Type} : Type :=
  | nil'
  | cons' (x : X) (l : list').

(** Поскольку [X] объявлен неявным для _всего_ определения индуктивного типа,
    включая сам [list'], мы теперь вынуждены писать просто [list'] вне
    зависимости от того, о каких списках мы говорим, вместо того чтобы
    писать [list' nat], [list' bool] или что-то ещё; это шаг слишком далеко. *)

(** Давайте завершим, переопределив некоторые стандартные функции на
    полимфорных списках... *)

Fixpoint app {X : Type} (l1 l2 : list X) : list X :=
  match l1 with
  | nil      => l2
  | cons h t => cons h (app t l2)
  end.

Fixpoint rev {X:Type} (l:list X) : list X :=
  match l with
  | nil      => nil
  | cons h t => app (rev t) (cons h nil)
  end.

Fixpoint length {X : Type} (l : list X) : nat :=
  match l with
  | nil => 0
  | cons _ l' => S (length l')
  end.

Example test_rev1 :
  rev (cons 1 (cons 2 nil)) = (cons 2 (cons 1 nil)).
Proof. reflexivity. Qed.

Example test_rev2:
  rev (cons true nil) = cons true nil.
Proof. reflexivity. Qed.

Example test_length1: length (cons 1 (cons 2 (cons 3 nil))) = 3.
Proof. reflexivity. Qed.

(* ----------------------------------------------------------------- *)
(** *** Явная передача типовых аргументов *)

(** Всё же есть одна небольшая проблема с объявлением аргументов неявными;
    она состоит в том, что иногда у Coq всё же нет достаточной локальной
    информации, чтобы определить типовой аргумент; в таких случаях нужно
    сообщить Coq, что прям вот в это случае мы хотем передать аргумент явно.
    Для этого, предположим, мы напишем следующее: *)

Fail Definition mynil := nil.

(** (Квалификатор [Fail] (который здесь перед [Definition]) можно
    использовать вместе с _любой_ командой. Его используют, чтобы убедиться, что
    исполнение команды действительно завершается ошибкой. В случае, если это
    действительно так, Coq печатает соответствующее сообщение об ошибке, но
    продолжает дальнейшую обработку файла.)

    Здесь Coq возвращает ошибку потому, что он не знает, какой типовой аргумент
    нужно подставить в [nil]. Мы можем помочь ему, предъявив явную аннотацию
    типа (так что у Coq-а станет доступно больше информации, когда он доберётся
    до "применения" [nil]): *)

Definition mynil : list nat := nil.

(** Также можно сделать все аргументы явными,
    добавив [@] перед именем функции. *)

Check @nil : forall X : Type, list X.

Definition mynil' := @nil nat.

(** Используя синтез аргументов и неявные аргументы, мы можем определить
    удобную нотацию для списков, как раньше.  Так как мы сделали типовые
    аргументы конструкторов неявными, Coq будет автоматически их выводить, когда
    мы будем эти нотации использовать. *)

Notation "x :: y" := (cons x y)
                     (at level 60, right associativity).
Notation "[ ]" := nil.
Notation "[ x ; .. ; y ]" := (cons x .. (cons y []) ..).
Notation "x ++ y" := (app x y)
                     (at level 60, right associativity).

(** Теперь списки можно записывать ровно так, как хотелось бы: *)

Definition list123''' := [1; 2; 3].

(* ----------------------------------------------------------------- *)
(** *** Упражнения *)

(** **** Упражнение: 2 звезды, стандартное (poly_exercises)

    Ниже приведено несколько простых упражнений, в точности таких же, как в
    первой части лекции, чтобы попрактиковаться с полиморфизмом.
    Закончите доказательства ниже. *)

Theorem app_nil_r : forall (X:Type), forall l:list X,
  l ++ [] = l.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Theorem app_assoc : forall A (l m n:list A),
  l ++ m ++ n = (l ++ m) ++ n.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Lemma app_length : forall (X:Type) (l1 l2 : list X),
  length (l1 ++ l2) = length l1 + length l2.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** **** Упражнение: 2 звезды, стандартное (more_poly_exercises)

    Вот несколько упражнений слегка поинтереснее... *)

Theorem rev_app_distr: forall X (l1 l2 : list X),
  rev (l1 ++ l2) = rev l2 ++ rev l1.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Theorem rev_involutive : forall X : Type, forall l : list X,
  rev (rev l) = l.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(* ================================================================= *)
(** ** Полиморфные пары *)

(** Следуя тому же паттерну, определение пар чисел, которое мы дали в
    первой части занятия, можно обобщить до _полиморфных пар_, часто называемых
    _произведением_: *)

Inductive prod (X Y : Type) : Type :=
| pair (x : X) (y : Y).

Arguments pair {X} {Y}.

(** Как и со списками, мы делаем типовые аргументы неявными и определяем
    уже знакомую нам нотацию. *)

Notation "( x , y )" := (pair x y).

(** Мы вновь можем воспользоваться механизмом [Нотаций], чтобы определить
    стандартную нотацию для _типов-произведений_ (т.е. типов пар): *)

Notation "X * Y" := (prod X Y) : type_scope.

(** (Аннотация [: type_scope] сообщает Coq-у, что это сокращение
    можно использовать только при синтаксическом разборе типов, но не при
    разборе выражений.  Это позволяет избежать коллизий
    с символом умножения.) *)

(** Поначалу, [(x,y)] и [X*Y] легко перепутать. Помните, что [(x,y)]
    -- это _значение_, построенное из двух других значений, когда как [X*Y]
    -- это _тип_, построенный из двух других типов.  Если [x] имеет тип [X],
    а [y] имеет тип [Y], тогда [(x,y)] имеет тип [X*Y]. *)

(** Первая и вторая проекции теперь выглядят примерно так же, как бы они
    выглядели в любом другом функциональном языке программирования. *)

Definition fst {X Y : Type} (p : X * Y) : X :=
  match p with
  | (x, y) => x
  end.

Definition snd {X Y : Type} (p : X * Y) : Y :=
  match p with
  | (x, y) => y
  end.

(** Следующая функция принимает два списка и комбинирует их в список пар.
    В других функциональных ЯП, её часто называют [zip]; мы называем её
    [combine] для консистентности со стандартной библиотекой Coq. *)

Fixpoint combine {X Y : Type} (lx : list X) (ly : list Y)
           : list (X*Y) :=
  match lx, ly with
  | [], _ => []
  | _, [] => []
  | x :: tx, y :: ty => (x, y) :: (combine tx ty)
  end.

(** **** Упражнение: 1 звезда, стандартное, необязательное (combine_checks)

    Попробуйте сначала ответить на следующие вопросы на бумаге, а затем
    проверьте ваши ответы в Coq:
    - Какой тип имеет функция [combine] (т.е., что печатает команда
      [Check @combine])?
    - Что получится, если применить следующую команду:

        Compute (combine [1;2] [false;false;true;true]).
*)
(** [] *)

(** **** Упражнение: 2 звезды, стандартное, особенно полезное (split)

    Функция [split] -- _правая обратная_ к [combine]: она получает список пар
    и возвращает пару списков.  Во многих функциональных ЯП она называется
    [unzip].

    Заполните определение [split] ниже.  Убедитесь, что она проходит
    предоставленный юнит-тест. *)

Fixpoint split {X Y : Type} (l : list (X*Y)) : (list X) * (list Y)
  (* ЗАМЕНИТЕ ЭТУ СТРОЧКУ ":= _вашим_определением_ ." *). Admitted.

Example test_split:
  split [(1,false);(2,false)] = ([1;2],[false;false]).
Proof.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(* ================================================================= *)
(** ** Полиморфные частичные значения *)

(** В этот раз остановимся на _полиморфном типе частичных значений_,
    обобщающем [natoption] из первой части лекции.  (Мы помещаем определение
    в отдельный модуль, потому что стандартная библиотека уже определяет
    [option], который мы собственно и хотим использовать в дальнейшем.) *)

Module OptionPlayground.

Inductive option (X:Type) : Type :=
  | Some (x : X)
  | None.

Arguments Some {X}.
Arguments None {X}.

End OptionPlayground.

(** Теперь мы можем переписать [nth_error] так, что она сработает с любым
    типом списков. *)

Fixpoint nth_error {X : Type} (l : list X) (n : nat)
                   : option X :=
  match l with
  | nil => None
  | a :: l' => match n with
               | O => Some a
               | S n' => nth_error l' n'
               end
  end.

Example test_nth_error1 : nth_error [4;5;6;7] 0 = Some 4.
Proof. reflexivity. Qed.
Example test_nth_error2 : nth_error [[1];[2]] 1 = Some [2].
Proof. reflexivity. Qed.
Example test_nth_error3 : nth_error [true] 2 = None.
Proof. reflexivity. Qed.

(** **** Упражнение: 1 звезда, стандартное, необязательное (hd_error_poly)

    Завершите определение полиморфной версии функции [hd_error]
    из первой части лекции. Убедитесь, что она проходит юнит-тесты ниже. *)

Definition hd_error {X : Type} (l : list X) : option X
  (* ЗАМЕНИТЕ ЭТУ СТРОЧКУ ":= _вашим_определением_ ." *). Admitted.

(** Опять же, чтобы сделать все аргументы функции явными,
    можно поставить [@] перед именем функции. *)

Check @hd_error : forall X : Type, list X -> option X.

Example test_hd_error1 : hd_error [1;2] = Some 1.
 (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
Example test_hd_error2 : hd_error  [[1];[2]]  = Some [1].
 (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(* ################################################################# *)
(** * Функции в качестве данных *)

(** Как и в большинстве современных языков программирования (особенно
    в "функциональных" ЯП, включая OCaml, Haskell, Racket, Scala,
    Clojure и т.д.), функции в Coq являются _объектами первого класса_,
    что позволяет как передавать их в качестве аргументов другим функциям,
    так и возвращать в качестве результата,
    хранить их в структурах данных и т.д.. *)

(* ================================================================= *)
(** ** Функции высшего порядка *)

(** Функции, манипулирующие другими функциями, часто называются
    функциями _высшего порядка_.  Вот один из примеров: *)

Definition doit3times {X : Type} (f : X->X) (n : X) : X :=
  f (f (f n)).

(** Здесь, аргумент [f] сам является функцией (из [X] в [X]);
    тело [doit3times] применяет [f] трижды к некоторому значению [n]. *)

Check @doit3times : forall X : Type, (X -> X) -> X -> X.

Example test_doit3times: doit3times minustwo 9 = 3.
Proof. reflexivity. Qed.

Example test_doit3times': doit3times negb true = false.
Proof. reflexivity. Qed.

(* ================================================================= *)
(** ** Фильтрация списка *)

(** Вот пример более полезной функции высшего порядка, по списку
    элементов типа [X] и _предикату_ на [X] (функции из [X] в [bool])
    "фильтрующей" этот список, т.е. возвращающей новый список, содержащий
    в точности те элементы исходного списка, на которых предикат возвращает
    [true]. *)

Fixpoint filter {X:Type} (test: X->bool) (l:list X) : list X :=
  match l with
  | [] => []
  | h :: t =>
    if test h then h :: (filter test t)
    else filter test t
  end.

(** Например, если мы применим [filter] к предикату [even] и списку чисел
    [l], она вернёт список, содержащий только чётные элементы [l]. *)

Example test_filter1: filter even [1;2;3;4] = [2;4].
Proof. reflexivity. Qed.

Definition length_is_1 {X : Type} (l : list X) : bool :=
  (length l) =? 1.

Example test_filter2:
    filter length_is_1
           [ [1; 2]; [3]; [4]; [5;6;7]; []; [8] ]
  = [ [3]; [4]; [8] ].
Proof. reflexivity. Qed.

(** Мы можем использовать [filter], чтобы сформулировать более
    краткую версию функции [countoddmembers], определённой ранее. *)

Definition countoddmembers' (l:list nat) : nat :=
  length (filter odd l).

Example test_countoddmembers'1:   countoddmembers' [1;0;3;1;4;5] = 4.
Proof. reflexivity. Qed.
Example test_countoddmembers'2:   countoddmembers' [0;2;4] = 0.
Proof. reflexivity. Qed.
Example test_countoddmembers'3:   countoddmembers' nil = 0.
Proof. reflexivity. Qed.

(* ================================================================= *)
(** ** Анонимные функции *)

(** Немного грустно, что в примере выше нам пришлось выделить целое
    _определение_ на функцию [length_is_1] (и выдать ей имя) только для того,
    чтобы передать её в качестве аргумента в [filter] и больше никогда не
    использовать.  Более того, это не какой-то особый отдельный случай:
    используя функции высшего порядка, мы часто хотим передавать такие
    "одноразовые" функции, которые мы ни разу больше не будем использовать;
    выдавать каждый раз какое-то имя каждой из этих функций было бы излишне и
    утомительно.

    К счастью, у нас есть способ получше.  Мы можем сконструировать функцию
    "на лету" без её именования и объявления на верхнем уровне. *)

Example test_anon_fun':
  doit3times (fun n => n * n) 2 = 256.
Proof. reflexivity. Qed.

(** Выражение [(fun n => n * n)] можно прочитать как "функция, которая, получив
    число [n], возвращает [n * n]." *)

(** Ниже пример использования [filter], переписанный с использованием
    анонимной функции. *)

Example test_filter2':
    filter (fun l => (length l) =? 1)
           [ [1; 2]; [3]; [4]; [5;6;7]; []; [8] ]
  = [ [3]; [4]; [8] ].
Proof. reflexivity. Qed.

(** **** Упражнение: 2 звезды, стандартное (filter_even_gt7)

    Используйте [filter] (вместо [Fixpoint]), чтобы написать функцию
    [filter_even_gt7], по списку натуральных чисел [l] возвращающую список
    элементов [l], больших 7 (и только их). *)

Definition filter_even_gt7 (l : list nat) : list nat
  (* ЗАМЕНИТЕ ЭТУ СТРОЧКУ ":= _вашим_определением_ ." *). Admitted.

Example test_filter_even_gt7_1 :
  filter_even_gt7 [1;2;6;9;10;3;12;8] = [10;12;8].
 (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Example test_filter_even_gt7_2 :
  filter_even_gt7 [5;2;6;19;129] = [].
 (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** **** Упражнение: 3 звезды, стандартное (partition)

    Используя [filter], напишите функцию [partition]:

      partition : forall X : Type,
                  (X -> bool) -> list X -> list X * list X

   По множеству [X], предикату типа [X -> bool] и [list X],
   [partition] должна возвращать пару списков.  Первая компонента этой пары --
   подпоследовательность исходного списка, содержащая элементы, удовлетворяющие
   предикату (и только их), а вторая -- наоборот, ему не удовлетворяющие.
   Порядок элементов в этих двух подсписках должен быть таким же, каким он был в
   исходном списке. *)

Definition partition {X : Type}
                     (test : X -> bool)
                     (l : list X)
                   : list X * list X
  (* ЗАМЕНИТЕ ЭТУ СТРОЧКУ ":= _вашим_определением_ ." *). Admitted.

Example test_partition1: partition odd [1;2;3;4;5] = ([1;3;5], [2;4]).
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
Example test_partition2: partition (fun x => false) [5;9;0] = ([], [5;9;0]).
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(* ================================================================= *)
(** ** Поэлементное отображение *)

(** Следующая полезная функция высшего порядка называется [map]. *)

Fixpoint map {X Y : Type} (f : X->Y) (l : list X) : list Y :=
  match l with
  | []     => []
  | h :: t => (f h) :: (map f t)
  end.

(** Она получает функцию [f] и список [ l = [n1, n2, n3, ...] ],
    и возвращает [ [f n1, f n2, f n3,...] ], т.е. [f] применили
    к списку [l] поэлементно.  Например: *)

Example test_map1: map (fun x => plus 3 x) [2;0;2] = [5;3;5].
Proof. reflexivity. Qed.

(** Типы элементов исходного и результирующего списков не обязаны
    совпадать, поскольку [map] принимает _два_ типовых аргумента, [X] и [Y];
    например, [map] можно применить к списку чисел и функции, по числу
    возвращающей логическое значение, и получить список логических значений: *)

Example test_map2:
  map odd [2;1;2;5] = [false;true;false;true].
Proof. reflexivity. Qed.

(** И, конечно, её можно применить к списку чисел и функции из чисел в
    _списки_ логических значений; в результате получится _список списков_
    логических значений: *)

Example test_map3:
    map (fun n => [even n;odd n]) [2;1;2;5]
  = [[true;false];[false;true];[true;false];[false;true]].
Proof. reflexivity. Qed.

(* ----------------------------------------------------------------- *)
(** *** Упражнения *)

(** **** Упражнение: 3 звезды, стандартное (map_rev)

    Покажите, что [map] и [rev] коммутируют.  Возможно, вам понадобится ввести
    вспомогательную лемму. *)

Theorem map_rev : forall (X Y : Type) (f : X -> Y) (l : list X),
  map f (rev l) = rev (map f l).
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** **** Упражнение: 2 звезды, стандартное, особенно полезное (flat_map)

    Функция [map] отображает [list X] в [list Y], используя функцию типа
    [X -> Y].  Мы можем определить похожую функцию, [flat_map], которая
    отображает [list X] в [list Y], используя функцию [f] типа [X -> list Y].
    Ваше определение должно 'сплющить' результаты [f] следующим образом:

        flat_map (fun n => [n;n+1;n+2]) [1;5;10]
      = [1; 2; 3; 5; 6; 7; 10; 11; 12].
*)

Fixpoint flat_map {X Y: Type} (f: X -> list Y) (l: list X)
                   : list Y
  (* ЗАМЕНИТЕ ЭТУ СТРОЧКУ ":= _вашим_определением_ ." *). Admitted.

Example test_flat_map1:
  flat_map (fun n => [n;n;n]) [1;5;4]
  = [1; 1; 1; 5; 5; 5; 4; 4; 4].
 (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** Списки -- не единственный индуктивный тип, для которого можно осмысленно
    определить [map]. Вот определение [map] для типа [option]: *)

Definition option_map {X Y : Type} (f : X -> Y) (xo : option X)
                      : option Y :=
  match xo with
  | None => None
  | Some x => Some (f x)
  end.

(** **** Упражнение: 2 звезды, стандартное, необязательное (implicit_args)

    Определения и использования [filter] и [map] используют неявные аргументы
    в множестве мест.  Замените фигурные скобки вокруг неявных аргументов
    обычными (круглыми) скобками, а замтем дозаполните явные типовые параметры
    везде, где это нужно, и используйте Coq для самопроверки.  (Это упражнение
    НЕ НУЖНО сдавать; пожалуй, проще всего сделать это в _копии_ этого файла,
    которую потом можно будет с облегчением удалить.)
*)
(** [] *)

(* ================================================================= *)
(** ** Свёртка *)

(** Ещё более мощную функцию высшего порядка называют [fold].
    Эта операция послужила вдохновением и основой для операции "[reduce]",
    лежащей в самом сердце map/reduce, фреймворка для распределённого
    программирования от Google. *)

Fixpoint fold {X Y: Type} (f : X->Y->Y) (l : list X) (b : Y)
                         : Y :=
  match l with
  | nil => b
  | h :: t => f h (fold f t b)
  end.

(** На уровне интуиции, [fold] "вставляет" полученную бинарную операцию
    [f] между каждой парой элементов в переданном списке.  Например,
    [ fold plus [1;2;3;4] ] по сути значит то же, что [1+2+3+4].  Чтобы сделать
    эту интуицию точной, нужно также не забыть про "начальный элемент" который
    служит первоначальным аргументом для [f] (на лекции Ваш покорный слуга
    называл его "зерном"/"начальным состоянием").  Так, например,

       fold plus [1;2;3;4] 0

    упрощается до

       1 + (2 + (3 + (4 + 0))).

    Ещё немного разных примеров: *)

Check (fold andb) : list bool -> bool -> bool.

Example fold_example1 :
  fold andb [true;true;false;true] true = false.
Proof. reflexivity. Qed.

Example fold_example2 :
  fold mult [1;2;3;4] 1 = 24.
Proof. reflexivity. Qed.

Example fold_example3 :
  fold app  [[1];[];[2;3];[4]] [] = [1;2;3;4].
Proof. reflexivity. Qed.

Example foldexample4 :
  fold (fun l n => length l + n) [[1];[];[2;3;2];[4]] 0 = 5.
Proof. reflexivity. Qed.


(** **** Упражнение: 1 звезда, стандартное, необязательное (fold_types_different)

    Заметьте, что тип [fold] параметризован _двумя_ типовыми переменными,
    [X] and [Y], а [f] -- это бинарный оператор, по [X] и [Y] возвращающий [Y].
    Можете ли вы представить себе такую ситуацию, в которой было бы полезно, что
    [X] и [Y] -- разные типы? *)

(* ЗАПОЛНИТЕ ЗДЕСЬ

    [] *)

(* ================================================================= *)
(** ** Функции, конструирующие функции *)

(** Большинство функций высшего порядка, которые мы обсудили на данный
    момент, получали функции в качестве аргументов. Теперь же давайте посмотрим
    на парочку примеров, в которых функции являются _результатом_ других функций
    и возвращаются из них в качестве значения. Для начала, вот функция, которая
    по значению [x] некоторого типа [X] возвращает функцию из [nat] в [X],
    всегда возвращающую [x], полностью игнорируя свой аргумент типа [nat]. *)

Definition constfun {X: Type} (x: X) : nat -> X :=
  fun (k:nat) => x.

Definition ftrue := constfun true.

Example constfun_example1 : ftrue 0 = true.
Proof. reflexivity. Qed.

Example constfun_example2 : (constfun 5) 99 = 5.
Proof. reflexivity. Qed.

(** По сути, функции от нескольких аргументов, виденные нами ранее
    (ещё на первой лекции), тоже являются примерами ситуаций, в которых функции
    передаются как данные. Чтобы увидеть, почему, напомню Вам тип функции
    [plus]. *)

Check plus : nat -> nat -> nat.

(** На самом деле, каждая [->] в этом выражении -- это _бинарный_ оператор
    на типах.  Этот оператор _правоассоциативен_, так что выведенный Coq-ом тип
    [plus] -- это, на самом деле, сокращение от [nat -> (nat -> nat)], т.е. его
    можно прочитать как "[plus] это функция от одного аргумента, по [nat]
    возвращающая другую функцию от одного аргумента, которая, в свою очередь, по
    ещё одному [nat] возвращает, наконец, [nat]."  В примерах выше, мы всегда
    применяли [plus] к обоим аргументам сразу, но, если мы захотим, мы можем
    передать только один аргумент.  Это называется _частичным применением_. *)

Definition plus3 := plus 3.
Check plus3 : nat -> nat.

Example test_plus3 :    plus3 4 = 7.
Proof. reflexivity. Qed.
Example test_plus3' :   doit3times plus3 0 = 9.
Proof. reflexivity. Qed.
Example test_plus3'' :  doit3times (plus 3) 0 = 9.
Proof. reflexivity. Qed.

(* ################################################################# *)
(** * Дополнительные упражнения *)

Module Exercises.

(** **** Упражнение: 2 звезды, стандартное (fold_length)

    Многие часто используемые функции на списках можно определить в терминах
    [fold].  Например, ниже дано альтернативное определение [length]: *)

Definition fold_length {X : Type} (l : list X) : nat :=
  fold (fun _ n => S n) l 0.

Example test_fold_length1 : fold_length [4;7;0] = 3.
Proof. reflexivity. Qed.

(** Докажите корректность [fold_length].  (Подсказка: возможно, вам поможет
    знание о том, что [reflexivity] упрощает выражения слегка более аггрессивно,
    чем [simpl] -- т.е., достаточно легко оказаться в ситуации, в которой
    [simpl] ничего не делает, а [reflexivity] решает текущую цель.) *)

Theorem fold_length_correct : forall X (l : list X),
  fold_length l = length l.
Proof.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** **** Упражнение: 3 звезды, стандартное (fold_map)

    Также легко определить [map] в терминах [fold].  Завершите определение
    [fold_map], объявленной ниже. *)

Definition fold_map {X Y: Type} (f: X -> Y) (l: list X) : list Y
  (* ЗАМЕНИТЕ ЭТУ СТРОЧКУ ":= _вашим_определением_ ." *). Admitted.

(** Сформулируйте теорему [fold_map_correct], утверждающую, что [fold_map]
    корректна, и докажите её с помощью Coq.  (Подсказка: опять же, имейте в
    виду, что [reflexivity] упрощает выражения слегка аггрессивнее, чем
    [simpl].) *)

(* ЗАПОЛНИТЕ ЗДЕСЬ *)

(* Do not modify the following line: *)
Definition manual_grade_for_fold_map : option (nat*string) := None.
(** [] *)

(** **** Упражнение: 2 звезды, продвинутое (currying)

    Тип [X -> Y -> Z] можно прочитать как тип, описывающий функции, принимающие
    два аргумента (один типа [X] и другой типа [Y]) и возвращающие результат
    типа [Z]. Строго говоря, если расставить все скобки, этот тип на самом деле
    выглядит как [X -> (Y -> Z)].  То есть, если у нас есть [f : X -> Y -> Z],
    и мы передаём [f] вход типа [X], она вернёт нам функцию типа [Y -> Z].
    Если мы затем уже этой функции передадим на вход что-либо, имеющее тип [Y],
    она вернёт нам результат типа [Z].  Таким образом, все функции в Coq
    принимают на вход только один аргумент, просто некоторые из возвращают
    функцию в качестве результата.  В точности благодаря этому механизму в Coq
    есть частичное применение, с которым мы познакомились выше, в [plus3].

    В свою очередь, функции типа [X * Y -> Z] (с полной расстановкой скобок этот
    тип пишется как [(X * Y) -> Z]) требуют своим единственным входом пару
    (типа [X * Y]).  Оба аргумента должны быть переданы одновременно; для
    функции с таким типом возможностей для частичного применения нет.

    Однако заметим, что функции этих двух типов можно конвертировать между
    собой. Так, конвертация из [X * Y -> Z] в [X -> Y -> Z] называется
    _каррирование_, в честь логика Хаскелла Карри.  Конвертация в обратную
    сторону, из [X -> Y -> Z] в [X * Y -> Z], называется _раскаррирование_
    (uncurrying).  *)

(** Мы можем определить каррирование следующим образом: *)

Definition prod_curry {X Y Z : Type}
  (f : X * Y -> Z) (x : X) (y : Y) : Z := f (x, y).

(** В качестве упражнения, постройте обратную функцию, [prod_uncurry].
    Затем докажите две теоремы ниже, что, действительно,
    [prod_curry] и [prod_uncurry] обратны друг другу. *)

Definition prod_uncurry {X Y Z : Type}
  (f : X -> Y -> Z) (p : X * Y) : Z
  (* ЗАМЕНИТЕ ЭТУ СТРОЧКУ ":= _вашим_определением_ ." *). Admitted.

(** В качестве (тривиального) примера полезности каррирования, мы можем
    использовать его, чтобы сократить один из примеров выше: *)

Example test_map1': map (plus 3) [2;0;2] = [5;3;5].
Proof. reflexivity. Qed.

(** Мысленный эксперимент: перед запуском следующих команд, можете ли вы
    вычислить в уме типы [prod_curry] и [prod_uncurry]? *)

Check @prod_curry.
Check @prod_uncurry.

Theorem uncurry_curry : forall (X Y Z : Type)
                        (f : X -> Y -> Z)
                        x y,
  prod_curry (prod_uncurry f) x y = f x y.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Theorem curry_uncurry : forall (X Y Z : Type)
                        (f : (X * Y) -> Z) (p : X * Y),
  prod_uncurry (prod_curry f) p = f p.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** **** Упражнение: 2 звезды, продвинутое (nth_error_informal)

    Вспомним определение функции [nth_error]:

   Fixpoint nth_error {X : Type} (l : list X) (n : nat) : option X :=
     match l with
     | [] => None
     | a :: l' => if n =? O then Some a else nth_error l' (pred n)
     end.

   Выпишите аккуратное неформальное доказательство следующей теоремы:

   forall X l n, length l = n -> @nth_error X l n = None

   Убедитесь, что предположение гипотезы Вами сформулировано _явно_.
*)
(* ЗАПОЛНИТЕ ЗДЕСЬ *)

(* Do not modify the following line: *)
Definition manual_grade_for_informal_proof : option (nat*string) := None.
(** [] *)

(* ================================================================= *)
(** ** Church Numerals (Advanced) *)

(** Следующие упражнения исследуют альтернативный способ построения натуральных
    чисел с использованием _нумералов Чёрча_, названных в честь их создателя,
    математика Алонзо Чёрча.  Основная идея заключается в том, что мы можем
    представить натуральное число [n] в виде функции высшего порядка,
    принимающей некоторую функцию [f] в качестве параметра и возвращающей [f],
    итерированную [n] раз. *)

Module Church.
Definition cnat := forall X : Type, (X -> X) -> X -> X.

(** Посмотрим, как же писать числа в такой нотации.
    Итерировать функцию единожды -- то же самое, что просто её применить.
    Так что: *)

Definition one : cnat :=
  fun (X : Type) (f : X -> X) (x : X) => f x.

(** Похожим образом, [два] должно применять [f] дважды: *)

Definition two : cnat :=
  fun (X : Type) (f : X -> X) (x : X) => f (f x).

(** Определить [zero] в каком-то смысле сложнее: как можно "применить функцию
    0 раз"?  Ответ на самом деле простой:
    просто возвращаем аргумент как есть. *)

Definition zero : cnat :=
  fun (X : Type) (f : X -> X) (x : X) => x.

(** Обобщая, число [n] можно записать как [fun X f x => f (f
    ... (f x) ...)], с [n] вхождениями [f] в выражение.  Давайте (неформально)
    обобзначать это как [fun X f x => f^n x], и договоримся, что [f^0 x]
    это просто [x]. Обратите внимание, что функция [doit3times] с лекции
    оказывается нумералом Чёрча для числа [3]. *)

Definition three : cnat := @doit3times.

(** Так, [n X f x] представляет "сделать ЭТО [n] раз", где [n] это нумерал
    Чёрча, а "ЭТО" значит применить [f], начиная с [x].

    Другой способ думать об этом следующий: внутри нумерала Чёрча, функция [f]
    это как будто бы "операция взятия следующего" в множестве [X], а значение
    [x] -- это "ноль". Переименуем аргументы, чтобы это стало более явным: *)

Definition zero' : cnat :=
  fun (X : Type) (succ : X -> X) (zero : X) => zero.
Definition one' : cnat :=
  fun (X : Type) (succ : X -> X) (zero : X) => succ zero.
Definition two' : cnat :=
  fun (X : Type) (succ : X -> X) (zero : X) => succ (succ zero).

(** Если мы передадим [S] в качестве [succ], а [O] в качестве [zero], в
    результате мы получим в точности соответствующие натуральные числа: *)

Example zero_church_peano : zero nat S O = 0.
Proof. reflexivity. Qed.

Example one_church_peano : one nat S O = 1.
Proof. reflexivity. Qed.

Example two_church_peano : two nat S O = 2.
Proof. reflexivity. Qed.

(** Самое интересное следствие из этого построения -- то, что в функциональном
    языке программирования нам не то что бы нужны натуральные числа в качестве
    примитива; более того, их не обязательно определять через индуктивные типы.
    Вполне возможно реализовать их чисто через функции (хотя, конечно, не очень
    эффективно).

    Конечно, нам недостаточно создать _представление_ нумералов (то, как они
    определяются и выглядят в Coq); нам также необходимо выполнять с ними
    арифметические операции. Покажите, что это возможно, завершив определения
    следующих функций.

    Убедитесь, что соответствующие юнит-тесты выполняются (доказываются) с
    помощью [reflexivity]. *)

(** **** Упражнение: 2 звезды, продвинутое (church_scc) *)

(** Определите функцию, вычисляющую последователя нумерала Чёрча.
    Используя нумерал Чёрча [n], его последователь [scc n] должен итерировать
    свой аргумент-функцию на один раз больше, чем [n]. Так, получив
    [fun X f x => f^n x] на вход, [scc] должен возвращать
    [fun X f x => f^(n+1) x] в качестве результата. Другими словами,
    "сделай ЭТО [n] раз, затем ещё раз". *)

Definition scc (n : cnat) : cnat
  (* ЗАМЕНИТЕ ЭТУ СТРОЧКУ ":= _вашим_определением_ ." *). Admitted.

Example scc_1 : scc zero = one.
Proof. (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Example scc_2 : scc one = two.
Proof. (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Example scc_3 : scc two = three.
Proof. (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

(** [] *)

(** **** Упражнение: 3 звезды, продвинутое (church_plus) *)

(** Определите функцию, вычисляющую сумму двух нумералов Чёрча. Получив
    [fun X f x => f^n x] и [fun X f x => f^m x] в качестве входа, [plus]
    должен вернуть [fun X f x => f^(n + m) x].
    Другими словами, "сделать ЭТО [n] раз, затем ещё [m] раз".

    Подсказка: "нулевой" аргумент в нумерале Чёрча не обязан быть одним и тем же
    [x] во всех нумералах Чёрча, они могут начинать с разных значений. *)

Definition plus (n m : cnat) : cnat
  (* ЗАМЕНИТЕ ЭТУ СТРОЧКУ ":= _вашим_определением_ ." *). Admitted.

Example plus_1 : plus zero one = one.
Proof. (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Example plus_2 : plus two three = plus three two.
Proof. (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Example plus_3 :
  plus (plus two two) three = plus one (plus three three).
Proof. (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

(** [] *)

(** **** Упражнение: 3 звезды, продвинутое (church_mult) *)

(** Определите функцию, вычисляющую произведение двух нумералов Чёрча.

    Подсказка: аргумент-функция в нумерале Чёрча не обязан всегда быть одним
    и тем же [f].

    Предупреждение: Coq не позволит вам передать сам [cnat] в качестве типового
    аргумента [X] в нумерале Чёрча; вы получите ошибку про так называемую
    "Universe inconsistency".  Таким образом Coq предотвращает парадоксы,
    вызванные типами, которые содержат сами себя. Так что используйте везде один
    и тот же [X]. *)

Definition mult (n m : cnat) : cnat
  (* ЗАМЕНИТЕ ЭТУ СТРОЧКУ ":= _вашим_определением_ ." *). Admitted.

Example mult_1 : mult one one = one.
Proof. (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Example mult_2 : mult zero (plus three three) = zero.
Proof. (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Example mult_3 : mult two three = plus three three.
Proof. (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

(** [] *)

(** **** Упражнение: 3 звезды, продвинутое (church_exp) *)

(** Экспонента: *)

(** Определите функцию, возводящую один нумерал Чёрча в степень другого.

    Подсказка: типовой аргумент в нумерале Чёрча не обязан быть одним и тем же
    в разных использованиях разных аргументов.  Но, опять же, мы не можем
    передать сам [cnat] в качестве аргумента; подобрать правильный типовой
    аргумент может быть сложно. *)

Definition exp (n m : cnat) : cnat
  (* ЗАМЕНИТЕ ЭТУ СТРОЧКУ ":= _вашим_определением_ ." *). Admitted.

Example exp_1 : exp two two = plus two two.
Proof. (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Example exp_2 : exp three zero = one.
Proof. (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Example exp_3 : exp three two = plus (mult two (mult two two)) one.
Proof. (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

(** [] *)

End Church.
End Exercises.

(* 2025-03-22 23:44 *)
